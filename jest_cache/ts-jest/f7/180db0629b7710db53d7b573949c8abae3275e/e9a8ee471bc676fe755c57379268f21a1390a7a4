[["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/api.create.e2e.ts",{"fileContent":"import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { options } from '@therootnetwork/api';\ndescribe('e2e api create', () => {\n\n  it('Find lock balance for rootnet validator', async () => {\n      const providerUrl = 'wss://root.rootnet.live/ws';\n      const provider = new WsProvider(providerUrl);\n      console.log('providerUrl', providerUrl);\n      const api = new ApiPromise(options({ provider }));\n      await api.isReady;\n    const validator = \"0x0Fa787f51333D9cA66a4A6563b56EececDA49a06\";\n    const lockBalance = await api.query.balances.locks(validator);\n    expect((lockBalance.toJSON())[0].amount).toBeGreaterThanOrEqual(0);\n    await api.disconnect();\n  });\n\n  // it('Should get rejected if the connection fails', async () => {\n  //   const incorrectEndPoint = 'wss://unknow.chain.io/ws';\n  //   const autoConnect = false;\n  //   const provider = new WsProvider(incorrectEndPoint, autoConnect);\n  //   const api = new ApiPromise(options({provider: provider}));\n  //   await expect(api.isReady).rejects.toThrow('Timed out in 10000 ms.');\n  // });\n\n  it('subscription test', async () => {\n      const providerUrl = 'wss://root.rootnet.live/ws';\n      const provider = new WsProvider(providerUrl);\n      console.log('providerUrl', providerUrl);\n      const api = new ApiPromise(options({ provider }));\n      await api.isReady;\n    const unsubscribe = await api.rpc.chain.subscribeNewHeads((header) => {\n      console.log(`Chain is at block: #${header.number}`);\n      expect(header.number).toBeDefined();\n      unsubscribe();\n      api.disconnect();\n    });\n  });\n});\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/src/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/index.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/nft.e2e.ts",{"fileContent":"import {ApiPromise, Keyring, WsProvider} from \"@polkadot/api\";\nimport {options} from \"@therootnetwork/api\";\nimport {hexToU8a, stringToHex} from \"@polkadot/util\";\n\nexport const ALITH_PRIVATE_KEY = \"0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133\";\nexport const BOB_PRIVATE_KEY = \"0x79c3b7fc0b7697b9414cb87adcb37317d1cab32818ae18c0e97ad76395d1fdcf\";\nconst TOKEN_ID = 1124;\nexport const GAS_TOKEN_ID = 2;\nlet collectionOwner, tokenOwner;\nlet globalCollectionId;\nlet globalTokenIds;\n\ndescribe('DEX RPC calls testing', () => {\n    let api;\n    let alith, bob;\n    beforeAll(async () => {\n        const providerUrl = 'ws://127.0.0.1:9944/';\n        const provider = new WsProvider(providerUrl);\n        api = new ApiPromise(options({provider}));\n        await api.isReady;\n        const keyring = new Keyring({type: \"ethereum\"});\n        alith = keyring.addFromSeed(hexToU8a(ALITH_PRIVATE_KEY));\n        bob = keyring.addFromSeed(hexToU8a(BOB_PRIVATE_KEY));\n        collectionOwner = alith;\n    });\n\n    afterAll(async () => {\n        api.disconnect();\n    });\n\n    describe('NFTs', () => {\n        let collectionId: number;\n\n        beforeEach(async () => {\n            // Create collection and series for each test to use\n            const collectionName = 'global-example-collection';\n            const quantity = 3;\n            const maxIssuance = null;\n            const tokenOwner = null;\n            const royalty = null;\n            const crossChainCompatibility = {\"xrpl\": false};\n            globalTokenIds = [...Array(quantity)]\n            const metadataSchema = \"http://example.com/nft/metadata\";\n            await api.tx.nft.createCollection(\n                collectionName, quantity,\n                maxIssuance, tokenOwner, metadataSchema, royalty, crossChainCompatibility\n            ).signAndSend(collectionOwner, async ({status, events}) => {\n                if (status.isInBlock) {\n                    events.forEach(({event: {data, method}}) => {\n                        if (method == 'CreateCollection') {\n                            globalCollectionId = data[0].toNumber();\n                        }\n                    });\n\n                    await api.tx.nft.mint(globalCollectionId, quantity, tokenOwner.address)\n                        .signAndSend(collectionOwner, {nonce: -1}, async ({status, events}) => {\n                            if (status.isInBlock) {\n                                events.forEach(({event: {data, method}}) => {\n                                    if (method == 'Mint') {\n                                        const collectionId = data[0].toNumber()\n                                        let seriesId = data[1].toNumber();\n                                        globalTokenIds = globalTokenIds.map((_, serialNumber) => [collectionId, seriesId, serialNumber])\n                                    }\n                                });\n                            }\n                        });\n                }\n            });\n        });\n\n          it('creates a collection', async () => {\n              const collectionName = 'example-collection';\n              const quantity = 3;\n              const maxIssuance = null;\n              const tokenOwner = null;\n              const royalty = null;\n              const crossChainCompatibility = {\"xrpl\": false};\n              const metadataSchema = \"http://example.com/nft/metadata\";\n            await api.tx.nft.createCollection(\n              collectionName, quantity,\n                maxIssuance, tokenOwner, metadataSchema, royalty, crossChainCompatibility\n            ).signAndSend(collectionOwner, {nonce: -1},async ({ status, events }) => {\n              if (status.isInBlock) {\n                events.forEach(({phase, event: {data, method, section}}) => {\n                  console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n                  if (method == 'CreateCollection') {\n                    collectionId = data[0].toNumber();\n                    console.log(`got collection: ${collectionId}`);\n                  }\n                });\n                const info = await api.query.nft.collectionInfo(collectionId);\n                expect(info.owner).toBe(collectionOwner.address);\n                expect(info.name).toBe(stringToHex(collectionName));\n              }\n            });\n          });\n\n\n\n  it('burn second token from series', async () => {\n    const serialNumber = 1;\n    const tokenId = [1124, serialNumber];\n    await api.tx.nft.burn(tokenId)\n      .signAndSend(collectionOwner, {nonce: -1}, async ({ status, events }) => {\n        if (status.isInBlock) {\n          events.forEach(({event: {data, method}}) => {\n            if (method == 'Burn') {\n              const [collId, serialNo ] = data;\n              expect(collId.toNumber()).toEqual(globalCollectionId);\n              expect(serialNo.toNumber()).toEqual(serialNumber);\n            }\n          });\n        }\n      });\n  });\n\n  it.skip('finds collected tokens', async () => {\n     const cursor = 0;\n     const limit = 5;\n    const ownedTokens = (await api.rpc.nft.ownedTokens(globalCollectionId, collectionOwner.address, cursor , limit)).toJSON();\n    console.log('ownedTokens::',ownedTokens);\n    expect(ownedTokens[2]).toEqual([0, 1, 2]);\n  });\n});\n\n    /// TODO - add more test for listing buy/sell\n});\n\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/src/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/index.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/staking.e2e.ts",{"fileContent":"// // Copyright 2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import {Api} from \"@cennznet/api\";\n// import { AccountId, Forcing, RewardDestination, StakingLedger, ValidatorPrefs, Option } from '@cennznet/types';\n// import { Keyring } from '@polkadot/keyring';\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n//\n// import initApiPromise from '../../../../jest/initApiPromise';\n//\n// let api;\n// const keyring = new Keyring({ type: 'sr25519' });\n// let alice, bob;\n//\n// beforeAll(async () => {\n//   await cryptoWaitReady();\n//   api = await initApiPromise();\n//   alice = keyring.addFromUri('//Alice');\n//   bob = keyring.addFromUri('//Bob');\n// });\n//\n// afterAll(async () => {\n//   await api.disconnect();\n// });\n//\n// describe('Staking derived queries', () => {\n//\n//   test('test elected validators info for local chain', async done =>{\n//     const electedValidatorInfo = await api.derive.stakingCennznet.electedInfo();\n//     const {info, nextElected, validators} = electedValidatorInfo;\n//     expect(info).toBeDefined();\n//     expect(info[0].accountId.toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     expect(info[0].controllerId.toString()).toEqual('5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY');\n//     expect(info[0].exposure.total.toNumber()).toEqual(1000000);\n//     expect(info[0].exposure.own.toNumber()).toEqual(1000000);\n//     expect(info[0].exposure.others.length).toEqual(0);\n//     expect(info[0].nominators.length).toEqual(0);\n//     expect(info[0].rewardDestination.toString()).toEqual('Stash');\n//     expect(info[0].stashId.toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     expect(nextElected.length).toBeGreaterThanOrEqual(1);\n//     expect(validators.length).toBeGreaterThanOrEqual(1);\n//     done();\n//   })\n//\n//   test('test waiting validators info query', async done =>{\n//     const waitingValidatorsToBeElected = await api.derive.stakingCennznet.waitingInfo();\n//     const {info, waiting} = waitingValidatorsToBeElected;\n//     expect(info.length).toEqual(0);\n//     expect(waiting.length).toEqual(0);\n//     done();\n//   })\n//\n//   test('validators info', async done => {\n//     const validatorDetails = await api.derive.stakingCennznet.validators();\n//     expect(validatorDetails.nextElected[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     expect(validatorDetails.validators[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     done();\n//   })\n//\n//   test('get all validators', async done => {\n//     const validatorList = await api.derive.stakingCennznet.stashes();\n//     expect(validatorList[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     done();\n//   })\n//\n//   test('test staking overview query', async done => {\n//     const validatorOverview = await api.derive.stakingCennznet.overview();\n//     expect(validatorOverview.activeEra.toString()).toEqual('0');\n//     expect(validatorOverview.activeEraStart.unwrap().toNumber()).toBeGreaterThanOrEqual(0);\n//     expect(validatorOverview.currentEra.toString()).toEqual('0');\n//     expect(validatorOverview.currentIndex.toNumber()).toBeGreaterThanOrEqual(0);\n//     expect(validatorOverview.validatorCount.toString()).toEqual('2');\n//     expect(validatorOverview.nextElected[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     expect(validatorOverview.validators[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     done();\n//   })\n// });\n//\n// describe('Staking Operations', () => {\n//   // Note: order of test execution matters here\n//   let stash, controller;\n//\n//   beforeAll(async done => {\n//     stash = keyring.addFromUri('//Test//Stash');\n//     controller = keyring.addFromUri('//Test//Controller');\n//\n//     // Fund stash and controller\n//     const stakingId = await api.query.genericAsset.stakingAssetId();\n//     const spendingId = await api.query.genericAsset.spendingAssetId();\n//     let nonce = await api.rpc.system.accountNextIndex(alice.address);\n//\n//     // How much to fund stash and controller with\n//     const initialEndowment = 100_000_000;\n//\n//     // controller needs CPAY\n//     await api.tx.genericAsset\n//       .mint(spendingId, controller.address, initialEndowment)\n//       .signAndSend(alice, { nonce: nonce++ });\n//     // stash needs CENNZ and CPAY\n//     await api.tx.genericAsset\n//       .mint(spendingId, stash.address, initialEndowment)\n//       .signAndSend(alice, { nonce: nonce++ });\n//     await api.tx.genericAsset\n//       .mint(stakingId, stash.address, initialEndowment)\n//       .signAndSend(alice, { nonce }, ({ status }) => status.isInBlock ? done() : null);\n//\n//   });\n//\n//   test('Bond locks caller funds and assigns a controller account', async done => {\n//     const bond = (await api.query.staking.minimumBond()) + 12_345;\n//\n//     await api.tx.staking.bond(controller.address, bond, 'controller').signAndSend(stash, async ({ status }) => {\n//       if (status.isInBlock) {\n//         expect((await api.query.staking.bonded(stash.address)).toString()).toEqual(controller.address);\n//         const payee = await api.query.rewards.payee(stash.address);\n//         expect(payee.toString()).toEqual(controller.address);\n//         const ledger = ((await api.query.staking.ledger(controller.address)) as Option<StakingLedger>).unwrap();\n//         expect(ledger.active.toString()).toEqual(bond);\n//         expect(ledger.total.toString()).toEqual(bond);\n//\n//         done();\n//       }\n//     });\n//\n//   });\n//\n//   test('Bond extra locks additional funds', async done => {\n//\n//     const additionalBond = 333;\n//     const previousLedger = ((await api.query.staking.ledger(controller.address)) as Option<StakingLedger>).unwrap();\n//\n//     // Subscribe to ledger value changes\n//     await api.query.staking.ledger(controller.address, (ledgerOpt: Option<StakingLedger>) => {\n//       const ledger = ledgerOpt.unwrapOr(null);\n//       if (ledger?.active.toNumber() === (previousLedger.active.toNumber() + additionalBond)) {\n//         done();\n//       }\n//     });\n//\n//     await api.tx.staking.bondExtra(additionalBond).signAndSend(stash);\n//   });\n//\n//   test('Unbond schedules some funds to unlock', async done => {\n//     const unbondAmount = 500;\n//     const previousLedger = ((await api.query.staking.ledger(controller.address)) as Option<StakingLedger>).unwrap();\n//\n//     // Subscribe to ledger value changes\n//     await api.query.staking.ledger(controller.address, (ledgerOpt: Option<StakingLedger>) => {\n//       const ledger = ledgerOpt.unwrapOr(null);\n//       if (ledger?.active.toNumber() === (previousLedger.active.toNumber() - unbondAmount)) {\n//         done();\n//       }\n//     });\n//\n//     await api.tx.staking.unbond(unbondAmount).signAndSend(controller);\n//   });\n//\n//   /// Rebond a portion of the stash scheduled to be unlocked.\n//   test('Rebond locks funds again', async done => {\n//     const rebondAmount = 300;\n//     const previousLedger = ((await api.query.staking.ledger(controller.address)) as Option<StakingLedger>).unwrap();\n//\n//     // Subscribe to ledger value changes\n//     await api.query.staking.ledger(controller.address, (ledgerOpt: Option<StakingLedger>) => {\n//       const ledger = ledgerOpt.unwrapOr(null);\n//       if (ledger?.active.toNumber() === (previousLedger.active.toNumber() + rebondAmount)) {\n//         done();\n//       }\n//     });\n//\n//     await api.tx.staking.rebond(rebondAmount).signAndSend(controller);\n//   });\n//\n//   test('Withdraw unbonded', async done => {\n//     await api.tx.staking.withdrawUnbonded().signAndSend(controller, ({ status, events }) => {\n//       if (status.isInBlock) {\n//         expect(\n//           events.find(wrapper => wrapper.event.method === 'ExtrinsicSuccess')\n//         ).toBeDefined();\n//         done();\n//       }\n//     });\n//   });\n//\n//   test('Validate adds stash as a validator candidate', async done => {\n//     // parts per billion\n//     // 100,000,000 / 1,000,000,000 == 0.1%\n//     const commission = 1_000_000_000;\n//\n//     const checkCommission = async ({ status }) => {\n//       if (status.isInBlock) {\n//         const prefs = ((await api.query.staking.validators(stash.address)) as ValidatorPrefs);\n//         expect(prefs.commission.toNumber()).toEqual(commission);\n//         done();\n//       };\n//     };\n//\n//     await api.tx.staking.validate({ commission }).signAndSend(controller, checkCommission);\n//   });\n//\n//   test('Chill removes stash from validator candidacy', async done => {\n//\n//     const checkCommission = async ({ status }) => {\n//       if (status.isInBlock) {\n//         const prefs = ((await api.query.staking.validators(stash.address)) as ValidatorPrefs);\n//         expect(prefs.commission.toNumber()).toEqual(0);\n//         done();\n//       };\n//     };\n//\n//     await api.tx.staking.chill().signAndSend(controller, checkCommission);\n//   });\n//\n//   test('setPayee changes reward destination', async done => {\n//     // Payee account should be set to controller after prior bond() test.\n//     const payee = await api.query.rewards.payee(stash.address);\n//     expect(payee.toString()).toEqual(controller.address);\n//\n//     // Subscribe to payee changes\n//     await api.query.rewards.payee(stash.address, (payee) => {\n//       payee.toString() === stash.address ? done() : null\n//     });\n//\n//     await api.tx.staking.setPayee('stash').signAndSend(controller);\n//   });\n//\n//   test('Payout to any account', async done => {\n//     const rewardDestinationAddress = '5FEe8Ht1ZTzNjQcvrxbLxnykA2EXfqN5LMog2gaNPus4tfZR';\n//     // Payee account set to any account\n//     await api.tx.staking.setPayee({ account: rewardDestinationAddress }).signAndSend(controller);\n//     // Subscribe to payee changes\n//     await api.query.rewards.payee(stash.address, (payee: RewardDestination) => {\n//       (payee.toString() === rewardDestinationAddress) ? done() : null\n//     });\n//   });\n//\n//   test('setController changes controller account', async done => {\n//     // NB: ensure to run this test last as it changes the controller account.\n//     const newController = keyring.addFromUri('//NewController');\n//\n//     // Subscribe to controller account value changes\n//     await api.query.staking.bonded(stash.address, (controllerOpt: Option<AccountId>) => {\n//       const controllerAddress = keyring.encodeAddress(controllerOpt.unwrap());\n//       if (controllerAddress === newController.address) {\n//         done();\n//       }\n//     });\n//\n//     await api.tx.staking.setController(newController.address).signAndSend(stash);\n//   });\n//\n//   test('Calculate accruedPayout via RPC', async done => {\n//     const aliceStash = keyring.addFromUri('//Alice//stash');\n//     const accruedPayout = await api.rpc.staking.accruedPayout(aliceStash.address);\n//     expect(accruedPayout.toNumber()).toBe(0);\n//     done();\n//   });\n//\n//   test('check received heat beat on azalea', async done => {\n//     const apiAzalea = await Api.create({ network: 'azalea' });\n//     const recentlyOnline = await apiAzalea.derive.stakingCennznet.receivedHeartbeats();\n//     for (const [key] of Object.entries(recentlyOnline)) {\n//       const validator = recentlyOnline[key];\n//       expect(validator.blockCount.toNumber()).toBeGreaterThanOrEqual(0);\n//     }\n//     await apiAzalea.disconnect();\n//     done();\n//   });\n//\n// });\n//\n// describe('Staking Governance (Sudo Required)', () => {\n//\n//   afterAll(async done => {\n//     // Ensure era forcing is disabled\n//     await api.tx.sudo.sudo(api.tx.staking.forceNewEra())\n//       .signAndSend(alice, ({ status }) => status.isInBlock ? done() : null);\n//   });\n//\n//   test('Set target validator count', async done => {\n//     const validatorCount = 15;\n//     const setValidatorTx = api.tx.staking.setValidatorCount(validatorCount);\n//\n//     await api.tx.sudo.sudo(setValidatorTx).signAndSend(alice, async ({ status }) => {\n//       if (status.isInBlock) {\n//         expect((await api.query.staking.validatorCount()).toString()).toEqual(validatorCount.toString());\n//         done();\n//       }\n//     });\n//   });\n//\n//   test('Set minimum bond', async done => {\n//     const minimumBond = 1_234;\n//     const setMinimumBondTx = api.tx.staking.setMinimumBond(minimumBond);\n//\n//     await api.tx.sudo.sudo(setMinimumBondTx).signAndSend(alice, async ({ status }) => {\n//       if (status.isInBlock) {\n//         expect((await api.query.staking.minimumBond()).toString()).toEqual(minimumBond.toString());\n//         done();\n//       }\n//     });\n//   });\n//\n//\n//   test('Set invulnerable validators', async done => {\n//     const invulnerables: AccountId[] = keyring.getPairs().map(p => p.publicKey as AccountId);\n//     const setInvulnerablesTx = api.tx.staking.setInvulnerables(invulnerables);\n//\n//     await api.tx.sudo.sudo(setInvulnerablesTx).signAndSend(alice, async ({ status }) => {\n//       if (status.isInBlock) {\n//         expect(\n//           (await api.query.staking.invulnerables()).map(k => keyring.encodeAddress(k))\n//         ).toEqual(\n//           invulnerables.map(k => keyring.encodeAddress(k))\n//         );\n//         done();\n//       }\n//     });\n//   });\n//\n//   test('Force no eras', async done => {\n//     await api.query.staking.forceEra(\n//       (forcing: Forcing) => {\n//         if (forcing.isForceNone) done();\n//       }\n//     );\n//     await api.tx.sudo.sudo(api.tx.staking.forceNoEras()).signAndSend(alice);\n//   });\n//\n//   test('Force new era', async done => {\n//     const transactionFeePot = await api.query.rewards.transactionFeePotHistory();\n//     expect(transactionFeePot).toBeDefined();\n//     expect(transactionFeePot.length).toEqual(0); // Transaction fee pot is empty [] without call to noteFeePayout/makeRewardPayout\n//     await api.query.staking.forceEra(\n//       (forcing: Forcing) => {\n//         if (forcing.isForceNew) done();\n//       }\n//     );\n//     await api.tx.sudo.sudo(api.tx.staking.forceNewEra()).signAndSend(alice);\n//   });\n//\n//   test('Force new era always', async done => {\n//     await api.query.staking.forceEra(\n//       (forcing: Forcing) => {\n//         if (forcing.isForceAlways) done();\n//       }\n//     );\n//     await api.tx.sudo.sudo(api.tx.staking.forceNewEraAlways()).signAndSend(alice);\n//   });\n//\n//   test('Force unstake', async done => {\n//     const bobStash = keyring.addFromUri('//Bob//stash');\n//     new Promise<void>(async (resolve) => {\n//       // bond bob's stash account.\n//       await api.tx.staking.bond(bob.address, 10_000, 'controller')\n//           .signAndSend( bobStash, async ({ status }) => {\n//             if (status.isInBlock) {\n//                   const controller = (await api.query.staking.bonded(bobStash.address)) as Option<AccountId>;\n//                   expect(controller.unwrapOr(null)).toBeDefined();\n//                   resolve();\n//             }\n//           });\n//     }).then(async () => {\n//       const unstake = api.tx.staking.forceUnstake(bobStash.address);\n//       await api.tx.sudo.sudo(unstake).signAndSend(alice);\n//         // bob stash is removed / unbonded\n//       await api.query.staking.bonded(bobStash.address, (controller: Option<AccountId>) =>\n//         (controller.unwrapOr(null) === null) ? done() : null);\n//     });\n//   });\n//\n//   test('test azalea nominators', async done =>{\n//     const apiAzalea: Api = await Api.create({network: 'azalea'});\n//     const accountId = '5HnB5MbbAcbVvGQqvoHVDa5r9L1tyCChSGjKQ1awNojRGxb8';\n//     const nominators = await apiAzalea.query.staking.nominators(accountId);\n//     const nominatorList = nominators.unwrap();\n//     expect(nominatorList.targets.length).toBeGreaterThanOrEqual(0);\n//     expect(nominatorList.submittedIn.toNumber()).toBeGreaterThan(0);\n//     const validatorDetails = await apiAzalea.query.staking.validators(accountId);\n//     expect(validatorDetails.commission).toBeDefined();\n//     await apiAzalea.disconnect();\n//     done();\n//   });\n//\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/ethBridge.e2e.ts",{"fileContent":"// import { awaitDepositClaim, ClaimDeposited, extractEthereumSignature } from \"@cennznet/api/util/helper\";\n// import { encodeAddress } from \"@polkadot/util-crypto\";\n// import { Keyring } from '@polkadot/keyring';\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n// import {AssetId, Balance, EventClaimId} from \"@cennznet/types\";\n// import initApiPromise from '../../../../jest/initApiPromise';\n// import {Api} from \"@cennznet/api\";\n//\ndescribe('Eth bridge test', () => {});\n//   let api, alice, aliceStash, bob, testTokenId1, testTokenId2;\n//\n//   beforeAll(async done => {\n//     await cryptoWaitReady();\n//     const keyring = new Keyring({type: 'sr25519'});\n//     alice = keyring.addFromUri('//Alice');\n//     aliceStash = keyring.addFromUri('//Alice//stash')\n//     bob = keyring.addFromUri('//Bob');\n//     api = await initApiPromise();\n//     const transaction1 = api.tx.erc20Peg.activateDeposits(true);\n//     const transaction2 = api.tx.erc20Peg.activateWithdrawals(true);\n//     const transaction3 = api.tx.erc20Peg.setContractAddress('0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512');\n//     const transaction4 = api.tx.ethBridge.setEventConfirmations(0); // Hardhat only makes blocks when txs are sent\n//     const batchBridgeActivationEx = api.tx.utility.batch([\n//       transaction1,\n//       transaction2,\n//       transaction3,\n//       transaction4\n//     ]);\n//\n//     await api.tx.sudo.sudo(batchBridgeActivationEx).signAndSend(alice, async ({status, events}) => {\n//       if (status.isInBlock) {\n//         events.forEach(({phase, event: {data, method, section}}) => {\n//           console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//         });\n//         done();\n//       }\n//     });\n//   });\n//\n//   afterAll(async () => {\n//     await api.disconnect();\n//   });\n//\n//   describe('Eth bridge claims', () => {\n//\n//     it('Submit claim for test token 1 from BridgeTest account', async done => {\n//       const depositTxHash = \"0xcac398ef5a9ae1e3217954212b1059e9bbe788897ba714950ab4d63a2434137f\";\n//       testTokenId1 = await api.query.genericAsset.nextAssetId();\n//       const depositAmount = \"1423\";\n//       const beneficiaryAcc = \"0xacd6118e217e552ba801f7aa8a934ea6a300a5b394e7c3f42cd9d6dd9a457c10\";\n//       const claim = {\n//         tokenAddress: \"0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9\",\n//         amount: depositAmount,\n//         beneficiary: beneficiaryAcc\n//       };\n//       console.log('New token generated will be::',testTokenId1.toString());\n//       const depositClaimEvent: ClaimDeposited = await awaitDepositClaim(api, depositTxHash, claim, alice) as ClaimDeposited;\n//\n//       const beneficiaryAddress = encodeAddress(beneficiaryAcc, 42); // convert public key to address\n//\n//       const {claimId, assetId, amount, beneficiary} = depositClaimEvent;\n//       expect(claimId).toBeGreaterThanOrEqual(0);\n//       expect(assetId).toEqual(testTokenId1.toString());\n//       expect(amount).toEqual(depositAmount);\n//       expect(beneficiary).toEqual(beneficiaryAddress);\n//       const assetBalance = await api.query.genericAsset.freeBalance(testTokenId1.toNumber(), beneficiaryAddress);\n//       expect(assetBalance.toString()).toBe(depositAmount);\n//       done();\n//   });\n//\n//   it('Submit a wrong claim ', async done => {\n//       const depositTxHash = \"0x028a721fcfd6ffa48e1095294bc26570f61a1866a57b7e6162ddaebe22871608\";\n//       testTokenId1 = await api.query.genericAsset.nextAssetId();\n//       const depositAmount = \"1423\";\n//       const beneficiaryAcc = \"0xacd6118e217e552ba801f7aa8a934ea6a300a5b394e7c3f42cd9d6dd9a457c10\";\n//       const claim = {\n//         tokenAddress: \"0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0\",\n//         amount: depositAmount,\n//         beneficiary: beneficiaryAcc\n//       };\n//       await expect(awaitDepositClaim(api, depositTxHash, claim, alice)).rejects.toEqual(\n//         'Claim deposition failed');\n//       done();\n//     });\n//\n//     it('Submitting same claim again show fail', async done => {\n//       const depositTxHash = \"0xcac398ef5a9ae1e3217954212b1059e9bbe788897ba714950ab4d63a2434137f\";\n//       testTokenId1 = await api.query.genericAsset.nextAssetId();\n//       const depositAmount = \"1423\";\n//       const beneficiaryAcc = \"0xacd6118e217e552ba801f7aa8a934ea6a300a5b394e7c3f42cd9d6dd9a457c10\";\n//       const claim = {\n//         tokenAddress: \"0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9\",\n//         amount: depositAmount,\n//         beneficiary: beneficiaryAcc\n//       };\n//       await expect(awaitDepositClaim(api, depositTxHash, claim, alice)).rejects.toEqual(\n//         'Claim already notarized');\n//       done();\n//     });\n//\n//   it('Submit claim for test token 2 from Alice', async done => {\n//     const depositTxHash = \"0x3ff83f651dfd1b9c5958fbd908b02faa5867ce9ee36e669c5e1ee35a524f5ef4\";\n//     const claim = {\n//       tokenAddress: \"0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9\",\n//       amount: \"5644\",\n//         beneficiary: \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\"\n//     };\n//     let nonce = await api.rpc.system.accountNextIndex(alice.address);\n//     await api.tx.erc20Peg.depositClaim(depositTxHash, claim).signAndSend(alice, {nonce}, async ({status, events}) => {\n//       if (status.isInBlock) {\n//         for (const {event: {method, section, data}} of events) {\n//           console.log('\\t', `: ${section}.${method}`, data.toString());\n//           if (section === 'erc20Peg' && method == 'Erc20Claim') {\n//             const [claimId, claimer] = data;\n//             expect((claimId as EventClaimId).toNumber()).toBeGreaterThanOrEqual(0);\n//             expect(claimer.toString()).toEqual(alice.address);\n//             done();\n//           }\n//         }\n//       }\n//     });\n//   });\n//\n//   it('Submit claim for test token 2 from Bob', async done => {\n//     const depositTxHash = \"0x205193beee5dff848085faaa5b1ef72a9816e1e5020d1c3b616107639313bc9d\";\n//     const claim = {\n//       tokenAddress: \"0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9\",\n//       amount: \"11644\",\n//       beneficiary: \"0x8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48\"\n//     };\n//     let nonce = await api.rpc.system.accountNextIndex(alice.address);\n//     testTokenId2 = await api.query.genericAsset.nextAssetId();\n//     console.log('testTokenId2::',testTokenId2.toString());\n//     await api.tx.erc20Peg.depositClaim(depositTxHash, claim).signAndSend(alice, {nonce}, async ({status, events}) => {\n//       if (status.isInBlock) {\n//         for (const {event: {method, section, data}} of events) {\n//           console.log('\\t', `: ${section}.${method}`, data.toString());\n//           if (section === 'erc20Peg' && method == 'Erc20Claim') {\n//             const [claimId, claimer] = data;\n//             expect((claimId as EventClaimId).toNumber()).toBeGreaterThanOrEqual(0);\n//             expect(claimer.toString()).toEqual(bob.address);\n//             done();\n//           }\n//         }\n//       }\n//     });\n//   });\n//\n// });\n//\n//   describe('Query storage check claimed tokens', () => {\n//\n//     beforeAll(async done => {\n//\n//     // wait for 4 blocks before checking the storage\n//       let count = 0;\n//\n//       const unsubHeads = await api.rpc.chain.subscribeNewHeads((lastHeader) => {\n//         console.log(`chain: last block #${lastHeader.number} has hash ${lastHeader.hash}`);\n//\n//         api.query.system.events((events) => {\n//           console.log(`\\nReceived ${events.length} events:`);\n//\n//           // loop through the Vec<EventRecord>\n//           events.forEach((record) => {\n//             // extract the phase, event and the event types\n//             const { event, phase } = record;\n//             const types = event.typeDef;\n//\n//             // show what we are busy with\n//             console.log(`\\t${event.section}:${event.method}:: (phase=${phase.toString()})`);\n//             console.log('event.meta::', event.meta);\n//             // console.log(`\\t\\t${event.meta.documentation.toString()}`);\n//\n//             // loop through each of the parameters, displaying the type and data\n//             event.data.forEach((data, index) => {\n//               console.log(`\\t\\t\\t${types[index].type}: ${data.toString()}`);\n//             });\n//           });\n//         });\n//         if (++count === 4) {\n//           unsubHeads();\n//           done();\n//         }\n//       });\n//     });\n//\n//     it('Queries registered assets', async done => {\n//\n//       const registeredAsset = await api.rpc.genericAsset.registeredAssets();\n//       console.log(registeredAsset.toJSON());\n//       const hasTestToken1Asset = ([assetId, meta]) => assetId.toString() === testTokenId1.toString() && meta.decimalPlaces.toString() === '18';\n//       const hasTestToken2Asset = ([assetId, meta]) => assetId.toString() === testTokenId2.toString() && meta.decimalPlaces.toString() === '18';\n//       expect(registeredAsset.some(hasTestToken1Asset)).toBe(true);\n//       expect(registeredAsset.some(hasTestToken2Asset)).toBe(true);\n//       done();\n//     });\n//\n//     it('Queries generic asset balance for test token 2 for Alices account', async done => {\n//       const assetBalance = await api.query.genericAsset.freeBalance(testTokenId2.toNumber(), alice.address);\n//       expect(assetBalance.toString()).toBe(\"5644\");\n//       done();\n//     });\n//\n//     it('Queries generic asset balance for test token 2 for Bobs account', async done => {\n//       const assetBalance = await api.query.genericAsset.freeBalance(testTokenId2.toNumber(), bob.address);\n//       expect(assetBalance.toString()).toBe(\"11644\");\n//       done();\n//     });\n//\n//     it('Queries totalIssuance for test token 2', async done => {\n//       const totalIssuance = await api.query.genericAsset.totalIssuance(testTokenId2.toNumber());\n//       expect(totalIssuance.toString()).toBe((11644 + 5644).toString());\n//       done();\n//     });\n//\n//   });\n//\n//\n//   describe('Test RPC subscribe to new clain', () => {\n//     it.skip('Subscribe event proof after mock withdraw', async done => {\n//       let nonce = await api.rpc.system.accountNextIndex(alice.address);\n//       await api.tx.erc20Peg.mockWithdraw().signAndSend(alice, {nonce});\n//       await api.tx.erc20Peg.mockWithdraw().signAndSend(aliceStash);\n//       let count = 0;\n//       const unsubHeads = await api.rpc.ethy.subscribeEventProofs((result: any) => {\n//         console.log('data::', result.toHuman());\n//         expect(result.eventId.toNumber()).toBeGreaterThanOrEqual(0);\n//         if (++count === 1) {\n//           unsubHeads();\n//           done();\n//         }\n//       });\n//     });\n//\n//     it('Withdraw claim for test token 2 from Alice', async done => {\n//       let nonce = await api.rpc.system.accountNextIndex(alice.address);\n//       let amount = 5644;\n//       const ethBeneficiary = '0x70997970c51812dc3a010c7d01b50e0d17dc79c8';\n//       await api.tx.erc20Peg.withdraw(testTokenId2, amount, ethBeneficiary,).signAndSend(alice, {nonce}, async ({status, events}) => {\n//         if (status.isInBlock) {\n//           for (const {event: {method, section, data}} of events) {\n//             console.log('\\t', `: ${section}.${method}`, data.toString());\n//             if (section === 'erc20Peg' && method == 'Erc20Withdraw') {\n//               const [withdrawalId, assetId, amountt, beneficiary] = data;\n//               expect((withdrawalId as EventClaimId).toNumber()).toBeGreaterThanOrEqual(0);\n//               // expect(assetId.toNumber()).toEqual(testTokenId2.toNumber());\n//               expect((amountt as Balance).toNumber()).toEqual(amount);\n//               expect(beneficiary.toString()).toEqual(ethBeneficiary);\n//               done();\n//             }\n//           }\n//         }\n//       });\n//     });\n//\n//     it('Withdraw claim for test token 2 from Bob', async done => {\n//       let nonce = await api.rpc.system.accountNextIndex(bob.address);\n//       let amount = 11644;\n//       const ethBeneficiary = '0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc';\n//       await api.tx.erc20Peg.withdraw(testTokenId2, amount, ethBeneficiary,).signAndSend(bob, {nonce}, async ({status, events}) => {\n//         if (status.isInBlock) {\n//           for (const {event: {method, section, data}} of events) {\n//             console.log('\\t', `: ${section}.${method}`, data.toString());\n//             if (section === 'erc20Peg' && method == 'Erc20Withdraw') {\n//               let count = 0;\n//               const unsubHeads = await api.rpc.ethy.subscribeEventProofs((result: any) => {\n//                 console.log('data::', result.toHuman());\n//                 if (count++ == 1) {\n//                   unsubHeads();\n//                   done();\n//                 }\n//               });\n//               const [withdrawalId, assetId, amountt, beneficiary] = data;\n//               expect((withdrawalId as EventClaimId).toNumber()).toBeGreaterThanOrEqual(0);\n//               expect((assetId as AssetId).toNumber()).toEqual(testTokenId2.toNumber());\n//               expect((amountt as Balance).toNumber()).toEqual(amount);\n//               expect(beneficiary.toString()).toEqual(ethBeneficiary);\n//             }\n//           }\n//         }\n//       });\n//     });\n//\n//     it( 'Get event id from rpc call', async done => {\n//       api = await Api.create({network: 'rata'});\n//       const versionedEventProof = (await api.rpc.ethy.getEventProof('1')).toJSON();\n//       expect(versionedEventProof.eventProof.eventId.toString()).toEqual('1');\n//\n//       const eventProof = await api.derive.ethBridge.eventProof('2');\n//       console.log('Proof::',eventProof);\n//       expect(eventProof.eventId).toEqual('2');\n//       done();\n//     })\n//\n//     it( 'Get r,s,v from signature', async done => {\n//       const sign = api.registry.createType('EthereumSignature', '0x5e0a108f836af7c7aeb832382f0a237709da037abdac72cc16a8a54b77d2bb946bb8e78fd63af7594650b8d1a033046e3d08ad15a0b648a0473263e51fe70e1b01');\n//       const signatures = [sign];\n//       const { r, s, v } = extractEthereumSignature(signatures);\n//\n//       expect(r[0]).toEqual('0x5e0a108f836af7c7aeb832382f0a237709da037abdac72cc16a8a54b77d2bb94');\n//       expect(s[0]).toEqual('0x6bb8e78fd63af7594650b8d1a033046e3d08ad15a0b648a0473263e51fe70e1b');\n//       expect(v[0]).toEqual(28);\n//\n//       done();\n//     })\n//\n//     it(   'Get r,s,v from invalid signature', async done => {\n//       const sign = api.registry.createType('EthereumSignature', '');\n//       const signatures = [sign];\n//       const { r, s, v } = extractEthereumSignature(signatures);\n//       expect(r).toEqual(['0x0000000000000000000000000000000000000000000000000000000000000000']);\n//       expect(s).toEqual(['0x0000000000000000000000000000000000000000000000000000000000000000']);\n//       expect(v[0]).toEqual(27);\n//\n//       done();\n//     })\n//\n//     // this requires migration\n//     it.skip(   'For rata chain get series metadata URI at collection id 29', async done => {\n//       const provider = 'wss://rata.centrality.me/public/ws';\n//\n//       const apiRata = await Api.create({provider});\n//\n//       const metadataPath = (await apiRata.query.nft.seriesMetadataURI(\n//         29,\n//         0\n//       )).toHuman();\n//       // const tokenId = apiRata.registry.createType('TokenId', [29,0,0]);\n//       //\n//       // const uri = await apiRata.rpc.nft.tokenUri(tokenId);\n//       // console.log('metadataPath::',uri.toHuman());\n//       expect(metadataPath).toEqual(\"ipfs://QmWGYnnapNUT9voEx8gyZBXKsSgmWWQXdkCqRrucQ8qdmx\");\n//       await apiRata.disconnect();\n//       done();\n//     })\n//\n//   })\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/tx.e2e.ts",{"fileContent":"// // Copyright 2019-2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import {AssetInfoV40 as AssetInfo, AssetOptions, Balance, LiquidityPriceResponse} from \"@cennznet/types\";\n// import {cvmToAddress} from \"@cennznet/types/utils\";\n// import { SubmittableResult } from '@polkadot/api';\n// import { Keyring } from '@polkadot/keyring';\n// import { KeyringPair } from '@polkadot/keyring/types';\n// import { stringToHex } from '@polkadot/util';\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n// import initApiPromise from '../../../../jest/initApiPromise';\n// import { SingleAccountSigner } from \"./util/SingleAccountSigner\";\n// import { mock } from '@depay/web3-mock'\n//\n// const keyring = new Keyring({ type: 'sr25519' });\n//\ndescribe.skip('e2e transactions', () => {});\n//   let api;\n//   let alice, bob;\n//   let spendingAssetId, stakingAssetId;\n//\n//   beforeAll(async () => {\n//     await cryptoWaitReady();\n//     api = await initApiPromise();\n//     alice = keyring.addFromUri('//Alice');\n//     bob = keyring.addFromUri('//Bob');\n//\n//     spendingAssetId = await api.query.genericAsset.spendingAssetId();\n//     stakingAssetId = await api.query.genericAsset.stakingAssetId();\n//\n//     mock('ethereum');\n//   });\n//\n//   afterAll(async () => {\n//     await api.disconnect();\n//   });\n//\n//   describe('Send', () => {\n//\n//     it('Makes a tx using immortal era', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(bob.address);\n//       await api.tx.genericAsset\n//         .transfer(stakingAssetId, alice.address, 100)\n//         .signAndSend(bob, { nonce },\n//           async ({ events, status }: SubmittableResult) => {\n//             if (status.isInBlock) {\n//               expect(events[0].event.method).toEqual('Transferred');\n//               expect(events[0].event.section).toEqual('genericAsset');\n//               done();\n//             }\n//           });\n//     });\n//\n//     it('Makes a tx via send', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(bob.address);\n//       const tx = api.tx.genericAsset\n//         .transfer(stakingAssetId, alice.address, 1)\n//         .sign(bob, { nonce });\n//       await tx.send(async ({ events, status }: SubmittableResult) => {\n//         if (status.isInBlock) {\n//           expect(events[0].event.method).toEqual('Transferred');\n//           expect(events[0].event.section).toEqual('genericAsset');\n//           done();\n//         }\n//       });\n//     });\n//\n//     it('Makes a tx', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(bob.address);\n//       await api.tx.genericAsset\n//         .transfer(stakingAssetId, alice.address, 1)\n//         .signAndSend(bob, { nonce }, async ({ events, status }: SubmittableResult) => {\n//           if (status.isInBlock) {\n//             expect(events[0].event.method).toEqual('Transferred');\n//             expect(events[0].event.section).toEqual('genericAsset');\n//             done();\n//           }\n//         });\n//     });\n//\n//   });\n//\n//   describe('Eth signining txs', () => {\n//\n//     it('Convert eth address to cennznet address', async done => {\n//       const ethAddress = '0x5D5586341ca72146791C33c26c0c10eD971c9B53';\n//       const cennznetAddress = cvmToAddress(ethAddress);\n//       console.log('cennznetAddress:',cennznetAddress);\n//       expect(cennznetAddress).toEqual('5EK7n4pa3FcCGoxvoqUFJM8CD6fngE31G4rAjqLYW2bXtstn');\n//       done();\n//     });\n//\n//     it('Uses eth wallet to sign', async done => {\n//       const ethAddress = '0x5d5586341ca72146791c33c26c0c10ed971c9b53';\n//       // Find the equivalent CENNZnet address for Ethereum address and send some CPAY to spend on txs\n//       const cennznetAddress = cvmToAddress(ethAddress);\n//       const amount = 100000;\n//       const nonce = await api.rpc.system.accountNextIndex(alice.address);\n//       const fundTransferred = new Promise<void>(async (resolve, reject) => {\n//         await api.tx.genericAsset\n//             .transfer(stakingAssetId, cennznetAddress, amount)\n//             .signAndSend(\n//                 alice,\n//                 { nonce });\n//         await api.tx.genericAsset\n//             .transfer(spendingAssetId, cennznetAddress, amount)\n//             .signAndSend(\n//                 alice,\n//                 { nonce: nonce+1 }, ({ status }) => status.isInBlock ? resolve() : null\n//             );\n//       });\n//       fundTransferred.then(async () => {\n//         // Start with a connected wallet\n//         const accounts = [ethAddress];\n//         mock({\n//           blockchain: 'ethereum',\n//           accounts: {return: accounts},\n//           signature: {\n//             params: [accounts[0], 'sign'],\n//             return: \"0xc8ee1390bc05479bb4e13eb36b46714af19821eb590142e3f8fb7d972f6f31fb070717be960e41e4ec33baf85776c43e5be588916e7c41ee20ad99c6695fa7fa1b\"\n//           }\n//         });\n//\n//\n//         const transferAmt = 20000;\n//         await api.tx.genericAsset\n//             .transfer(stakingAssetId, alice.address, transferAmt)\n//             .signViaEthWallet(\n//                 ethAddress,\n//                 api,\n//                 (global as any).ethereum,  async ({ events, status }: SubmittableResult) => {\n//                   if (status.isInBlock) {\n//                     expect(events[0].event.method).toEqual('Transferred');\n//                     expect(events[0].event.section).toEqual('genericAsset');\n//                     done();\n//                   }\n//                 }\n//             );\n//       });\n//     });\n//   });\n//\n//   describe('Extrinsic payment options', () => {\n//     // A generic asset to be used for fee payment\n//     let feeAssetId;\n//     // This account will own the newly created asset and receive initial issuance\n//     // It will also mint liquidity on CENNZ-X\n//     let assetOwner: KeyringPair;\n//\n//     beforeAll(async done => {\n//       // Setup:\n//       // Create a new generic asset and mint a liquidity pool on CENNZX.\n//       // This fee asset will be used for fee payment in place of the default asset, CPAY.\n//       assetOwner = keyring.addFromUri('//Test//AssetOwner');\n//\n//       // Amount of test asset to create\n//       const initialIssuance = 900_000_000_000_000;\n//       const owner = api.registry.createType('Owner', assetOwner.address, 1); // Owner type is enum with 0 as none/null\n//       const permissions = api.registry.createType('PermissionsV1', { update: owner, mint: owner, burn: owner});\n//       const option = {initialIssuance , permissions};\n//       const assetOption: AssetOptions = api.registry.createType('AssetOptions', option);\n//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'TEST', decimalPlaces: 4, existentialDeposit: 5});\n//       let createAssetTx = api.tx.genericAsset.create(assetOwner.address, assetOption, assetInfo);\n//\n//       // Lookup from keyring (assuming we have added all, on --dev this would be `//Alice`)\n//       const sudoAddress = await api.query.sudo.key();\n//       const sudoKeypair = keyring.getPair(sudoAddress.toString());\n//\n//       // when the new asset is created it will have this ID.\n//       feeAssetId = await api.query.genericAsset.nextAssetId();\n//\n//       // 1) Create the new fee asset\n//       // 2) Mint CPAY to assetOwner to fund subsequent pool liquidity and further transactions.\n//       const assetCreated = new Promise<void>(async (resolve, reject) => {\n//         let nonce = await api.rpc.system.accountNextIndex(sudoAddress);\n//         await api.tx.sudo.sudo(createAssetTx).signAndSend(sudoKeypair, { nonce: nonce++ });\n//         await api.tx.genericAsset.mint(spendingAssetId, assetOwner.address, initialIssuance).signAndSend(\n//           sudoKeypair, { nonce: nonce++ }, ({ status }) => status.isInBlock ? resolve() : null\n//         );\n//       });\n//\n//       // 3) Mint liquidity for fee asset <> CPAY.\n//       assetCreated.then(async () => {\n//         const desiredLiquidity = 30_000_000;\n//         const minimumLiquidity = 1;\n//         const liquidityPrice: LiquidityPriceResponse = await (api.rpc.cennzx.liquidityPrice(feeAssetId, desiredLiquidity));\n//         await api.tx.cennzx\n//           .addLiquidity(feeAssetId, minimumLiquidity, liquidityPrice.asset, liquidityPrice.core)\n//           .signAndSend(assetOwner, ({ events, status }) => status.isInBlock ? done() :null );\n//\n//       });\n//\n//     });\n//\n//     it('Uses keypair to sign', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);\n//       await api.tx.genericAsset\n//         .transfer(spendingAssetId, bob.address, 100)\n//         .setPaymentOpts(api, {feeAssetId: feeAssetId, slippage: 0, tip: 0})\n//         .signAndSend(\n//           assetOwner,\n//           { nonce },\n//           ({ status }) => status.isInBlock ? done() : null\n//         );\n//     });\n//\n//     it('Use tip along with fee exchange', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);\n//       await api.tx.genericAsset\n//         .transfer(spendingAssetId, bob.address, 100)\n//         .setPaymentOpts(api, { feeAssetId: feeAssetId, slippage: 0, tip: 2})\n//         .signAndSend(\n//           assetOwner,\n//           { nonce },\n//           ({ status }) => (status.isInBlock) ? done() : null\n//       );\n//     });\n//\n//     it('Use slippage for max payment in transaction', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);\n//       await api.tx.genericAsset\n//         .transfer(spendingAssetId, bob.address, 100)\n//         .setPaymentOpts(api, { feeAssetId: feeAssetId, slippage: 0.03})\n//         .signAndSend(\n//           assetOwner,\n//           { nonce },\n//           ({ status }) => (status.isInBlock) ? done() : null\n//         );\n//     });\n//\n//     it('Update asset info', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);\n//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'NEW_ASSET_ID', decimalPlaces: 5, existentialDeposit: 5});\n//       await api.tx.genericAsset.updateAssetInfo( feeAssetId, assetInfo).signAndSend(assetOwner, { nonce }, async ({ events, status }) => {\n//         if (status.isInBlock) {\n//           for (const { event: { method, section, data } } of events) {\n//             if (section === 'genericAsset' && method == 'AssetInfoUpdated') {\n//               const [assetId, assetMeta] = data;\n//               expect(assetId as number).toEqual(feeAssetId);\n//               expect(assetMeta.toJSON()).toEqual({\n//                 existentialDeposit: 5,\n//                 decimalPlaces: 5,\n//                 symbol: stringToHex('NEW_ASSET_ID')\n//               });\n//\n//               done();\n//             }\n//           }\n//         }\n//       });\n//     });\n//   });\n//\n//\n//   describe('Signed via signer', () => {\n//     it('should sign with a signer', async done => {\n//       const dave = keyring.addFromUri('//Dave');\n//       const signer = new SingleAccountSigner(api.registry, dave);\n//       const transfer = api.tx.genericAsset.transfer(spendingAssetId, alice.address, 54121);\n//       await transfer.signAndSend(dave.address, { signer }, async ({events, status}) => {\n//         if (status.isInBlock) {\n//           for (const {event: { method, section } } of events) {\n//             if (section === 'genericAsset' && method == 'Transferred') {\n//               done();\n//             }\n//           }\n//         }\n//       });\n//     });\n//   });\n//\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/cennzx.e2e.ts",{"fileContent":"// // Copyright 2019-2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n// import { Api } from '@cennznet/api';\n// import {SignerOptions} from \"@polkadot/api/types\";\n// import { Keyring } from '@polkadot/keyring';\n// import {BN} from \"@polkadot/util\";\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n// import initApiPromise from '../../../../jest/initApiPromise';\n// import {Balance, LiquidityPriceResponse, LiquidityValueResponse} from '@cennznet/types';\n// const CENNZ = '16000';\n// const CENTRAPAY = '16001';\n// const PLUG = '16003';\n//\ndescribe.skip('DEX RPC calls testing', () => {});\n//   let api: Api;\n//   let alice, bob;\n//   beforeAll(async () => {\n//     await cryptoWaitReady();\n//     // api = await initApiPromise();\n//     // const keyring = new Keyring({ type: 'sr25519' });\n//     // alice = keyring.addFromUri('//Alice');\n//     // bob = keyring.addFromUri('//Bob');\n//   });\n//\n//   afterAll(async () => {\n//     // api.disconnect();\n//   });\n//\n//   describe('Queries()', () => {\n//\n//     it(\"Deposit liquidity in CENNZ asset's pool\", async done => {\n//         const amount = 3_000_000;\n//         const coreAmount = amount;\n//         const minLiquidity = 1;\n//       // Add Liquidity for the first time in the pool.\n//         await api.tx.cennzx\n//           .addLiquidity(CENNZ, minLiquidity, amount, coreAmount)\n//           .signAndSend(alice, async ({events, status}) => {\n//             if (status.isInBlock) {\n//               for (const {event} of events) {\n//                 if (event.method === 'AddLiquidity') {\n//                   let amount = 2000;\n//                   const liquidityPrice: LiquidityPriceResponse = await api.rpc.cennzx.liquidityPrice(CENNZ, amount);\n//                   // Deposit liquidity in existing pool\n//                   await api.tx.cennzx\n//                       .addLiquidity(CENNZ, minLiquidity, liquidityPrice.asset, liquidityPrice.core)\n//                       .signAndSend(alice, async ({events, status}) => {\n//                         if (status.isFinalized) {\n//                           for (const {event} of events) {\n//                             if (event.method === 'AddLiquidity') {\n//                               done();\n//                             }\n//                           }\n//                         }\n//                       });\n//                 }\n//               }\n//             }\n//           });\n//     });\n//\n//     it(\"Get the liquidity value for CENNZ asset in Alice's account\", async done => {\n//       const liquidityValue: LiquidityValueResponse = await api.rpc.cennzx.liquidityValue(alice.address, CENNZ);\n//       expect(liquidityValue.liquidity.isZero()).toBe(false);\n//       expect(liquidityValue.core.isZero()).toBe(false);\n//       expect(liquidityValue.asset.isZero()).toBe(false);\n//       done();\n//     });\n//\n//     describe('Positive flow with liquidity in pool', () => {\n//       it(\"Calculate the buy price when buying CENTRAPAY for CENNZ\", async done => {\n//         const amount = 100;\n//         const poolAssetBalance = await api.derive.cennzx.poolAssetBalance(CENNZ);\n//         const poolCoreAssetBalance = await api.derive.cennzx.poolCoreAssetBalance(CENNZ);\n//         console.log('Amount of asset in CENNZ pool:', poolAssetBalance.toString());\n//         console.log('Amount of core in CENNZ pool:', poolCoreAssetBalance.toString());\n//         // How much CENTRAPAY will it cost to buy 100 (amount) CENNZ\n//         const buyPrice = await api.rpc.cennzx.buyPrice(CENTRAPAY, amount, CENNZ);\n//         console.log('Buy price:', buyPrice.toString());\n//         expect(buyPrice.price.toNumber()).toBeGreaterThan(0);\n//         done();\n//       });\n//\n//       it(\"Calculate the sell price when selling CENNZ for CENTRAPAY \", async done => {\n//         const amount = 1000;\n//         // when I sell 1000(amount) CENNZ, how much of CENTRAPAY will I get in return\n//         const sellPrice = await api.rpc.cennzx\n//           .sellPrice(CENNZ, amount, CENTRAPAY);\n//         expect(sellPrice.price.toNumber()).toBeGreaterThan(0);\n//         done();\n//       });\n//\n//       describe('feeExchange derive queries with positive flow', () => {\n//         it('Query estimated fee in CENTRAPAY(default fee currency)', async done => {\n//           const assetBalanceBefore = await api.query.genericAsset.freeBalance(CENTRAPAY, alice.address);\n//           const extrinsic = api.tx.genericAsset\n//             .transfer(CENNZ, bob.address, 10000);\n//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId:CENTRAPAY});\n//\n//           await extrinsic.signAndSend(alice,  async ({events, status}) => {\n//             if (status.isFinalized) {\n//               events.forEach(({phase, event: {data, method, section}}) => {\n//                 console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//               });\n//               const assetBalanceAfter = await api.query.genericAsset.freeBalance(CENTRAPAY, alice.address);\n//               expect((assetBalanceBefore as Balance).toBn().sub((assetBalanceAfter as Balance).toBn()).toString()).toEqual(feeFromQuery.toString());\n//               done();\n//             }\n//           });\n//         });\n//\n//         it('Query estimated fee in different currency (CENNZ)', async done => {\n//           const maxPayment = '50000000000000000';\n//           const assetId = api.registry.createType('AssetId', CENNZ);\n//           const feeExchange = api.registry.createType('FeeExchange', {assetId, maxPayment}, 0);\n//           const transactionPayment = api.registry.createType('ChargeTransactionPayment', {tip: 0, feeExchange});\n//           const royaltiesSchedule = null;\n//           const extrinsic = api.tx.nft.createCollection(\n//             'collectionName',\n//             royaltiesSchedule\n//           );\n//\n//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId: CENNZ, maxPayment});\n//           await extrinsic.signAndSend(alice,  {transactionPayment} as Partial<SignerOptions>, async ({events, status}) => {\n//             if (status.isFinalized) {\n//               events.forEach(({phase, event: {data, method, section}}) => {\n//                 if (method === 'AssetBought') {\n//                   const price = data[3];\n//                   console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//                   expect(feeFromQuery.toString()).toEqual(price.toString());\n//                   done();\n//                 }\n//               });\n//             }\n//           });\n//         });\n//       });\n//     });\n//\n//     describe('Negative flow with no liquidity in pool', () => {\n//       it(\"Calculate the buy price when buying CENTRAPAY for PLUG\", async done => {\n//         const amount = 100;\n//         const poolAssetBalance = await api.derive.cennzx.poolAssetBalance(PLUG);\n//         const poolCoreAssetBalance = await api.derive.cennzx.poolCoreAssetBalance(PLUG);\n//         console.log('Amount of asset in PLUG pool:', poolAssetBalance.toString());\n//         console.log('Amount of core in PLUG pool:', poolCoreAssetBalance.toString());\n//         // How much CENTRAPAY will it cost to buy 100 (amount) PLUG\n//         await expect(api.rpc.cennzx.buyPrice(CENTRAPAY, amount, PLUG)).rejects.toThrow(\n//           '2: Cannot exchange for requested amount.:'\n//         );\n//         done();\n//       });\n//\n//       it(\"Calculate the sell price when selling PLUG for CENTRAPAY when no liquidity exist \", async done => {\n//         const amount = 1000;\n//         // when I sell 1000(amount) PLUG, how much of CENTRAPAY will I get in return\n//         await expect(api.rpc.cennzx\n//           .sellPrice(PLUG, amount, CENTRAPAY)).rejects.toThrow(\n//           '2: Cannot exchange by requested amount.'\n//         );\n//         done();\n//       });\n//\n//       describe('feeExchange derive queries with negative flow', () => {\n//\n//         it('Query estimated fee in different currency (PLUG)', async done => {\n//           const maxPayment = '50000000000000000';\n//           const extrinsic = api.tx.genericAsset\n//             .transfer(CENNZ, bob.address, 10000);\n//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId:PLUG, maxPayment});\n//           expect(feeFromQuery).toEqual(new Error('2: Cannot exchange for requested amount.: '));\n//           done();\n//         });\n//       });\n//     });\n//\n//   });\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/queries.e2e.ts",{"fileContent":"// // Copyright 2019-2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import { AssetInfoV41 as AssetInfo, AssetOptions, Hash, Vec, BalanceLock } from \"@cennznet/types\";\n// import { Keyring } from '@polkadot/keyring';\n// import {Reasons} from \"@polkadot/types/interfaces\";\n// import {stringToHex, u8aToString} from '@polkadot/util';\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n//\n// import initApiPromise from '../../../../jest/initApiPromise';\n//\n// describe('e2e queries', () => {\n//   let api, alice, aliceStash, bob;\n//\n//   beforeAll(async () => {\n//     await cryptoWaitReady();\n//     const keyring = new Keyring({ type: 'sr25519' });\n//     alice = keyring.addFromUri('//Alice');\n//     aliceStash = keyring.addFromUri('//Alice//stash')\n//     bob = keyring.addFromUri('//Bob');\n//     api = await initApiPromise();\n//   });\n//\n//   afterAll(async () => {\n//     await api.disconnect();\n//   });\n//\n//   describe('Query storage', () => {\n//     it('Makes the runtime, rpc, state & extrinsics available', (): void => {\n//       expect(api.genesisHash).toBeDefined();\n//       expect(api.runtimeMetadata).toBeDefined();\n//       expect(api.runtimeVersion).toBeDefined();\n//       expect(api.rpc).toBeDefined();\n//       expect(api.query).toBeDefined();\n//       expect(api.tx).toBeDefined();\n//       expect(api.derive).toBeDefined();\n//     });\n//   });\n//\n//   describe('Query storage using at', () => {\n//     it('Queries correct balance', async () => {\n//       const nextAssetId = await api.query.genericAsset.nextAssetId();\n//       const blockHash: Hash = (await api.rpc.chain.getBlockHash()) as Hash;\n//       const nextAssetIdAt = await api.query.genericAsset.nextAssetId.at(blockHash);\n//       expect(nextAssetId.toString()).toEqual(nextAssetIdAt.toString());\n//     });\n//\n//     it('Checks transaction payment', async done => {\n//       const assetBalance = await api.query.genericAsset.freeBalance(16001, bob.address);\n//       console.log('Balance before ', assetBalance.toString());\n//       const ex = await api.tx.genericAsset\n//         .transfer(16000, bob.address, 100);\n//       const payment = await api.rpc.payment.queryInfo(ex.toHex());\n//       console.log('Payment:', payment.partialFee.toString());\n//       done();\n//     });\n//   });\n//\n//   describe('Subscribe storage', () => {\n//     let unsubscribeFn;\n//     it('Emits events when storage changes', async done => {\n//       let count = 0;\n//       const reservedIdStart: number = 17000;\n//       unsubscribeFn = await api.query.genericAsset.nextAssetId((result: any) => {\n//         if (count === 0) {\n//           expect(result.toNumber()).toBeGreaterThanOrEqual(reservedIdStart);\n//           count += 1;\n//         } else {\n//           expect(result.toNumber()).toBeGreaterThanOrEqual(reservedIdStart);\n//           unsubscribeFn();\n//           done();\n//         }\n//       });\n//       const sudoKey = await api.query.sudo.key();\n//       const keyring = new Keyring({ type: 'sr25519' });\n//       keyring.addFromUri('//Alice');\n//       // Lookup from keyring (assuming we have added all, on --dev this would be `//Alice`)\n//       const sudoPair = keyring.getPair(sudoKey.toString());\n//       const owner = api.registry.createType('Owner', 0); // Owner type is enum with 0 as none/null\n//       const permissions = api.registry.createType('PermissionsV1', { update: owner, mint: owner, burn: owner});\n//       const option = {initialIssuance : 0, permissions};\n//       const assetOption: AssetOptions = api.registry.createType('AssetOptions', option);\n//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'SYLO', decimalPlaces: 3, existentialDeposit: 5});\n//       await api.tx.sudo\n//         .sudo(api.tx.genericAsset\n//           .create(alice.address,\n//             assetOption,\n//             assetInfo\n//           ))\n//         .signAndSend(sudoPair);\n//     }, 12000);\n//   });\n//\n//   describe('GA rpc calls', () => {\n//     it('Gets generic asset registeredAssets through RPC call', async done => {\n//       const registeredAsset = await api.rpc.genericAsset.registeredAssets();\n//       console.log(registeredAsset.toJSON());\n//       expect(registeredAsset.length).toBeGreaterThan(0);\n//       const hasCpayAsset = ([assetId, meta]) => assetId.toString() === '16001' && u8aToString(meta.symbol) === 'CPAY' && meta.decimalPlaces.toString() === '4';\n//       const hasCennzAsset = ([assetId, meta]) => assetId.toString() === '16000' && u8aToString(meta.symbol) === 'CENNZ' && meta.decimalPlaces.toString() === '4';\n//       expect(registeredAsset.some(hasCpayAsset)).toBe(true);\n//       expect(registeredAsset.some(hasCennzAsset)).toBe(true);\n//       done();\n//     });\n//   });\n//\n//   describe('Staking account derived query', () => {\n//     it('Gets staking account details', async done => {\n//       const stashId = aliceStash.address;\n//       const activeEra = await api.query.staking.activeEra();\n//       const stakingAccount = await api.derive.stakingCennznet.accountInfo(stashId, activeEra.unwrap().index);\n//       expect(stakingAccount.accountId.toString()).toBe(stashId);\n//       expect(stakingAccount.controllerId.toString()).toBe(alice.address);\n//       expect(stakingAccount.nominators).toHaveLength(0); // Initially no nominators\n//       expect(stakingAccount.rewardDestination.toString()).toBe(stashId);\n//       expect(stakingAccount.stakers).toBeDefined();\n//       expect(stakingAccount.stakingLedger.stash.toString()).toBe(stashId);\n//       expect(stakingAccount.validatorPrefs[0]).toBe('commission');\n//       expect(stakingAccount.validatorPrefs[1].toNumber()).toBe(0);\n//       // with the latest polkadot version, session keyInfo returns object with session details\n//       const stakingSessionDetails = await api.derive.session.keyInfo(stashId);\n//       const sessionInfo = {\n//         grandpa: '0x88dc3417d5058ec4b4503e0c12ea1a0a89be200fe98922423d4334014fa6b0ee',\n//         babe: '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d',\n//         imOnline: '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d',\n//         authorityDiscovery: '0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d',\n//         ethBridge: '0x0204dad6fc9c291c68498de501c6d6d17bfe28aee69cfbf71b2cc849caafcb0159'\n//       };\n//       expect(stakingSessionDetails.nextSessionKeys.toJSON()).toStrictEqual(sessionInfo);\n//       expect(stakingSessionDetails.sessionKeys.toJSON()).toStrictEqual(sessionInfo);\n//       done();\n//     });\n//   });\n//\n//   describe('Generic Asset Storage', () => {\n//     it('Gets balance locks ok', async done => {\n//       const stashId = '5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY'; // alice_stash\n//       const stakingAssetId = await api.query.genericAsset.stakingAssetId();\n//       const balanceLocks: Vec<BalanceLock> = await api.query.genericAsset.locks(stakingAssetId, stashId);\n//       expect(balanceLocks.isEmpty).toBeFalsy();\n//       const lockDetails = {\n//         \"id\": stringToHex(\"staking \"),\n//         \"amount\": 1000000,\n//         \"reasons\": \"All\"\n//       };\n//       expect(balanceLocks[0].toJSON()).toStrictEqual(lockDetails);\n//       let reasons: Reasons = balanceLocks[0].reasons;\n//       expect(reasons.isAll).toBeTruthy();\n//       done();\n//     });\n//   });\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/governance.e2e.ts",{"fileContent":"// // Copyright 2020-2021 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import { Keyring } from '@polkadot/keyring';\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n// import { u8aToString } from '@polkadot/util'\n//\n// import initApiPromise from '../../../../jest/initApiPromise';\n// import { AccountId, Vec } from '@cennznet/types';\n// import {DeriveProposalInfo} from \"@cennznet/api/derives/governance/types\";\n//\n// let api;\n// const keyring = new Keyring({ type: 'sr25519' });\n// let councilMemberAlice, councilMemberBob, councilMemberCharlie, councilMemberDave;\n//\n// beforeAll(async done => {\n//   await cryptoWaitReady();\n//   api = await initApiPromise();\n//   const sudoKey = await api.query.sudo.key();\n//   // alice is sudo\n//   councilMemberAlice = keyring.addFromUri('//Alice');\n//   councilMemberDave = keyring.addFromUri('//Dave');\n//   councilMemberBob = keyring.addFromUri('//Bob');\n//   councilMemberCharlie = keyring.addFromUri('//Charlie');\n//   // Lookup from keyring (assuming we have added all, on --dev this would be `//Alice`)\n//   const sudoPair = keyring.getPair(sudoKey.toString());\n//\n//   const transaction1 = api.tx.governance.addCouncilMember(councilMemberAlice.address);\n//   const transaction2 = api.tx.governance.addCouncilMember(councilMemberBob.address);\n//   const transaction3 = api.tx.governance.addCouncilMember(councilMemberCharlie.address);\n//   const transaction4 = api.tx.governance.addCouncilMember(councilMemberDave.address);\n//\n//   const batchCouncilEx = api.tx.utility.batch([\n//     transaction1,\n//     transaction2,\n//     transaction3,\n//     transaction4\n//   ]);\n//\n//   await api.tx.sudo\n//     .sudo(batchCouncilEx)\n//     .signAndSend(sudoPair, async ({ events, status }) => {\n//       if (status.isInBlock) {\n//         for (const {event: {method, section, data}} of events) {\n//           console.log('Method:', method.toString());\n//           console.log('section:', section.toString());\n//         }\n//         console.log(`Transaction included at blockHash ${status.asInBlock}`);\n//         done();\n//       }\n//     });\n//\n// });\n//\n// afterAll(async () => {\n//   await api.disconnect();\n// });\n//\n// describe.skip('Governance', () => {\n//\n//   it('List all council members', async done => {\n//     const councilMembers: Vec<AccountId> = await api.query.governance.council();\n//     console.log('Councilmemmbers::....', councilMembers.toJSON());\n//     const members: string[] = councilMembers.toJSON() as unknown as string[];\n//     expect(members.includes(councilMemberBob.address)).toBeTruthy();\n//     expect(members.includes(councilMemberAlice.address)).toBeTruthy();\n//     expect(members.includes(councilMemberCharlie.address)).toBeTruthy();\n//     expect(members.includes(councilMemberDave.address)).toBeTruthy();\n//     done();\n//   });\n//\n//   it('creates a proposal to add new council member', async done => {\n//     const newCouncilMember = '5FWEHQqYMN8YCg8yJxKHnon7Dtx4Psp2xnjvKfQqGC6kUwgv';\n//     const call = api.tx.governance.addCouncilMember(newCouncilMember);\n//     const proposalCall = api.registry.createType('Call', call).toHex();\n//     const justificationUri = 'https://example.com/nft/metadata'\n//     const enactmentDelay = 26; // execute after 26 blocks once sufficient votes criteria is met\n//     await api.tx.governance.submitProposal(\n//       proposalCall,\n//       justificationUri,\n//       enactmentDelay, // execute after 2\n//     ).signAndSend(councilMemberBob, async ({ status, events }) => {\n//       if (status.isInBlock) {\n//         events.forEach(({phase, event: {data, method, section}}) => {\n//           console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//         });\n//         expect((await api.query.governance.proposalCalls(0)).toString()).toBe(proposalCall);\n//         const proposalOpt = await api.query.governance.proposals(0);\n//         const proposal = proposalOpt.unwrap();\n//         expect(proposal.sponsor.toString()).toEqual(councilMemberBob.address);\n//         expect(u8aToString(proposal.justificationUri)).toEqual(justificationUri);\n//         expect(proposal.enactmentDelay.toString()).toEqual(enactmentDelay.toString());\n//         done();\n//       }\n//     });\n//   });\n//\n//   it('vote for proposal 0 to add new council member by a valid council member', async done => {\n//     const proposalId = 0;\n//     const vote = true;\n//     await api.tx.governance.voteOnProposal(\n//       proposalId,\n//       vote\n//     ).signAndSend(councilMemberCharlie, async ({ status, events }) => {\n//       if (status.isInBlock) {\n//         events.forEach(({phase, event: {data, method, section}}) => {\n//           console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//         });\n//         const votesFetched = await api.rpc.governance.getProposalVotes();\n//         console.log('votes fetched::')\n//         const votes = votesFetched.toJSON().find((vote: { proposalId: number; }) => vote.proposalId === proposalId)?.votes;\n//         const charlieVoted = votes.find(vote => vote[0] === councilMemberCharlie.address && vote[1] === true);\n//         console.log('Charlie voted::',charlieVoted);\n//         expect(charlieVoted).toBeDefined();\n//         done();\n//       }\n//     });\n//   });\n//\n//   it('vote for proposal 0 to add new council member by a non council member should fail', async done => {\n//     const nonCouncilMember = keyring.addFromUri('//Ferdie');\n//     const proposalId = 0;\n//     const vote = true;\n//     await api.tx.governance.voteOnProposal(\n//       proposalId,\n//       vote\n//     ).signAndSend(nonCouncilMember, async ({ status, events }) => {\n//       if (status.isInBlock) {\n//         events.forEach(({phase, event: {data, method, section}}) => {\n//           expect(section).toEqual('system');\n//           expect(method).toEqual('ExtrinsicFailed')\n//           console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//           done();\n//         });\n//       }\n//     });\n//   });\n//\n//   it('List all the proposals and its details', async done => {\n//     const proposalId = 0;\n//     const proposals: DeriveProposalInfo[] = await api.derive.governance.proposals();\n//     const proposal = proposals.find(proposal => proposal.id === proposalId);\n//     const newCouncilMember = '5FWEHQqYMN8YCg8yJxKHnon7Dtx4Psp2xnjvKfQqGC6kUwgv';\n//     const call = api.tx.governance.addCouncilMember(newCouncilMember);\n//     const proposalCall = api.registry.createType('Call', call).toHex();\n//     expect(proposal.id).toEqual(proposalId);\n//     expect(proposal.proposal.call.toString()).toEqual(proposalCall.toString());\n//     expect(proposal.proposal.enactmentDelay).toEqual(26);\n//     expect(proposal.proposal.justificationCid).toEqual('https://example.com/nft/metadata')\n//     const charlieVoted = proposal.votes.find(vote => vote[0] === councilMemberCharlie.address && vote[1] === true);\n//     const bobProposed = proposal.votes.find(vote => vote[0] === councilMemberBob.address && vote[1] === true);\n//     expect(charlieVoted).toBeDefined();\n//     expect(bobProposed).toBeDefined();\n//     done();\n//   });\n//\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/rxapi.create.e2e.ts",{"fileContent":"// // Copyright 2019-2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import {ApiRx} from '../../src/ApiRx';\n// import initApiRx from '../../../../jest/initApiRx';\n// import {Api} from \"@cennznet/api\";\n// import config from '../../../../config';\n//\n// describe('e2e rx api create', () => {\n//   const incorrectEndPoint = 'wss://rimu.centrality.cloud/';\n//\n//   afterAll(async done => {\n//     done();\n//   });\n//\n//   it('Should create an Api instance with the timeout option', async done => {\n//     const apiRx = await initApiRx();\n//     const api = await apiRx.toPromise();\n//\n//     api.rpc.chain.getBlockHash().subscribe(hash => {\n//       expect(hash).toBeDefined();\n//       done();\n//     });\n//   });\n//\n//   it ('Should create rx api instance with slim metadata', async done => {\n//     const provider = config.wsProvider[`${process.env.TEST_TYPE}`];\n//     const api = await Api.create({provider, fullMeta: false});\n//     const stakingAssetId = await api.query.genericAsset.stakingAssetId();\n//     expect(stakingAssetId.toNumber()).toBeGreaterThan(0);\n//     await api.disconnect();\n//     done();\n//   });\n//\n//   it ('Should create rx api instance with custom metadata', async done => {\n//     const provider = config.wsProvider[`${process.env.TEST_TYPE}`];\n//     const api = await Api.create({provider, modules:['TransactionPayment', 'GenericAsset']});\n//     const stakingAssetId = await api.query.genericAsset.stakingAssetId();\n//     expect(stakingAssetId.toNumber()).toBeGreaterThan(0);\n//     await api.disconnect();\n//     done();\n//   });\n//\n//   it('Should connect to all available networks on cennznet via network name', async done => {\n//     let apiRx;\n//     let api;\n//     const networkNames = ['azalea', 'nikau', 'rata', 'local'] as const;\n//     const connectionPromises = networkNames.map(async networkName => {\n//       apiRx = await ApiRx.create({network: networkName, timeout: 10000});\n//       api = await apiRx.toPromise()\n//       return api.rpc.chain.getBlockHash();\n//     });\n//     const networkHashes = await Promise.all(connectionPromises);\n//     networkHashes.forEach(hash => {\n//       expect(hash).toBeDefined();\n//     })\n//     done();\n//   });\n//\n//   it('Should connect to use network name and not provider', async done => {\n//     const apiRx = await ApiRx.create({ network: 'local', provider: 'wss://should/not/use/this/provider.io', timeout: 10000});\n//     const api = await apiRx.toPromise()\n//     api.rpc.chain.getBlockHash().subscribe(hash => {\n//       expect(hash).toBeDefined();\n//       done();\n//     });\n//   });\n//\n//   it('Should create Api without timeout if timeout is 0', async done => {\n//     const apiRx = await initApiRx();\n//     const api = await apiRx.toPromise();\n//     api.rpc.chain.getBlockHash().subscribe(hash => {\n//       expect(hash).toBeDefined();\n//       done();\n//     });\n//   });\n//\n//   it('Should get error if the connection fails', async () => {\n//     const incorrectApiRx = await ApiRx.create({provider: incorrectEndPoint});\n//     await expect(incorrectApiRx.toPromise()).rejects.toThrow(/Connection fail/);\n//   });\n//\n//   it('Should get rejected if it is not resolved in a specific period of time', async () => {\n//     const incorrectApiRx = await ApiRx.create({timeout: -1});\n//     await expect(incorrectApiRx.toPromise()).rejects.toThrow(/Timeout has occurred/);\n//   });\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/api.calls.e2e.ts",{"fileContent":"// Copyright 2019-2021 Centrality Investments Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Hash, Block, AccountId } from \"@therootnetwork/types/interfaces\";\nimport { createHeaderExtended } from '@polkadot/api-derive/type';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { options } from '@therootnetwork/api';\n\ndescribe('e2e api calls', () => {\n  let api;\n  let blockHash: Hash;\n  beforeAll(async () => {\n    const providerUrl = 'wss://porcini.rootnet.app/archive/ws';\n    const provider = new WsProvider(providerUrl);\n    console.log('providerUrl', providerUrl);\n    api = new ApiPromise(options({ provider }));\n    await api.isReady;\n    blockHash = await api.rpc.chain.getBlockHash();\n  });\n\n  afterAll(async () => {\n    if (api) {\n      return await api.disconnect();\n    }\n  });\n\n  it('Get correct block', async () => {\n    const block: Block = await api.rpc.chain.getBlock(blockHash).then((r: any) => r.block);\n    expect(block.header.hash.toString()).toEqual(blockHash.toString());\n  });\n\n  it('Get correct validators', async () => {\n    const validators: AccountId[] = (await api.query.session.validators.at(blockHash)) as any;\n    expect(validators.length).toBeGreaterThan(0);\n  });\n\n  it('Expect author is in validators', async () => {\n    const block: Block = await api.rpc.chain.getBlock(blockHash).then((r: any) => r.block);\n    const header = block.header;\n    const validators: AccountId[] = (await api.query.session.validators.at(blockHash)) as any;\n    // console.log('validators:',validators);\n    const extHeader = createHeaderExtended(api.registry, header, validators);\n    const author: AccountId = extHeader.author;\n    expect(validators).toEqual(expect.arrayContaining([expect.objectContaining(author)]));\n  });\n\n  it('Expect at least one event', async () => {\n    const events = (await api.query.system.events.at(blockHash)) as any;\n    expect(events.length).toBeGreaterThan(0);\n  });\n\n  describe('Get session info', () => {\n    it('Get correct session information (length, last length, era, current index, session per era', async () => {\n      const currentSession = await api.derive.session.info();\n      expect(currentSession.currentEra.toNumber()).toBeGreaterThanOrEqual(0);\n      expect(currentSession.currentIndex.toNumber()).toBeGreaterThanOrEqual(0);\n      expect(currentSession.eraLength.toNumber()).toBeGreaterThanOrEqual(0);\n      expect(currentSession.isEpoch).toBe(true);\n      expect(currentSession.sessionLength.toNumber()).toBeGreaterThanOrEqual(0);\n      expect(currentSession.sessionsPerEra.toNumber()).toBeGreaterThanOrEqual(0);\n      expect(currentSession.validatorCount.toNumber()).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n});\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/src/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/types.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/index.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/rpc.decodeResponse.e2e.ts",{"fileContent":"// // Copyright 2019-2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import { RpcCoder } from \"@polkadot/rpc-provider/coder\";\n// import { JsonRpcResponse } from \"@polkadot/rpc-provider/types\";\n//\n// describe('decodeResponse', (): void => {\n//     let coder: RpcCoder;\n//\n//     beforeEach((): void => {\n//         coder = new RpcCoder();\n//     });\n//\n//     it('expects a non-empty input object', (): void => {\n//         expect(\n//             () => coder.decodeResponse(undefined as unknown as JsonRpcResponse)\n//         ).toThrow(/Empty response/);\n//     });\n//\n//     it('expects a valid jsonrpc field', (): void => {\n//         expect(\n//             () => coder.decodeResponse({} as JsonRpcResponse)\n//         ).toThrow(/Invalid jsonrpc/);\n//     });\n//\n//     it('expects a valid id field', (): void => {\n//         expect(\n//             () => coder.decodeResponse({ jsonrpc: '2.0' } as JsonRpcResponse)\n//         ).toThrow(/Invalid id/);\n//     });\n//\n//     it('expects a valid result field', (): void => {\n//         expect(\n//             () => coder.decodeResponse({ id: 1, jsonrpc: '2.0' } as JsonRpcResponse)\n//         ).toThrow(/No result/);\n//     });\n//\n//     it('throws any error found', (): void => {\n//         expect(\n//             () => coder.decodeResponse({ error: { code: 123, message: 'test error' }, id: 1, jsonrpc: '2.0' } as JsonRpcResponse)\n//         ).toThrow(/123: test error/);\n//     });\n//\n//     it('throws any error found, with data', (): void => {\n//         expect(\n//             () => coder.decodeResponse({ error: { code: 123, data: 'Error(\"Some random error description\")', message: 'test error' }, id: 1, jsonrpc: '2.0' } as JsonRpcResponse)\n//         ).toThrow(/123: test error: Some random error description/);\n//     });\n//\n//     it('allows for number subscription ids', (): void => {\n//         expect(\n//             coder.decodeResponse({ id: 1, jsonrpc: '2.0', method: 'test', params: { result: 'test result', subscription: 1 } } as JsonRpcResponse)\n//         ).toEqual('test result');\n//     });\n//\n//     it('allows for string subscription ids', (): void => {\n//         expect(\n//             coder.decodeResponse({ id: 1, jsonrpc: '2.0', method: 'test', params: { result: 'test result', subscription: 'abc' } } as JsonRpcResponse)\n//         ).toEqual('test result');\n//     });\n//\n//     it('returns the result', (): void => {\n//         expect(\n//             coder.decodeResponse({ id: 1, jsonrpc: '2.0', result: 'some result' } as JsonRpcResponse)\n//         ).toEqual('some result');\n//     });\n//     it('encodes a valid JsonRPC object', () => {\n//         expect(coder.encodeObject('method', ['a', 'b'])).toEqual({\n//             id: 1,\n//             jsonrpc: '2.0',\n//             method: 'method',\n//             params: ['a', 'b']\n//         });\n//         expect(coder.getId()).toEqual(1);\n//     });\n//     it('encodes a valid JsonRPC JSON string', () => {\n//       const p: unknown[] = ['params'];\n//         expect(coder.encodeJson('method', p)).toEqual('{\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"method\",\"params\":[\"params\"]}');\n//     });\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/getMetadata.e2e.ts",{"fileContent":"// // Copyright 2019-2021 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import {getMetadata, essential} from \"../../src/util/getMetadata\";\n// import {TypeRegistry} from \"@polkadot/types/create\";\n// import {MetadataVersioned} from \"@polkadot/types/metadata/MetadataVersioned\";\n//\n// describe('getMetadata()',  () => {\n//   it('get slim metadata for endpoint', async (done)=> {\n//     const slimMetadata = await getMetadata('ws://localhost:9944');\n//     const metadataKey = Object.entries(slimMetadata)[0][0].split('-');\n//     const metadataValue = Object.entries(slimMetadata)[0][1];\n//     expect(metadataKey[1]).toEqual(\"58\");\n//     const registry = new TypeRegistry();\n//     const mVersionedSlim = new MetadataVersioned(registry, metadataValue);\n//     const modules = mVersionedSlim.asLatest.pallets.toArray();\n//     const storageData = modules.filter(m => m.storage.isSome);\n//     expect(storageData.length).toEqual(essential.length);\n//     const modulesName = storageData.map(value => value.name.toString().toLowerCase());\n//     expect(modulesName.sort()).toEqual(essential.sort());\n//     done();\n//   });\n//\n//   it('get custom metadata for endpoint, with the list of metadata expected', async (done)=> {\n//     const keepMetaFor = ['Staking']\n//     const slimMetadata = await getMetadata('ws://localhost:9944', keepMetaFor);\n//     const metadataKey = Object.entries(slimMetadata)[0][0].split('-');\n//     const metadataValue = Object.entries(slimMetadata)[0][1];\n//     expect(metadataKey[1]).toEqual(\"58\");\n//     const registry = new TypeRegistry();\n//     const mVersionedSlim = new MetadataVersioned(registry, metadataValue);\n//     const modules = mVersionedSlim.asLatest.pallets.toArray();\n//     const storageData = modules.filter(m => m.storage.isSome);\n//     expect(storageData.length).toEqual(keepMetaFor.length + essential.length);\n//     const modulesNameRecieved = storageData.map(value => value.name.toString().toLowerCase());\n//     const modulesNameExpected = keepMetaFor.concat(essential).map(value => value.toLowerCase());\n//     expect(modulesNameRecieved.sort()).toEqual(modulesNameExpected.sort());\n//     done();\n//   });\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/send.e2e.ts",{"fileContent":"// import { WebSocket } from '@polkadot/x-ws';\n// import { RpcCoder } from \"@polkadot/rpc-provider/coder\";\n//\n// describe('send', (): void => {\n//\n//     it('Send request using websocket for Azalea node', async (done)  => {\n//         const providerUrl = 'wss://cennznet.unfrastructure.io/public/ws';\n//         const ws = new WebSocket(providerUrl);\n//         const coder = new RpcCoder();\n//         ws.onopen = function() {\n//             const requestObject = coder.encodeJson('system_chain', []);\n//             ws.send(requestObject);\n//             ws.onmessage = function (event) {\n//                 expect(event.data).toEqual('{\"jsonrpc\":\"2.0\",\"result\":\"CENNZnet Azalea\",\"id\":1}');\n//                 const data = JSON.parse(event.data);\n//                 expect(data.result).toEqual('CENNZnet Azalea');\n//                 expect(data.id).toBeGreaterThan(0);\n//                 expect(data.jsonrpc).toEqual(\"2.0\");\n//                 done();\n//             }\n//         };\n//     });\n//\n//     it('Send request using websocket for local node', async (done)  => {\n//         const providerUrl = 'ws://127.0.0.1:9944';\n//         const ws = new WebSocket(providerUrl);\n//         const coder = new RpcCoder();\n//         ws.onopen = function() {\n//             const requestObject = coder.encodeJson('system_chain', []);\n//             ws.send(requestObject);\n//             ws.onmessage = function (event) {\n//                 expect(event.data).toEqual('{\"jsonrpc\":\"2.0\",\"result\":\"Development\",\"id\":1}');\n//                 const data = JSON.parse(event.data);\n//                 expect(data.result).toEqual('Development');\n//                 expect(data.id).toBeGreaterThan(0);\n//                 expect(data.jsonrpc).toEqual(\"2.0\");\n//                 done();\n//             }\n//         };\n//     });\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/rxapi.queries.e2e.ts",{"fileContent":"// // Copyright 2019-2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import { Hash } from '@cennznet/types';\n// import { combineLatest } from 'rxjs';\n// import { switchMap } from 'rxjs/operators';\n// import initApiRx from '../../../../jest/initApiRx';\n//\n// describe('e2e queries', () => {\n//   let apiRx;\n//   let api;\n//\n//   beforeAll(async () => {\n//     apiRx = await initApiRx();\n//     api = await apiRx.toPromise();\n//   });\n//\n//   afterAll(async done => {\n//     api = null;\n//     done();\n//   });\n//\n//   describe('Query storage using at', () => {\n//     it('Queries correct balance', async done => {\n//       const nextAssetId$ = api.rpc.chain\n//         .getBlockHash()\n//         .pipe(switchMap(blockHash => api.query.genericAsset.nextAssetId.at(blockHash as Hash)));\n//       combineLatest(api.query.genericAsset.nextAssetId(), nextAssetId$).subscribe(([nextAssetId, nextAssetIdAt]) => {\n//         expect(nextAssetId.toString()).toEqual(nextAssetIdAt.toString());\n//         done();\n//       });\n//     });\n//   });\n// });\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/src/index.ts",{"fileContent":"import type { ApiOptions } from '@polkadot/api/types';\nimport type { RegistryTypes } from '@polkadot/types/types';\n\nimport { lookupTypes as rootnetLookupTypes, rpc as rootnetRpc, types as rootnetTypes, typesAlias as rootnetTypesAlias, typesBundle as rootnetTypesBundle } from '@therootnetwork/types';\n\n// import { runtime as rootnetRuntime } from './runtime';\n\nexport const defaultOptions: ApiOptions = {\n  types: rootnetTypes,\n  rpc: rootnetRpc\n};\n\nexport const options = ({ rpc = {},\n  runtime = {},\n  signedExtensions,\n  types = {},\n  typesAlias = {},\n  typesBundle = {},\n  ...otherOptions }: ApiOptions = {}): ApiOptions => ({\n  types: {\n    ...rootnetTypes,\n    ...(rootnetLookupTypes as unknown as RegistryTypes), // TODO: RegistryTypes's own issue?\n    ...types\n  },\n  rpc: {\n    ...rootnetRpc,\n    ...rpc\n  },\n  typesAlias: {\n    ...rootnetTypesAlias,\n    ...typesAlias\n  },\n  typesBundle: {\n    ...typesBundle,\n    spec: {\n      ...typesBundle.spec,\n      rootnet: {\n        ...rootnetTypesBundle?.spec?.rootnet,\n        ...typesBundle?.spec?.rootnet\n      },\n      porcini: {\n        ...rootnetTypesBundle?.spec?.porcini,\n        ...typesBundle?.spec?.porcini\n      },\n    }\n  },\n  // runtime: {\n  //   ...rootnetRuntime,\n  //   ...runtime\n  // },\n  ...otherOptions\n});\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/lookup/rootnet.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/index.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/index.ts",{"fileContent":"import '@polkadot/types/lookup';\nimport './augment/api';\nimport './lookup/rootnet';\n\nimport type { DefinitionRpc, DefinitionRpcSub, OverrideBundleType, OverrideModuleType, RegistryTypes } from '@polkadot/types/types';\n\nimport { rpc as rootnetRpc, types as rootnetTypes, typesAlias as rootnetTypeAlias, typesBundle as rootnetTypesBundle } from '@therootnetwork/type-definitions';\n\nexport * as lookupTypes from './lookup/rootnet';\n\nexport const types: RegistryTypes = rootnetTypes;\n\nexport const rpc: Record<string, Record<string, DefinitionRpc | DefinitionRpcSub>> = rootnetRpc;\n\nexport const typesAlias: Record<string, OverrideModuleType> = rootnetTypeAlias;\n\nexport const typesBundle = rootnetTypesBundle as unknown as OverrideBundleType;\n\n// export const signedExtensions = rootnetSignedExtensions;\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/lookup/rootnet.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-consts.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-errors.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-events.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-query.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-tx.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-rpc.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-runtime.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/spec/rootnet.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/spec/porcini.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/dex.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/ethy.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/ethWallet.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/xrplBridge.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/nft.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/runtime.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\nimport './api-consts';\nimport './api-errors';\nimport './api-events';\nimport './api-query';\nimport './api-tx';\nimport './api-rpc';\nimport './api-runtime';\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-consts.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-errors.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-events.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-query.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-tx.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-rpc.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-runtime.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/nft/index.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-consts.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/api-base/types/consts';\n\nimport type { ApiTypes, AugmentedConst } from '@polkadot/api-base/types';\nimport type { Vec, u128, u16, u32, u64, u8 } from '@polkadot/types-codec';\nimport type { Codec, ITuple } from '@polkadot/types-codec/types';\nimport type { FrameSupportPalletId, FrameSupportWeightsRuntimeDbWeight, FrameSystemLimitsBlockLength, FrameSystemLimitsBlockWeights, SpVersionRuntimeVersion } from '@polkadot/types/lookup';\nimport type { Perbill } from '@therootnetwork/types/interfaces/runtime';\n\nexport type __AugmentedConst<ApiType extends ApiTypes> = AugmentedConst<ApiType>;\n\ndeclare module '@polkadot/api-base/types/consts' {\n  interface AugmentedConsts<ApiType extends ApiTypes> {\n    assets: {\n      /**\n       * The amount of funds that must be reserved when creating a new approval.\n       **/\n      approvalDeposit: u128 & AugmentedConst<ApiType>;\n      /**\n       * The amount of funds that must be reserved for a non-provider asset account to be\n       * maintained.\n       **/\n      assetAccountDeposit: u128 & AugmentedConst<ApiType>;\n      /**\n       * The basic amount of funds that must be reserved for an asset.\n       **/\n      assetDeposit: u128 & AugmentedConst<ApiType>;\n      /**\n       * The basic amount of funds that must be reserved when adding metadata to your asset.\n       **/\n      metadataDepositBase: u128 & AugmentedConst<ApiType>;\n      /**\n       * The additional funds that must be reserved for the number of bytes you store in your\n       * metadata.\n       **/\n      metadataDepositPerByte: u128 & AugmentedConst<ApiType>;\n      /**\n       * The maximum length of a name or symbol stored on-chain.\n       **/\n      stringLimit: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    assetsExt: {\n      /**\n       * The maximum * of holds per asset & account\n       **/\n      maxHolds: u32 & AugmentedConst<ApiType>;\n      /**\n       * The native token asset Id (managed by pallet-balances)\n       **/\n      nativeAssetId: u32 & AugmentedConst<ApiType>;\n      /**\n       * This pallet's Id, used for deriving a sovereign account ID\n       **/\n      palletId: FrameSupportPalletId & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    authorship: {\n      /**\n       * The number of blocks back we should accept uncles.\n       * This means that we will deal with uncle-parents that are\n       * `UncleGenerations + 1` before `now`.\n       **/\n      uncleGenerations: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    babe: {\n      /**\n       * The amount of time, in slots, that each epoch should last.\n       * NOTE: Currently it is not possible to change the epoch duration after\n       * the chain has started. Attempting to do so will brick block production.\n       **/\n      epochDuration: u64 & AugmentedConst<ApiType>;\n      /**\n       * The expected average block time at which BABE should be creating\n       * blocks. Since BABE is probabilistic it is not trivial to figure out\n       * what the expected average block time should be based on the slot\n       * duration and the security parameter `c` (where `1 - c` represents\n       * the probability of a slot being empty).\n       **/\n      expectedBlockTime: u64 & AugmentedConst<ApiType>;\n      /**\n       * Max number of authorities allowed\n       **/\n      maxAuthorities: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    balances: {\n      /**\n       * The minimum amount required to keep an account open.\n       **/\n      existentialDeposit: u128 & AugmentedConst<ApiType>;\n      /**\n       * The maximum number of locks that should exist on an account.\n       * Not strictly enforced, but used for weight estimation.\n       **/\n      maxLocks: u32 & AugmentedConst<ApiType>;\n      /**\n       * The maximum number of named reserves that can exist on an account.\n       **/\n      maxReserves: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    dex: {\n      /**\n       * The DEX's burn id, to provide for a redundant, unredeemable minter/burner address.\n       **/\n      dexBurnPalletId: FrameSupportPalletId & AugmentedConst<ApiType>;\n      /**\n       * Trading fee rate\n       * The first item of the tuple is the numerator of the fee rate, second\n       * item is the denominator, fee_rate = numerator / denominator,\n       * use (u32, u32) over `Rate` type to minimize internal division\n       * operation.\n       **/\n      getExchangeFee: ITuple<[u32, u32]> & AugmentedConst<ApiType>;\n      /**\n       * Liquidity pair default token decimals\n       **/\n      lpTokenDecimals: u8 & AugmentedConst<ApiType>;\n      /**\n       * The limit for length of trading path\n       **/\n      tradingPathLimit: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    echo: {\n      /**\n       * This pallet's Id, used for deriving a sovereign account ID\n       **/\n      palletId: FrameSupportPalletId & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    electionProviderMultiPhase: {\n      /**\n       * The minimum amount of improvement to the solution score that defines a solution as\n       * \"better\" in the Signed phase.\n       **/\n      betterSignedThreshold: Perbill & AugmentedConst<ApiType>;\n      /**\n       * The minimum amount of improvement to the solution score that defines a solution as\n       * \"better\" in the Unsigned phase.\n       **/\n      betterUnsignedThreshold: Perbill & AugmentedConst<ApiType>;\n      /**\n       * The maximum number of electable targets to put in the snapshot.\n       **/\n      maxElectableTargets: u16 & AugmentedConst<ApiType>;\n      /**\n       * The maximum number of electing voters to put in the snapshot. At the moment, snapshots\n       * are only over a single block, but once multi-block elections are introduced they will\n       * take place over multiple blocks.\n       **/\n      maxElectingVoters: u32 & AugmentedConst<ApiType>;\n      /**\n       * The priority of the unsigned transaction submitted in the unsigned-phase\n       **/\n      minerTxPriority: u64 & AugmentedConst<ApiType>;\n      /**\n       * The repeat threshold of the offchain worker.\n       * \n       * For example, if it is 5, that means that at least 5 blocks will elapse between attempts\n       * to submit the worker's solution.\n       **/\n      offchainRepeat: u32 & AugmentedConst<ApiType>;\n      /**\n       * Base deposit for a signed solution.\n       **/\n      signedDepositBase: u128 & AugmentedConst<ApiType>;\n      /**\n       * Per-byte deposit for a signed solution.\n       **/\n      signedDepositByte: u128 & AugmentedConst<ApiType>;\n      /**\n       * Per-weight deposit for a signed solution.\n       **/\n      signedDepositWeight: u128 & AugmentedConst<ApiType>;\n      /**\n       * The maximum amount of unchecked solutions to refund the call fee for.\n       **/\n      signedMaxRefunds: u32 & AugmentedConst<ApiType>;\n      /**\n       * Maximum number of signed submissions that can be queued.\n       * \n       * It is best to avoid adjusting this during an election, as it impacts downstream data\n       * structures. In particular, `SignedSubmissionIndices<T>` is bounded on this value. If you\n       * update this value during an election, you _must_ ensure that\n       * `SignedSubmissionIndices.len()` is less than or equal to the new value. Otherwise,\n       * attempts to submit new solutions may cause a runtime panic.\n       **/\n      signedMaxSubmissions: u32 & AugmentedConst<ApiType>;\n      /**\n       * Maximum weight of a signed solution.\n       * \n       * If [`Config::MinerConfig`] is being implemented to submit signed solutions (outside of\n       * this pallet), then [`MinerConfig::solution_weight`] is used to compare against\n       * this value.\n       **/\n      signedMaxWeight: u64 & AugmentedConst<ApiType>;\n      /**\n       * Duration of the signed phase.\n       **/\n      signedPhase: u32 & AugmentedConst<ApiType>;\n      /**\n       * Base reward for a signed solution\n       **/\n      signedRewardBase: u128 & AugmentedConst<ApiType>;\n      /**\n       * Duration of the unsigned phase.\n       **/\n      unsignedPhase: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    feeProxy: {\n      /**\n       * The native token asset Id (managed by pallet-balances)\n       **/\n      feeAssetId: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    grandpa: {\n      /**\n       * Max Authorities in use\n       **/\n      maxAuthorities: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    imOnline: {\n      /**\n       * A configuration for base priority of unsigned transactions.\n       * \n       * This is exposed so that it can be tuned for particular runtime, when\n       * multiple pallets send unsigned transactions.\n       **/\n      unsignedPriority: u64 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    nft: {\n      /**\n       * Default auction / sale length in blocks\n       **/\n      defaultListingDuration: u32 & AugmentedConst<ApiType>;\n      /**\n       * This pallet's Id, used for deriving a sovereign account ID\n       **/\n      palletId: FrameSupportPalletId & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    nftPeg: {\n      delayLength: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    proxy: {\n      /**\n       * The base amount of currency needed to reserve for creating an announcement.\n       * \n       * This is held when a new storage item holding a `Balance` is created (typically 16\n       * bytes).\n       **/\n      announcementDepositBase: u128 & AugmentedConst<ApiType>;\n      /**\n       * The amount of currency needed per announcement made.\n       * \n       * This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)\n       * into a pre-existing storage value.\n       **/\n      announcementDepositFactor: u128 & AugmentedConst<ApiType>;\n      /**\n       * The maximum amount of time-delayed announcements that are allowed to be pending.\n       **/\n      maxPending: u32 & AugmentedConst<ApiType>;\n      /**\n       * The maximum amount of proxies allowed for a single account.\n       **/\n      maxProxies: u32 & AugmentedConst<ApiType>;\n      /**\n       * The base amount of currency needed to reserve for creating a proxy.\n       * \n       * This is held for an additional storage item whose value size is\n       * `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes.\n       **/\n      proxyDepositBase: u128 & AugmentedConst<ApiType>;\n      /**\n       * The amount of currency needed per proxy added.\n       * \n       * This is held for adding 32 bytes plus an instance of `ProxyType` more into a\n       * pre-existing storage value. Thus, when configuring `ProxyDepositFactor` one should take\n       * into account `32 + proxy_type.encode().len()` bytes of data.\n       **/\n      proxyDepositFactor: u128 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    recovery: {\n      /**\n       * The base amount of currency needed to reserve for creating a recovery configuration.\n       * \n       * This is held for an additional storage item whose value size is\n       * `2 + sizeof(BlockNumber, Balance)` bytes.\n       **/\n      configDepositBase: u128 & AugmentedConst<ApiType>;\n      /**\n       * The amount of currency needed per additional user when creating a recovery\n       * configuration.\n       * \n       * This is held for adding `sizeof(AccountId)` bytes more into a pre-existing storage\n       * value.\n       **/\n      friendDepositFactor: u128 & AugmentedConst<ApiType>;\n      /**\n       * The maximum amount of friends allowed in a recovery configuration.\n       * \n       * NOTE: The threshold programmed in this Pallet uses u16, so it does\n       * not really make sense to have a limit here greater than u16::MAX.\n       * But also, that is a lot more than you should probably set this value\n       * to anyway...\n       **/\n      maxFriends: u32 & AugmentedConst<ApiType>;\n      /**\n       * The base amount of currency needed to reserve for starting a recovery.\n       * \n       * This is primarily held for deterring malicious recovery attempts, and should\n       * have a value large enough that a bad actor would choose not to place this\n       * deposit. It also acts to fund additional storage item whose value size is\n       * `sizeof(BlockNumber, Balance + T * AccountId)` bytes. Where T is a configurable\n       * threshold.\n       **/\n      recoveryDeposit: u128 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    scheduler: {\n      /**\n       * The maximum weight that may be scheduled per block for any dispatchables of less\n       * priority than `schedule::HARD_DEADLINE`.\n       **/\n      maximumWeight: u64 & AugmentedConst<ApiType>;\n      /**\n       * The maximum number of scheduled calls in the queue for a single block.\n       * Not strictly enforced, but used for weight estimation.\n       **/\n      maxScheduledPerBlock: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    staking: {\n      /**\n       * Number of eras that staked funds must remain bonded for.\n       **/\n      bondingDuration: u32 & AugmentedConst<ApiType>;\n      /**\n       * Maximum number of nominations per nominator.\n       **/\n      maxNominations: u32 & AugmentedConst<ApiType>;\n      /**\n       * The maximum number of nominators rewarded for each validator.\n       * \n       * For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can\n       * claim their reward. This used to limit the i/o cost for the nominator payout.\n       **/\n      maxNominatorRewardedPerValidator: u32 & AugmentedConst<ApiType>;\n      /**\n       * The maximum number of `unlocking` chunks a [`StakingLedger`] can have. Effectively\n       * determines how many unique eras a staker may be unbonding in.\n       **/\n      maxUnlockingChunks: u32 & AugmentedConst<ApiType>;\n      /**\n       * Number of sessions per era.\n       **/\n      sessionsPerEra: u32 & AugmentedConst<ApiType>;\n      /**\n       * Number of eras that slashes are deferred by, after computation.\n       * \n       * This should be less than the bonding duration. Set to 0 if slashes\n       * should be applied immediately, without opportunity for intervention.\n       **/\n      slashDeferDuration: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    system: {\n      /**\n       * Maximum number of block number to block hash mappings to keep (oldest pruned first).\n       **/\n      blockHashCount: u32 & AugmentedConst<ApiType>;\n      /**\n       * The maximum length of a block (in bytes).\n       **/\n      blockLength: FrameSystemLimitsBlockLength & AugmentedConst<ApiType>;\n      /**\n       * Block & extrinsics weights: base values and limits.\n       **/\n      blockWeights: FrameSystemLimitsBlockWeights & AugmentedConst<ApiType>;\n      /**\n       * The weight of runtime database operations the runtime can invoke.\n       **/\n      dbWeight: FrameSupportWeightsRuntimeDbWeight & AugmentedConst<ApiType>;\n      /**\n       * The designated SS85 prefix of this chain.\n       * \n       * This replaces the \"ss58Format\" property declared in the chain spec. Reason is\n       * that the runtime should know about the prefix in order to make use of it as\n       * an identifier of the chain.\n       **/\n      ss58Prefix: u16 & AugmentedConst<ApiType>;\n      /**\n       * Get the chain's current version.\n       **/\n      version: SpVersionRuntimeVersion & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    timestamp: {\n      /**\n       * The minimum period between blocks. Beware that this is different to the *expected*\n       * period that the block production apparatus provides. Your chosen consensus system will\n       * generally work with this to determine a sensible block time. e.g. For Aura, it will be\n       * double this period on default settings.\n       **/\n      minimumPeriod: u64 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    transactionPayment: {\n      /**\n       * A fee mulitplier for `Operational` extrinsics to compute \"virtual tip\" to boost their\n       * `priority`\n       * \n       * This value is multipled by the `final_fee` to obtain a \"virtual tip\" that is later\n       * added to a tip component in regular `priority` calculations.\n       * It means that a `Normal` transaction can front-run a similarly-sized `Operational`\n       * extrinsic (with no tip), by including a tip value greater than the virtual tip.\n       * \n       * ```rust,ignore\n       * // For `Normal`\n       * let priority = priority_calc(tip);\n       * \n       * // For `Operational`\n       * let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;\n       * let priority = priority_calc(tip + virtual_tip);\n       * ```\n       * \n       * Note that since we use `final_fee` the multiplier applies also to the regular `tip`\n       * sent with the transaction. So, not only does the transaction get a priority bump based\n       * on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`\n       * transactions.\n       **/\n      operationalFeeMultiplier: u8 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    txFeePot: {\n      txFeePotId: FrameSupportPalletId & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    utility: {\n      /**\n       * The limit on the number of batched calls.\n       **/\n      batchedCallsLimit: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    voterList: {\n      /**\n       * The list of thresholds separating the various bags.\n       * \n       * Ids are separated into unsorted bags according to their score. This specifies the\n       * thresholds separating the bags. An id's bag is the largest bag for which the id's score\n       * is less than or equal to its upper threshold.\n       * \n       * When ids are iterated, higher bags are iterated completely before lower bags. This means\n       * that iteration is _semi-sorted_: ids of higher score tend to come before ids of lower\n       * score, but peer ids within a particular bag are sorted in insertion order.\n       * \n       * # Expressing the constant\n       * \n       * This constant must be sorted in strictly increasing order. Duplicate items are not\n       * permitted.\n       * \n       * There is an implied upper limit of `Score::MAX`; that value does not need to be\n       * specified within the bag. For any two threshold lists, if one ends with\n       * `Score::MAX`, the other one does not, and they are otherwise equal, the two\n       * lists will behave identically.\n       * \n       * # Calculation\n       * \n       * It is recommended to generate the set of thresholds in a geometric series, such that\n       * there exists some constant ratio such that `threshold[k + 1] == (threshold[k] *\n       * constant_ratio).max(threshold[k] + 1)` for all `k`.\n       * \n       * The helpers in the `/utils/frame/generate-bags` module can simplify this calculation.\n       * \n       * # Examples\n       * \n       * - If `BagThresholds::get().is_empty()`, then all ids are put into the same bag, and\n       * iteration is strictly in insertion order.\n       * - If `BagThresholds::get().len() == 64`, and the thresholds are determined according to\n       * the procedure given above, then the constant ratio is equal to 2.\n       * - If `BagThresholds::get().len() == 200`, and the thresholds are determined according to\n       * the procedure given above, then the constant ratio is approximately equal to 1.248.\n       * - If the threshold list begins `[1, 2, 3, ...]`, then an id with score 0 or 1 will fall\n       * into bag 0, an id with score 2 will fall into bag 1, etc.\n       * \n       * # Migration\n       * \n       * In the event that this list ever changes, a copy of the old bags list must be retained.\n       * With that `List::migrate` can be called, which will perform the appropriate migration.\n       **/\n      bagThresholds: Vec<u64> & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n    xrplBridge: {\n      /**\n       * Challenge Period to wait for a challenge before processing the transaction\n       **/\n      challengePeriod: u32 & AugmentedConst<ApiType>;\n      /**\n       * Clear Period to wait for a transaction to be cleared from settled storages\n       **/\n      clearTxPeriod: u32 & AugmentedConst<ApiType>;\n      /**\n       * XRP Asset Id set at runtime\n       **/\n      xrpAssetId: u32 & AugmentedConst<ApiType>;\n      /**\n       * Generic const\n       **/\n      [key: string]: Codec;\n    };\n  } // AugmentedConsts\n} // declare module\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/types.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-errors.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/api-base/types/errors';\n\nimport type { ApiTypes, AugmentedError } from '@polkadot/api-base/types';\n\nexport type __AugmentedError<ApiType extends ApiTypes> = AugmentedError<ApiType>;\n\ndeclare module '@polkadot/api-base/types/errors' {\n  interface AugmentedErrors<ApiType extends ApiTypes> {\n    assets: {\n      /**\n       * The asset-account already exists.\n       **/\n      AlreadyExists: AugmentedError<ApiType>;\n      /**\n       * Invalid metadata given.\n       **/\n      BadMetadata: AugmentedError<ApiType>;\n      /**\n       * Invalid witness data given.\n       **/\n      BadWitness: AugmentedError<ApiType>;\n      /**\n       * Account balance must be greater than or equal to the transfer amount.\n       **/\n      BalanceLow: AugmentedError<ApiType>;\n      /**\n       * The origin account is frozen.\n       **/\n      Frozen: AugmentedError<ApiType>;\n      /**\n       * The asset ID is already taken.\n       **/\n      InUse: AugmentedError<ApiType>;\n      /**\n       * Minimum balance should be non-zero.\n       **/\n      MinBalanceZero: AugmentedError<ApiType>;\n      /**\n       * The account to alter does not exist.\n       **/\n      NoAccount: AugmentedError<ApiType>;\n      /**\n       * The asset-account doesn't have an associated deposit.\n       **/\n      NoDeposit: AugmentedError<ApiType>;\n      /**\n       * The signing account has no permission to do the operation.\n       **/\n      NoPermission: AugmentedError<ApiType>;\n      /**\n       * Unable to increment the consumer reference counters on the account. Either no provider\n       * reference exists to allow a non-zero balance of a non-self-sufficient asset, or the\n       * maximum number of consumers has been reached.\n       **/\n      NoProvider: AugmentedError<ApiType>;\n      /**\n       * No approval exists that would allow the transfer.\n       **/\n      Unapproved: AugmentedError<ApiType>;\n      /**\n       * The given asset ID is unknown.\n       **/\n      Unknown: AugmentedError<ApiType>;\n      /**\n       * The operation would result in funds being burned.\n       **/\n      WouldBurn: AugmentedError<ApiType>;\n      /**\n       * The source account would not survive the transfer and it needs to stay alive.\n       **/\n      WouldDie: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    assetsExt: {\n      /**\n       * Hold balance is less then the required amount\n       **/\n      BalanceLow: AugmentedError<ApiType>;\n      /**\n       * Failed to create a new asset\n       **/\n      CreateAssetFailed: AugmentedError<ApiType>;\n      /**\n       * Maximum holds placed on this asset/account pair\n       **/\n      MaxHolds: AugmentedError<ApiType>;\n      /**\n       * The account to alter does not exist\n       **/\n      NoAccount: AugmentedError<ApiType>;\n      /**\n       * No more Ids are available, they've been exhausted\n       **/\n      NoAvailableIds: AugmentedError<ApiType>;\n      /**\n       * Operation would overflow\n       **/\n      Overflow: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    authorship: {\n      /**\n       * The uncle is genesis.\n       **/\n      GenesisUncle: AugmentedError<ApiType>;\n      /**\n       * The uncle parent not in the chain.\n       **/\n      InvalidUncleParent: AugmentedError<ApiType>;\n      /**\n       * The uncle isn't recent enough to be included.\n       **/\n      OldUncle: AugmentedError<ApiType>;\n      /**\n       * The uncle is too high in chain.\n       **/\n      TooHighUncle: AugmentedError<ApiType>;\n      /**\n       * Too many uncles.\n       **/\n      TooManyUncles: AugmentedError<ApiType>;\n      /**\n       * The uncle is already included.\n       **/\n      UncleAlreadyIncluded: AugmentedError<ApiType>;\n      /**\n       * Uncles already set in the block.\n       **/\n      UnclesAlreadySet: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    babe: {\n      /**\n       * A given equivocation report is valid but already previously reported.\n       **/\n      DuplicateOffenceReport: AugmentedError<ApiType>;\n      /**\n       * Submitted configuration is invalid.\n       **/\n      InvalidConfiguration: AugmentedError<ApiType>;\n      /**\n       * An equivocation proof provided as part of an equivocation report is invalid.\n       **/\n      InvalidEquivocationProof: AugmentedError<ApiType>;\n      /**\n       * A key ownership proof provided as part of an equivocation report is invalid.\n       **/\n      InvalidKeyOwnershipProof: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    balances: {\n      /**\n       * Beneficiary account must pre-exist\n       **/\n      DeadAccount: AugmentedError<ApiType>;\n      /**\n       * Value too low to create account due to existential deposit\n       **/\n      ExistentialDeposit: AugmentedError<ApiType>;\n      /**\n       * A vesting schedule already exists for this account\n       **/\n      ExistingVestingSchedule: AugmentedError<ApiType>;\n      /**\n       * Balance too low to send value\n       **/\n      InsufficientBalance: AugmentedError<ApiType>;\n      /**\n       * Transfer/payment would kill account\n       **/\n      KeepAlive: AugmentedError<ApiType>;\n      /**\n       * Account liquidity restrictions prevent withdrawal\n       **/\n      LiquidityRestrictions: AugmentedError<ApiType>;\n      /**\n       * Number of named reserves exceed MaxReserves\n       **/\n      TooManyReserves: AugmentedError<ApiType>;\n      /**\n       * Vesting balance too high to send value\n       **/\n      VestingBalance: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    dex: {\n      /**\n       * Supply amount is more than max_supply_amount\n       **/\n      ExcessiveSupplyAmount: AugmentedError<ApiType>;\n      IdenticalTokenAddress: AugmentedError<ApiType>;\n      /**\n       * Insufficent amount\n       **/\n      InsufficientAmount: AugmentedError<ApiType>;\n      /**\n       * Insufficient asset_a liquidity amount\n       **/\n      InsufficientAmountA: AugmentedError<ApiType>;\n      /**\n       * Insufficient asset_b liquidity amount\n       **/\n      InsufficientAmountB: AugmentedError<ApiType>;\n      /**\n       * Insufficient input amount\n       **/\n      InsufficientInputAmount: AugmentedError<ApiType>;\n      /**\n       * Liquidity is not enough\n       **/\n      InsufficientLiquidity: AugmentedError<ApiType>;\n      /**\n       * Insufficient liquidity burnt\n       **/\n      InsufficientLiquidityBurnt: AugmentedError<ApiType>;\n      /**\n       * Insufficient output amount\n       **/\n      InsufficientOutputAmount: AugmentedError<ApiType>;\n      /**\n       * Target amount is less to min_target_amount\n       **/\n      InsufficientTargetAmount: AugmentedError<ApiType>;\n      /**\n       * Insufficient withdraw amount for token A\n       **/\n      InsufficientWithdrawnAmountA: AugmentedError<ApiType>;\n      /**\n       * Insufficient withdraw amount for token B\n       **/\n      InsufficientWithdrawnAmountB: AugmentedError<ApiType>;\n      /**\n       * Invalid Asset id\n       **/\n      InvalidAssetId: AugmentedError<ApiType>;\n      /**\n       * Invalid constant product K\n       **/\n      InvalidConstantProduct: AugmentedError<ApiType>;\n      /**\n       * Must provide non-zero amount of liquidity\n       **/\n      InvalidInputAmounts: AugmentedError<ApiType>;\n      /**\n       * The increment of liquidity is invalid\n       **/\n      InvalidLiquidityIncrement: AugmentedError<ApiType>;\n      /**\n       * Invalid trading path length\n       **/\n      InvalidTradingPathLength: AugmentedError<ApiType>;\n      /**\n       * The Liquidity Provider token does not exist\n       **/\n      LiquidityProviderTokenNotCreated: AugmentedError<ApiType>;\n      /**\n       * Trading pair must be in Enabled status\n       **/\n      MustBeEnabled: AugmentedError<ApiType>;\n      /**\n       * Trading pair must be in NotEnabled status\n       **/\n      MustBeNotEnabled: AugmentedError<ApiType>;\n      /**\n       * The share increment is unacceptable\n       **/\n      UnacceptableShareIncrement: AugmentedError<ApiType>;\n      /**\n       * The supply amount is zero\n       **/\n      ZeroSupplyAmount: AugmentedError<ApiType>;\n      /**\n       * The target amount is zero\n       **/\n      ZeroTargetAmount: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    echo: {\n      /**\n       * The abi received does not match the encoding scheme\n       **/\n      InvalidAbiEncoding: AugmentedError<ApiType>;\n      /**\n       * Invalid ping_or_pong parameter, must be 0 or 1\n       **/\n      InvalidParameter: AugmentedError<ApiType>;\n      /**\n       * There are no remaining session ids\n       **/\n      NoAvailableIds: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    electionProviderMultiPhase: {\n      /**\n       * The call is not allowed at this point.\n       **/\n      CallNotAllowed: AugmentedError<ApiType>;\n      /**\n       * The fallback failed\n       **/\n      FallbackFailed: AugmentedError<ApiType>;\n      /**\n       * `Self::insert_submission` returned an invalid index.\n       **/\n      InvalidSubmissionIndex: AugmentedError<ApiType>;\n      /**\n       * Snapshot metadata should exist but didn't.\n       **/\n      MissingSnapshotMetadata: AugmentedError<ApiType>;\n      /**\n       * OCW submitted solution for wrong round\n       **/\n      OcwCallWrongEra: AugmentedError<ApiType>;\n      /**\n       * Submission was too early.\n       **/\n      PreDispatchEarlySubmission: AugmentedError<ApiType>;\n      /**\n       * Submission was too weak, score-wise.\n       **/\n      PreDispatchWeakSubmission: AugmentedError<ApiType>;\n      /**\n       * Wrong number of winners presented.\n       **/\n      PreDispatchWrongWinnerCount: AugmentedError<ApiType>;\n      /**\n       * The origin failed to pay the deposit.\n       **/\n      SignedCannotPayDeposit: AugmentedError<ApiType>;\n      /**\n       * Witness data to dispatchable is invalid.\n       **/\n      SignedInvalidWitness: AugmentedError<ApiType>;\n      /**\n       * The queue was full, and the solution was not better than any of the existing ones.\n       **/\n      SignedQueueFull: AugmentedError<ApiType>;\n      /**\n       * The signed submission consumes too much weight\n       **/\n      SignedTooMuchWeight: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    erc20Peg: {\n      /**\n       * Could not create the bridged asset\n       **/\n      CreateAssetFailed: AugmentedError<ApiType>;\n      /**\n       * Deposits are inactive\n       **/\n      DepositsPaused: AugmentedError<ApiType>;\n      /**\n       * Withdrawals over the set payment delay for EVM calls are disabled\n       **/\n      EvmWithdrawalFailed: AugmentedError<ApiType>;\n      /**\n       * The abi received does not match the encoding scheme\n       **/\n      InvalidAbiEncoding: AugmentedError<ApiType>;\n      /**\n       * Deposit has bad amount\n       **/\n      InvalidAmount: AugmentedError<ApiType>;\n      /**\n       * Could not convert pallet id to account\n       **/\n      InvalidPalletId: AugmentedError<ApiType>;\n      /**\n       * Withdrawals of this asset are not supported\n       **/\n      UnsupportedAsset: AugmentedError<ApiType>;\n      /**\n       * Withdrawals are inactive\n       **/\n      WithdrawalsPaused: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    ethBridge: {\n      /**\n       * The bridge is paused pending validator set changes (once every era / 24 hours)\n       * It will reactive after ~10 minutes\n       **/\n      BridgePaused: AugmentedError<ApiType>;\n      /**\n       * The relayer already has a bonded amount\n       **/\n      CantBondRelayer: AugmentedError<ApiType>;\n      /**\n       * The relayer is active and cant unbond the specified amount\n       **/\n      CantUnbondRelayer: AugmentedError<ApiType>;\n      /**\n       * There is already a challenge for this claim\n       **/\n      ClaimAlreadyChallenged: AugmentedError<ApiType>;\n      /**\n       * Event was already submitted and is pending\n       **/\n      EventReplayPending: AugmentedError<ApiType>;\n      /**\n       * Event was already submitted and is complete\n       **/\n      EventReplayProcessed: AugmentedError<ApiType>;\n      HttpFetch: AugmentedError<ApiType>;\n      /**\n       * Some internal operation failed\n       **/\n      Internal: AugmentedError<ApiType>;\n      /**\n       * Claim was invalid e.g. not properly ABI encoded\n       **/\n      InvalidClaim: AugmentedError<ApiType>;\n      /**\n       * A notarization was invalid\n       **/\n      InvalidNotarization: AugmentedError<ApiType>;\n      /**\n       * Someone tried to set a greater amount of validators than allowed\n       **/\n      MaxNewSignersExceeded: AugmentedError<ApiType>;\n      /**\n       * The relayer hasn't paid the relayer bond so can't be set as the active relayer\n       **/\n      NoBondPaid: AugmentedError<ApiType>;\n      /**\n       * There is no event claim associated with the supplied claim_id\n       **/\n      NoClaim: AugmentedError<ApiType>;\n      NoLocalSigningAccount: AugmentedError<ApiType>;\n      /**\n       * Caller does not have permission for that action\n       **/\n      NoPermission: AugmentedError<ApiType>;\n      /**\n       * offchain worker not configured properly\n       **/\n      OcwConfig: AugmentedError<ApiType>;\n      OffchainUnsignedTxSignedPayload: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    ethereum: {\n      BalanceLow: AugmentedError<ApiType>;\n      GasLimitTooHigh: AugmentedError<ApiType>;\n      GasLimitTooLow: AugmentedError<ApiType>;\n      GasPriceTooLow: AugmentedError<ApiType>;\n      InvalidNonce: AugmentedError<ApiType>;\n      /**\n       * Signature is invalid.\n       **/\n      InvalidSignature: AugmentedError<ApiType>;\n      /**\n       * Pre-log is present, therefore transact is not allowed.\n       **/\n      PreLogExists: AugmentedError<ApiType>;\n      Undefined: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    evm: {\n      /**\n       * Not enough balance to perform action\n       **/\n      BalanceLow: AugmentedError<ApiType>;\n      /**\n       * Calculating total fee overflowed\n       **/\n      FeeOverflow: AugmentedError<ApiType>;\n      /**\n       * Gas limit is too high.\n       **/\n      GasLimitTooHigh: AugmentedError<ApiType>;\n      /**\n       * Gas limit is too low.\n       **/\n      GasLimitTooLow: AugmentedError<ApiType>;\n      /**\n       * Gas price is too low.\n       **/\n      GasPriceTooLow: AugmentedError<ApiType>;\n      /**\n       * Nonce is invalid\n       **/\n      InvalidNonce: AugmentedError<ApiType>;\n      /**\n       * Calculating total payment overflowed\n       **/\n      PaymentOverflow: AugmentedError<ApiType>;\n      /**\n       * Undefined error.\n       **/\n      Undefined: AugmentedError<ApiType>;\n      /**\n       * Withdraw fee failed\n       **/\n      WithdrawFailed: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    feeProxy: {\n      /**\n       * The selected fee token is equal to the native gas token\n       **/\n      FeeTokenIsGasToken: AugmentedError<ApiType>;\n      /**\n       * The inner call is a fee preference call\n       **/\n      NestedFeePreferenceCall: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    futurepass: {\n      /**\n       * Account is already futurepass holder\n       **/\n      AccountAlreadyRegistered: AugmentedError<ApiType>;\n      /**\n       * Account already exists as a delegate\n       **/\n      DelegateAlreadyExists: AugmentedError<ApiType>;\n      /**\n       * Account is not futurepass delegate\n       **/\n      DelegateNotRegistered: AugmentedError<ApiType>;\n      /**\n       * Futurepass migrator admin account is not set\n       **/\n      MigratorNotSet: AugmentedError<ApiType>;\n      /**\n       * Account is not futurepass owner\n       **/\n      NotFuturepassOwner: AugmentedError<ApiType>;\n      /**\n       * Futurepass owner cannot remove themselves\n       **/\n      OwnerCannotUnregister: AugmentedError<ApiType>;\n      /**\n       * Account does not have permission to call this function\n       **/\n      PermissionDenied: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    grandpa: {\n      /**\n       * Attempt to signal GRANDPA change with one already pending.\n       **/\n      ChangePending: AugmentedError<ApiType>;\n      /**\n       * A given equivocation report is valid but already previously reported.\n       **/\n      DuplicateOffenceReport: AugmentedError<ApiType>;\n      /**\n       * An equivocation proof provided as part of an equivocation report is invalid.\n       **/\n      InvalidEquivocationProof: AugmentedError<ApiType>;\n      /**\n       * A key ownership proof provided as part of an equivocation report is invalid.\n       **/\n      InvalidKeyOwnershipProof: AugmentedError<ApiType>;\n      /**\n       * Attempt to signal GRANDPA pause when the authority set isn't live\n       * (either paused or already pending pause).\n       **/\n      PauseFailed: AugmentedError<ApiType>;\n      /**\n       * Attempt to signal GRANDPA resume when the authority set isn't paused\n       * (either live or already pending resume).\n       **/\n      ResumeFailed: AugmentedError<ApiType>;\n      /**\n       * Cannot signal forced change so soon after last.\n       **/\n      TooSoon: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    imOnline: {\n      /**\n       * Duplicated heartbeat.\n       **/\n      DuplicatedHeartbeat: AugmentedError<ApiType>;\n      /**\n       * Non existent public key.\n       **/\n      InvalidKey: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    nft: {\n      /**\n       * Attemped to mint a token that was bridged from a different chain\n       **/\n      AttemptedMintOnBridgedToken: AugmentedError<ApiType>;\n      /**\n       * Auction bid was lower than reserve or current highest bid\n       **/\n      BidTooLow: AugmentedError<ApiType>;\n      /**\n       * Cannot claim already claimed collections\n       **/\n      CannotClaimNonClaimableCollections: AugmentedError<ApiType>;\n      /**\n       * Total issuance of collection must be zero to add xls20 compatibility\n       **/\n      CollectionIssuanceNotZero: AugmentedError<ApiType>;\n      /**\n       * Given collection name is invalid (invalid utf-8, too long, empty)\n       **/\n      CollectionNameInvalid: AugmentedError<ApiType>;\n      /**\n       * Initial issuance on XLS-20 compatible collections must be zero\n       **/\n      InitialIssuanceNotZero: AugmentedError<ApiType>;\n      /**\n       * Max issuance needs to be greater than 0 and initial_issuance\n       * Cannot exceed MaxTokensPerCollection\n       **/\n      InvalidMaxIssuance: AugmentedError<ApiType>;\n      /**\n       * The metadata path is invalid (non-utf8 or empty)\n       **/\n      InvalidMetadataPath: AugmentedError<ApiType>;\n      /**\n       * No offer exists for the given OfferId\n       **/\n      InvalidOffer: AugmentedError<ApiType>;\n      /**\n       * The caller owns the token and can't make an offer\n       **/\n      IsTokenOwner: AugmentedError<ApiType>;\n      /**\n       * The account_id hasn't been registered as a marketplace\n       **/\n      MarketplaceNotRegistered: AugmentedError<ApiType>;\n      /**\n       * The max issuance has already been set and can't be changed\n       **/\n      MaxIssuanceAlreadySet: AugmentedError<ApiType>;\n      /**\n       * The collection max issuance has been reached and no more tokens can be minted\n       **/\n      MaxIssuanceReached: AugmentedError<ApiType>;\n      /**\n       * The maximum number of offers on this token has been reached\n       **/\n      MaxOffersReached: AugmentedError<ApiType>;\n      /**\n       * The quantity exceeds the max tokens per mint limit\n       **/\n      MintLimitExceeded: AugmentedError<ApiType>;\n      /**\n       * Selling tokens from different collection is not allowed\n       **/\n      MixedBundleSale: AugmentedError<ApiType>;\n      /**\n       * No more Ids are available, they've been exhausted\n       **/\n      NoAvailableIds: AugmentedError<ApiType>;\n      /**\n       * The collection does not exist\n       **/\n      NoCollectionFound: AugmentedError<ApiType>;\n      /**\n       * The caller is not the specified buyer\n       **/\n      NotBuyer: AugmentedError<ApiType>;\n      /**\n       * Origin is not the collection owner and is not permitted to perform the operation\n       **/\n      NotCollectionOwner: AugmentedError<ApiType>;\n      /**\n       * The token is not listed for auction sale\n       **/\n      NotForAuction: AugmentedError<ApiType>;\n      /**\n       * The token is not listed for fixed price sale\n       **/\n      NotForFixedPriceSale: AugmentedError<ApiType>;\n      /**\n       * The token does not exist\n       **/\n      NoToken: AugmentedError<ApiType>;\n      /**\n       * The caller is not the seller of the NFT\n       **/\n      NotSeller: AugmentedError<ApiType>;\n      /**\n       * Origin does not own the NFT\n       **/\n      NotTokenOwner: AugmentedError<ApiType>;\n      /**\n       * Total royalties would exceed 100% of sale or an empty vec is supplied\n       **/\n      RoyaltiesInvalid: AugmentedError<ApiType>;\n      /**\n       * The number of tokens have exceeded the max tokens allowed\n       **/\n      TokenLimitExceeded: AugmentedError<ApiType>;\n      /**\n       * Cannot operate on a listed NFT\n       **/\n      TokenLocked: AugmentedError<ApiType>;\n      /**\n       * The token is not listed for sale\n       **/\n      TokenNotListed: AugmentedError<ApiType>;\n      /**\n       * Cannot make an offer on a token up for auction\n       **/\n      TokenOnAuction: AugmentedError<ApiType>;\n      /**\n       * Offer amount needs to be greater than 0\n       **/\n      ZeroOffer: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    nftPeg: {\n      /**\n       * Send more addresses than are allowed\n       **/\n      ExceedsMaxAddresses: AugmentedError<ApiType>;\n      /**\n       * Sent more tokens than are allowed\n       **/\n      ExceedsMaxTokens: AugmentedError<ApiType>;\n      /**\n       * The length of the given vec exceeds the maximal allowed length limit\n       **/\n      ExceedsMaxVecLength: AugmentedError<ApiType>;\n      /**\n       * The abi data passed in could not be decoded\n       **/\n      InvalidAbiEncoding: AugmentedError<ApiType>;\n      /**\n       * The prefix uint in the abi encoded data was invalid\n       **/\n      InvalidAbiPrefix: AugmentedError<ApiType>;\n      /**\n       * No collection info exists\n       **/\n      NoCollectionFound: AugmentedError<ApiType>;\n      /**\n       * No mapped token was stored for bridging the token back to the bridged chain\n       * chain(Should not happen)\n       **/\n      NoMappedTokenExists: AugmentedError<ApiType>;\n      /**\n       * Tried to bridge a token that originates from Root, which is not yet supported\n       **/\n      NoPermissionToBridge: AugmentedError<ApiType>;\n      /**\n       * The state sync decoding feature is not implemented\n       **/\n      StateSyncDisabled: AugmentedError<ApiType>;\n      /**\n       * Multiple tokens were passed from contract, but amounts were unqeual per each array\n       **/\n      TokenListLengthMismatch: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    proxy: {\n      /**\n       * Account is already a proxy.\n       **/\n      Duplicate: AugmentedError<ApiType>;\n      /**\n       * Call may not be made by proxy because it may escalate its privileges.\n       **/\n      NoPermission: AugmentedError<ApiType>;\n      /**\n       * Cannot add self as proxy.\n       **/\n      NoSelfProxy: AugmentedError<ApiType>;\n      /**\n       * Proxy registration not found.\n       **/\n      NotFound: AugmentedError<ApiType>;\n      /**\n       * Sender is not a proxy of the account to be proxied.\n       **/\n      NotProxy: AugmentedError<ApiType>;\n      /**\n       * There are too many proxies registered or too many announcements pending.\n       **/\n      TooMany: AugmentedError<ApiType>;\n      /**\n       * Announcement, if made at all, was made too recently.\n       **/\n      Unannounced: AugmentedError<ApiType>;\n      /**\n       * A call which is incompatible with the proxy type's filter was attempted.\n       **/\n      Unproxyable: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    recovery: {\n      /**\n       * This account is already set up for recovery\n       **/\n      AlreadyProxy: AugmentedError<ApiType>;\n      /**\n       * This account is already set up for recovery\n       **/\n      AlreadyRecoverable: AugmentedError<ApiType>;\n      /**\n       * A recovery process has already started for this account\n       **/\n      AlreadyStarted: AugmentedError<ApiType>;\n      /**\n       * This user has already vouched for this recovery\n       **/\n      AlreadyVouched: AugmentedError<ApiType>;\n      /**\n       * Some internal state is broken.\n       **/\n      BadState: AugmentedError<ApiType>;\n      /**\n       * The friend must wait until the delay period to vouch for this recovery\n       **/\n      DelayPeriod: AugmentedError<ApiType>;\n      /**\n       * Friends list must be less than max friends\n       **/\n      MaxFriends: AugmentedError<ApiType>;\n      /**\n       * User is not allowed to make a call on behalf of this account\n       **/\n      NotAllowed: AugmentedError<ApiType>;\n      /**\n       * Friends list must be greater than zero and threshold\n       **/\n      NotEnoughFriends: AugmentedError<ApiType>;\n      /**\n       * This account is not a friend who can vouch\n       **/\n      NotFriend: AugmentedError<ApiType>;\n      /**\n       * This account is not set up for recovery\n       **/\n      NotRecoverable: AugmentedError<ApiType>;\n      /**\n       * Friends list must be sorted and free of duplicates\n       **/\n      NotSorted: AugmentedError<ApiType>;\n      /**\n       * A recovery process has not started for this rescuer\n       **/\n      NotStarted: AugmentedError<ApiType>;\n      /**\n       * There are still active recovery attempts that need to be closed\n       **/\n      StillActive: AugmentedError<ApiType>;\n      /**\n       * The threshold for recovering this account has not been met\n       **/\n      Threshold: AugmentedError<ApiType>;\n      /**\n       * Threshold must be greater than zero\n       **/\n      ZeroThreshold: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    scheduler: {\n      /**\n       * Failed to schedule a call\n       **/\n      FailedToSchedule: AugmentedError<ApiType>;\n      /**\n       * Cannot find the scheduled call.\n       **/\n      NotFound: AugmentedError<ApiType>;\n      /**\n       * Reschedule failed because it does not change scheduled time.\n       **/\n      RescheduleNoChange: AugmentedError<ApiType>;\n      /**\n       * Given target block number is in the past.\n       **/\n      TargetBlockNumberInPast: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    session: {\n      /**\n       * Registered duplicate key.\n       **/\n      DuplicatedKey: AugmentedError<ApiType>;\n      /**\n       * Invalid ownership proof.\n       **/\n      InvalidProof: AugmentedError<ApiType>;\n      /**\n       * Key setting account is not live, so it's impossible to associate keys.\n       **/\n      NoAccount: AugmentedError<ApiType>;\n      /**\n       * No associated validator ID for account.\n       **/\n      NoAssociatedValidatorId: AugmentedError<ApiType>;\n      /**\n       * No keys are associated with this account.\n       **/\n      NoKeys: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    staking: {\n      /**\n       * Stash is already bonded.\n       **/\n      AlreadyBonded: AugmentedError<ApiType>;\n      /**\n       * Rewards for this era have already been claimed for this validator.\n       **/\n      AlreadyClaimed: AugmentedError<ApiType>;\n      /**\n       * Controller is already paired.\n       **/\n      AlreadyPaired: AugmentedError<ApiType>;\n      /**\n       * Internal state has become somehow corrupted and the operation cannot continue.\n       **/\n      BadState: AugmentedError<ApiType>;\n      /**\n       * A nomination target was supplied that was blocked or otherwise not a validator.\n       **/\n      BadTarget: AugmentedError<ApiType>;\n      /**\n       * The user has enough bond and thus cannot be chilled forcefully by an external person.\n       **/\n      CannotChillOther: AugmentedError<ApiType>;\n      /**\n       * Commission is too low. Must be at least `MinCommission`.\n       **/\n      CommissionTooLow: AugmentedError<ApiType>;\n      /**\n       * Duplicate index.\n       **/\n      DuplicateIndex: AugmentedError<ApiType>;\n      /**\n       * Targets cannot be empty.\n       **/\n      EmptyTargets: AugmentedError<ApiType>;\n      /**\n       * Attempting to target a stash that still has funds.\n       **/\n      FundedTarget: AugmentedError<ApiType>;\n      /**\n       * Incorrect previous history depth input provided.\n       **/\n      IncorrectHistoryDepth: AugmentedError<ApiType>;\n      /**\n       * Incorrect number of slashing spans provided.\n       **/\n      IncorrectSlashingSpans: AugmentedError<ApiType>;\n      /**\n       * Cannot have a validator or nominator role, with value less than the minimum defined by\n       * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the\n       * intention, `chill` first to remove one's role as validator/nominator.\n       **/\n      InsufficientBond: AugmentedError<ApiType>;\n      /**\n       * Invalid era to reward.\n       **/\n      InvalidEraToReward: AugmentedError<ApiType>;\n      /**\n       * Invalid number of nominations.\n       **/\n      InvalidNumberOfNominations: AugmentedError<ApiType>;\n      /**\n       * Slash record index out of bounds.\n       **/\n      InvalidSlashIndex: AugmentedError<ApiType>;\n      /**\n       * Can not schedule more unlock chunks.\n       **/\n      NoMoreChunks: AugmentedError<ApiType>;\n      /**\n       * Not a controller account.\n       **/\n      NotController: AugmentedError<ApiType>;\n      /**\n       * Items are not sorted and unique.\n       **/\n      NotSortedAndUnique: AugmentedError<ApiType>;\n      /**\n       * Not a stash account.\n       **/\n      NotStash: AugmentedError<ApiType>;\n      /**\n       * Can not rebond without unlocking chunks.\n       **/\n      NoUnlockChunk: AugmentedError<ApiType>;\n      /**\n       * There are too many nominators in the system. Governance needs to adjust the staking\n       * settings to keep things safe for the runtime.\n       **/\n      TooManyNominators: AugmentedError<ApiType>;\n      /**\n       * Too many nomination targets supplied.\n       **/\n      TooManyTargets: AugmentedError<ApiType>;\n      /**\n       * There are too many validators in the system. Governance needs to adjust the staking\n       * settings to keep things safe for the runtime.\n       **/\n      TooManyValidators: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    sudo: {\n      /**\n       * Sender must be the Sudo account\n       **/\n      RequireSudo: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    system: {\n      /**\n       * The origin filter prevent the call to be dispatched.\n       **/\n      CallFiltered: AugmentedError<ApiType>;\n      /**\n       * Failed to extract the runtime version from the new runtime.\n       * \n       * Either calling `Core_version` or decoding `RuntimeVersion` failed.\n       **/\n      FailedToExtractRuntimeVersion: AugmentedError<ApiType>;\n      /**\n       * The name of specification does not match between the current runtime\n       * and the new runtime.\n       **/\n      InvalidSpecName: AugmentedError<ApiType>;\n      /**\n       * Suicide called when the account has non-default composite data.\n       **/\n      NonDefaultComposite: AugmentedError<ApiType>;\n      /**\n       * There is a non-zero reference count preventing the account from being purged.\n       **/\n      NonZeroRefCount: AugmentedError<ApiType>;\n      /**\n       * The specification version is not allowed to decrease between the current runtime\n       * and the new runtime.\n       **/\n      SpecVersionNeedsToIncrease: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    tokenApprovals: {\n      /**\n       * Address is already approved\n       **/\n      AlreadyApproved: AugmentedError<ApiType>;\n      /**\n       * There is no approval set for this token\n       **/\n      ApprovalDoesntExist: AugmentedError<ApiType>;\n      /**\n       * The caller is not approved for the requested amount\n       **/\n      ApprovedAmountTooLow: AugmentedError<ApiType>;\n      /**\n       * The caller isn't approved for any amount\n       **/\n      CallerNotApproved: AugmentedError<ApiType>;\n      /**\n       * The caller account can't be the same as the operator account\n       **/\n      CallerNotOperator: AugmentedError<ApiType>;\n      /**\n       * The token doesn't exist\n       **/\n      NoToken: AugmentedError<ApiType>;\n      /**\n       * The account is not the owner of the token\n       **/\n      NotTokenOwner: AugmentedError<ApiType>;\n      /**\n       * The account is not the owner of the token or an approved account\n       **/\n      NotTokenOwnerOrApproved: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    utility: {\n      /**\n       * Too many calls batched.\n       **/\n      TooManyCalls: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    voterList: {\n      /**\n       * A error in the list interface implementation.\n       **/\n      List: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    xls20: {\n      /**\n       * There is already a Root native -> XLS-20 mapping for this token\n       **/\n      MappingAlreadyExists: AugmentedError<ApiType>;\n      /**\n       * No the owner of the collection\n       **/\n      NotCollectionOwner: AugmentedError<ApiType>;\n      /**\n       * The NFT does not exist\n       **/\n      NoToken: AugmentedError<ApiType>;\n      /**\n       * The caller is not the relayer and does not have permission to perform this action\n       **/\n      NotRelayer: AugmentedError<ApiType>;\n      /**\n       * The collection is not compatible with XLS-20\n       **/\n      NotXLS20Compatible: AugmentedError<ApiType>;\n      /**\n       * The supplied fee for minting XLS-20 tokens is too low\n       **/\n      Xls20MintFeeTooLow: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n    xrplBridge: {\n      /**\n       * Cannot process more transactions at that block\n       **/\n      CannotProcessMoreTransactionsAtThatBlock: AugmentedError<ApiType>;\n      /**\n       * The door address has not been configured\n       **/\n      DoorAddressNotSet: AugmentedError<ApiType>;\n      /**\n       * The signers are not known by ethy\n       **/\n      InvalidSigners: AugmentedError<ApiType>;\n      /**\n       * The NextTicketSequenceParams is invalid\n       **/\n      NextTicketSequenceParamsInvalid: AugmentedError<ApiType>;\n      /**\n       * The NextTicketSequenceParams has not been set\n       **/\n      NextTicketSequenceParamsNotSet: AugmentedError<ApiType>;\n      NotPermitted: AugmentedError<ApiType>;\n      RelayerDoesNotExists: AugmentedError<ApiType>;\n      /**\n       * The TicketSequenceParams is invalid\n       **/\n      TicketSequenceParamsInvalid: AugmentedError<ApiType>;\n      /**\n       * XRPL does not allow more than 8 signers for door address\n       **/\n      TooManySigners: AugmentedError<ApiType>;\n      /**\n       * Submitted a duplicate transaction hash\n       **/\n      TxReplay: AugmentedError<ApiType>;\n      /**\n       * Withdraw amount must be non-zero and <= u64\n       **/\n      WithdrawInvalidAmount: AugmentedError<ApiType>;\n      /**\n       * Generic error\n       **/\n      [key: string]: AugmentedError<ApiType>;\n    };\n  } // AugmentedErrors\n} // declare module\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-events.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/api-base/types/events';\n\nimport type { ApiTypes, AugmentedEvent } from '@polkadot/api-base/types';\nimport type { Bytes, Null, Option, Result, U8aFixed, Vec, bool, u128, u16, u32, u64, u8 } from '@polkadot/types-codec';\nimport type { ITuple } from '@polkadot/types-codec/types';\nimport type { EthereumLog, EvmCoreErrorExitReason, FrameSupportScheduleLookupError, FrameSupportTokensMiscBalanceStatus, FrameSupportWeightsDispatchInfo, PalletDexTradingPair, PalletElectionProviderMultiPhaseElectionCompute, PalletEthyEthySigningRequest, PalletEthyEventClaim, PalletImOnlineSr25519AppSr25519Public, PalletNftAuctionClosureReason, PalletNftCrossChainCompatibility, PalletNftFixedPriceClosureReason, PalletNftOriginChain, PalletNftRoyaltiesSchedule, PalletStakingExposure, PalletStakingValidatorPrefs, SeedPalletCommonEventRouterError, SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, SpFinalityGrandpaAppPublic, SpRuntimeDispatchError } from '@polkadot/types/lookup';\nimport type { H160, H256, H512, Permill } from '@therootnetwork/types/interfaces/runtime';\n\nexport type __AugmentedEvent<ApiType extends ApiTypes> = AugmentedEvent<ApiType>;\n\ndeclare module '@polkadot/api-base/types/events' {\n  interface AugmentedEvents<ApiType extends ApiTypes> {\n    assets: {\n      /**\n       * An approval for account `delegate` was cancelled by `owner`.\n       **/\n      ApprovalCancelled: AugmentedEvent<ApiType, [assetId: u32, owner: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20], { assetId: u32, owner: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * (Additional) funds have been approved for transfer to a destination account.\n       **/\n      ApprovedTransfer: AugmentedEvent<ApiType, [assetId: u32, source: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20, amount: u128], { assetId: u32, source: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Some asset `asset_id` was frozen.\n       **/\n      AssetFrozen: AugmentedEvent<ApiType, [assetId: u32], { assetId: u32 }>;\n      /**\n       * An asset has had its attributes changed by the `Force` origin.\n       **/\n      AssetStatusChanged: AugmentedEvent<ApiType, [assetId: u32], { assetId: u32 }>;\n      /**\n       * Some asset `asset_id` was thawed.\n       **/\n      AssetThawed: AugmentedEvent<ApiType, [assetId: u32], { assetId: u32 }>;\n      /**\n       * Some assets were destroyed.\n       **/\n      Burned: AugmentedEvent<ApiType, [assetId: u32, owner: SeedPrimitivesSignatureAccountId20, balance: u128], { assetId: u32, owner: SeedPrimitivesSignatureAccountId20, balance: u128 }>;\n      /**\n       * Some asset class was created.\n       **/\n      Created: AugmentedEvent<ApiType, [assetId: u32, creator: SeedPrimitivesSignatureAccountId20, owner: SeedPrimitivesSignatureAccountId20], { assetId: u32, creator: SeedPrimitivesSignatureAccountId20, owner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * An asset class was destroyed.\n       **/\n      Destroyed: AugmentedEvent<ApiType, [assetId: u32], { assetId: u32 }>;\n      /**\n       * Some asset class was force-created.\n       **/\n      ForceCreated: AugmentedEvent<ApiType, [assetId: u32, owner: SeedPrimitivesSignatureAccountId20], { assetId: u32, owner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Some account `who` was frozen.\n       **/\n      Frozen: AugmentedEvent<ApiType, [assetId: u32, who: SeedPrimitivesSignatureAccountId20], { assetId: u32, who: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Some assets were issued.\n       **/\n      Issued: AugmentedEvent<ApiType, [assetId: u32, owner: SeedPrimitivesSignatureAccountId20, totalSupply: u128], { assetId: u32, owner: SeedPrimitivesSignatureAccountId20, totalSupply: u128 }>;\n      /**\n       * Metadata has been cleared for an asset.\n       **/\n      MetadataCleared: AugmentedEvent<ApiType, [assetId: u32], { assetId: u32 }>;\n      /**\n       * New metadata has been set for an asset.\n       **/\n      MetadataSet: AugmentedEvent<ApiType, [assetId: u32, name: Bytes, symbol_: Bytes, decimals: u8, isFrozen: bool], { assetId: u32, name: Bytes, symbol: Bytes, decimals: u8, isFrozen: bool }>;\n      /**\n       * The owner changed.\n       **/\n      OwnerChanged: AugmentedEvent<ApiType, [assetId: u32, owner: SeedPrimitivesSignatureAccountId20], { assetId: u32, owner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * The management team changed.\n       **/\n      TeamChanged: AugmentedEvent<ApiType, [assetId: u32, issuer: SeedPrimitivesSignatureAccountId20, admin: SeedPrimitivesSignatureAccountId20, freezer: SeedPrimitivesSignatureAccountId20], { assetId: u32, issuer: SeedPrimitivesSignatureAccountId20, admin: SeedPrimitivesSignatureAccountId20, freezer: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Some account `who` was thawed.\n       **/\n      Thawed: AugmentedEvent<ApiType, [assetId: u32, who: SeedPrimitivesSignatureAccountId20], { assetId: u32, who: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Some assets were transferred.\n       **/\n      Transferred: AugmentedEvent<ApiType, [assetId: u32, from: SeedPrimitivesSignatureAccountId20, to: SeedPrimitivesSignatureAccountId20, amount: u128], { assetId: u32, from: SeedPrimitivesSignatureAccountId20, to: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * An `amount` was transferred in its entirety from `owner` to `destination` by\n       * the approved `delegate`.\n       **/\n      TransferredApproved: AugmentedEvent<ApiType, [assetId: u32, owner: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20, destination: SeedPrimitivesSignatureAccountId20, amount: u128], { assetId: u32, owner: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20, destination: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    assetsExt: {\n      /**\n       * New asset has been created\n       **/\n      CreateAsset: AugmentedEvent<ApiType, [assetId: u32, creator: SeedPrimitivesSignatureAccountId20, initialBalance: u128], { assetId: u32, creator: SeedPrimitivesSignatureAccountId20, initialBalance: u128 }>;\n      /**\n       * Assets were deposited into this account by the system e.g. refunding gas\n       **/\n      InternalDeposit: AugmentedEvent<ApiType, [assetId: u32, who: SeedPrimitivesSignatureAccountId20, amount: u128], { assetId: u32, who: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Assets were withdrawn from this account by the system e.g. paying tx fees\n       **/\n      InternalWithdraw: AugmentedEvent<ApiType, [assetId: u32, who: SeedPrimitivesSignatureAccountId20, amount: u128], { assetId: u32, who: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Some assets have been placed on hold by a pallet\n       **/\n      PlaceHold: AugmentedEvent<ApiType, [assetId: u32, who: SeedPrimitivesSignatureAccountId20, amount: u128, palletId: U8aFixed], { assetId: u32, who: SeedPrimitivesSignatureAccountId20, amount: u128, palletId: U8aFixed }>;\n      /**\n       * Some held assets have been released by a pallet\n       **/\n      ReleaseHold: AugmentedEvent<ApiType, [assetId: u32, who: SeedPrimitivesSignatureAccountId20, amount: u128, palletId: U8aFixed], { assetId: u32, who: SeedPrimitivesSignatureAccountId20, amount: u128, palletId: U8aFixed }>;\n      /**\n       * Some held assets were spend by a pallet\n       **/\n      SpendHold: AugmentedEvent<ApiType, [assetId: u32, who: SeedPrimitivesSignatureAccountId20, spends: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, u128]>>, palletId: U8aFixed], { assetId: u32, who: SeedPrimitivesSignatureAccountId20, spends: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, u128]>>, palletId: U8aFixed }>;\n      /**\n       * Multi-part transfer of assets from who\n       **/\n      SplitTransfer: AugmentedEvent<ApiType, [assetId: u32, who: SeedPrimitivesSignatureAccountId20, transfers: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, u128]>>], { assetId: u32, who: SeedPrimitivesSignatureAccountId20, transfers: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, u128]>> }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    balances: {\n      /**\n       * A balance was set by root.\n       **/\n      BalanceSet: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, free: u128, reserved: u128], { who: SeedPrimitivesSignatureAccountId20, free: u128, reserved: u128 }>;\n      /**\n       * Some amount was deposited (e.g. for transaction fees).\n       **/\n      Deposit: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, amount: u128], { who: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * An account was removed whose balance was non-zero but below ExistentialDeposit,\n       * resulting in an outright loss.\n       **/\n      DustLost: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20, amount: u128], { account: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * An account was created with some free balance.\n       **/\n      Endowed: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20, freeBalance: u128], { account: SeedPrimitivesSignatureAccountId20, freeBalance: u128 }>;\n      /**\n       * Some balance was reserved (moved from free to reserved).\n       **/\n      Reserved: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, amount: u128], { who: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Some balance was moved from the reserve of the first account to the second account.\n       * Final argument indicates the destination balance type.\n       **/\n      ReserveRepatriated: AugmentedEvent<ApiType, [from: SeedPrimitivesSignatureAccountId20, to: SeedPrimitivesSignatureAccountId20, amount: u128, destinationStatus: FrameSupportTokensMiscBalanceStatus], { from: SeedPrimitivesSignatureAccountId20, to: SeedPrimitivesSignatureAccountId20, amount: u128, destinationStatus: FrameSupportTokensMiscBalanceStatus }>;\n      /**\n       * Some amount was removed from the account (e.g. for misbehavior).\n       **/\n      Slashed: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, amount: u128], { who: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Transfer succeeded.\n       **/\n      Transfer: AugmentedEvent<ApiType, [from: SeedPrimitivesSignatureAccountId20, to: SeedPrimitivesSignatureAccountId20, amount: u128], { from: SeedPrimitivesSignatureAccountId20, to: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Some balance was unreserved (moved from reserved to free).\n       **/\n      Unreserved: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, amount: u128], { who: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Some amount was withdrawn from the account (e.g. for transaction fees).\n       **/\n      Withdraw: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, amount: u128], { who: SeedPrimitivesSignatureAccountId20, amount: u128 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    dex: {\n      /**\n       * Add liquidity success. \\[who, asset_id_0, reserve_0_increment,\n       * asset_id_1, reserve_1_increment, share_increment\\]\n       **/\n      AddLiquidity: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u32, u128, u32, u128, u128]>;\n      /**\n       * add provision success \\[who, asset_id_0, contribution_0,\n       * asset_id_1, contribution_1\\]\n       **/\n      AddProvision: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u32, u128, u32, u128]>;\n      /**\n       * Disable trading pair. \\[trading_pair\\]\n       **/\n      DisableTradingPair: AugmentedEvent<ApiType, [PalletDexTradingPair]>;\n      /**\n       * Enable trading pair. \\[trading_pair\\]\n       **/\n      EnableTradingPair: AugmentedEvent<ApiType, [PalletDexTradingPair]>;\n      /**\n       * Provisioning trading pair convert to Enabled. \\[trading_pair,\n       * pool_0_amount, pool_1_amount, total_share_amount\\]\n       **/\n      ProvisioningToEnabled: AugmentedEvent<ApiType, [PalletDexTradingPair, u128, u128, u128]>;\n      /**\n       * Remove liquidity from the trading pool success. \\[who,\n       * asset_id_0, reserve_0_decrement, asset_id_1, reserve_1_decrement,\n       * share_decrement\\]\n       **/\n      RemoveLiquidity: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u32, u128, u32, u128, u128]>;\n      /**\n       * Use supply Asset to swap target Asset. \\[trader, trading_path,\n       * supply_Asset_amount, target_Asset_amount\\]\n       **/\n      Swap: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, Vec<u32>, u128, u128]>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    echo: {\n      /**\n       * A ping was received from Ethereum\n       **/\n      PingReceived: AugmentedEvent<ApiType, [sessionId: u64, source: H160, data: Bytes], { sessionId: u64, source: H160, data: Bytes }>;\n      /**\n       * A ping message was sent to Ethereum\n       **/\n      PingSent: AugmentedEvent<ApiType, [sessionId: u64, source: H160, destination: H160, eventProofId: u64], { sessionId: u64, source: H160, destination: H160, eventProofId: u64 }>;\n      /**\n       * A pong response was received from Ethereum\n       **/\n      PongReceived: AugmentedEvent<ApiType, [sessionId: u64, source: H160, data: Bytes], { sessionId: u64, source: H160, data: Bytes }>;\n      /**\n       * A pong message was sent to Ethereum\n       **/\n      PongSent: AugmentedEvent<ApiType, [sessionId: u64, source: H160, destination: H160, eventProofId: u64], { sessionId: u64, source: H160, destination: H160, eventProofId: u64 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    electionProviderMultiPhase: {\n      /**\n       * The election has been finalized, with `Some` of the given computation, or else if the\n       * election failed, `None`.\n       **/\n      ElectionFinalized: AugmentedEvent<ApiType, [electionCompute: Option<PalletElectionProviderMultiPhaseElectionCompute>], { electionCompute: Option<PalletElectionProviderMultiPhaseElectionCompute> }>;\n      /**\n       * An account has been rewarded for their signed submission being finalized.\n       **/\n      Rewarded: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20, value: u128], { account: SeedPrimitivesSignatureAccountId20, value: u128 }>;\n      /**\n       * The signed phase of the given round has started.\n       **/\n      SignedPhaseStarted: AugmentedEvent<ApiType, [round: u32], { round: u32 }>;\n      /**\n       * An account has been slashed for submitting an invalid signed submission.\n       **/\n      Slashed: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20, value: u128], { account: SeedPrimitivesSignatureAccountId20, value: u128 }>;\n      /**\n       * A solution was stored with the given compute.\n       * \n       * If the solution is signed, this means that it hasn't yet been processed. If the\n       * solution is unsigned, this means that it has also been processed.\n       * \n       * The `bool` is `true` when a previous solution was ejected to make room for this one.\n       **/\n      SolutionStored: AugmentedEvent<ApiType, [electionCompute: PalletElectionProviderMultiPhaseElectionCompute, prevEjected: bool], { electionCompute: PalletElectionProviderMultiPhaseElectionCompute, prevEjected: bool }>;\n      /**\n       * The unsigned phase of the given round has started.\n       **/\n      UnsignedPhaseStarted: AugmentedEvent<ApiType, [round: u32], { round: u32 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    erc20Peg: {\n      /**\n       * A delayed erc20 deposit has failed (payment_id, beneficiary)\n       **/\n      DelayedErc20DepositFailed: AugmentedEvent<ApiType, [u64, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * A delayed erc20 withdrawal has failed (asset_id, beneficiary)\n       **/\n      DelayedErc20WithdrawalFailed: AugmentedEvent<ApiType, [u32, H160]>;\n      /**\n       * A bridged erc20 deposit succeeded. (asset, amount, beneficiary)\n       **/\n      Erc20Deposit: AugmentedEvent<ApiType, [u32, u128, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * An erc20 deposit has been delayed.(payment_id, scheduled block, amount, beneficiary)\n       **/\n      Erc20DepositDelayed: AugmentedEvent<ApiType, [u64, u32, u128, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * A bridged erc20 deposit failed. (source address, abi data)\n       **/\n      Erc20DepositFail: AugmentedEvent<ApiType, [H160, Bytes]>;\n      /**\n       * Tokens were burnt for withdrawal on Ethereum as ERC20s (asset, amount, beneficiary)\n       **/\n      Erc20Withdraw: AugmentedEvent<ApiType, [u32, u128, H160]>;\n      /**\n       * A withdrawal has been delayed.(payment_id, scheduled block, amount, beneficiary)\n       **/\n      Erc20WithdrawalDelayed: AugmentedEvent<ApiType, [u64, u32, u128, H160]>;\n      /**\n       * There are no more payment ids available, they've been exhausted\n       **/\n      NoAvailableDelayedPaymentIds: AugmentedEvent<ApiType, []>;\n      /**\n       * A delay was added for an asset_id (asset_id, min_balance, delay)\n       **/\n      PaymentDelaySet: AugmentedEvent<ApiType, [u32, u128, u32]>;\n      /**\n       * The peg contract address has been set\n       **/\n      SetContractAddress: AugmentedEvent<ApiType, [H160]>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    ethBridge: {\n      /**\n       * A notary (validator) set change is in motion (event_id, new_validator_set_id)\n       * A proof for the change will be generated with the given `event_id`\n       **/\n      AuthoritySetChange: AugmentedEvent<ApiType, [u64, u64]>;\n      /**\n       * An event has been challenged (claim_id, challenger)\n       **/\n      Challenged: AugmentedEvent<ApiType, [u64, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * An event proof has been sent for signing by ethy-gadget\n       **/\n      EventSend: AugmentedEvent<ApiType, [eventProofId: u64, signingRequest: PalletEthyEthySigningRequest], { eventProofId: u64, signingRequest: PalletEthyEthySigningRequest }>;\n      /**\n       * An event has been submitted from Ethereum (event_claim_id, event_claim, process_at)\n       **/\n      EventSubmit: AugmentedEvent<ApiType, [u64, PalletEthyEventClaim, u32]>;\n      /**\n       * The schedule to unpause the bridge has failed (scheduled_block)\n       **/\n      FinaliseScheduleFail: AugmentedEvent<ApiType, [u32]>;\n      /**\n       * Verifying an event failed\n       **/\n      Invalid: AugmentedEvent<ApiType, [u64]>;\n      /**\n       * The event is still awaiting consensus. Process block pushed out (claim_id, process_at)\n       **/\n      ProcessAtExtended: AugmentedEvent<ApiType, [u64, u32]>;\n      /**\n       * Processing an event failed\n       **/\n      ProcessingFailed: AugmentedEvent<ApiType, [u64, SeedPalletCommonEventRouterError]>;\n      /**\n       * Processing an event succeeded\n       **/\n      ProcessingOk: AugmentedEvent<ApiType, [u64]>;\n      /**\n       * Generating event proof delayed as bridge is paused\n       **/\n      ProofDelayed: AugmentedEvent<ApiType, [u64]>;\n      /**\n       * An account has deposited a relayer bond\n       **/\n      RelayerBondDeposit: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * An account has withdrawn a relayer bond\n       **/\n      RelayerBondWithdraw: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * A new relayer has been set\n       **/\n      RelayerSet: AugmentedEvent<ApiType, [Option<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * The bridge contract address has been set\n       **/\n      SetContractAddress: AugmentedEvent<ApiType, [H160]>;\n      /**\n       * Verifying an event succeeded\n       **/\n      Verified: AugmentedEvent<ApiType, [u64]>;\n      /**\n       * A notary (validator) set change for Xrpl is in motion (event_id, new_validator_set_id)\n       * A proof for the change will be generated with the given `event_id`\n       **/\n      XrplAuthoritySetChange: AugmentedEvent<ApiType, [u64, u64]>;\n      /**\n       * Xrpl authority set change request failed\n       **/\n      XrplAuthoritySetChangeRequestFailed: AugmentedEvent<ApiType, []>;\n      /**\n       * Xrpl Door signers are set\n       **/\n      XrplDoorSignersSet: AugmentedEvent<ApiType, []>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    ethereum: {\n      /**\n       * An ethereum transaction was successfully executed.\n       **/\n      Executed: AugmentedEvent<ApiType, [from: H160, to: H160, transactionHash: H256, exitReason: EvmCoreErrorExitReason], { from: H160, to: H160, transactionHash: H256, exitReason: EvmCoreErrorExitReason }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    evm: {\n      /**\n       * A contract has been created at given address.\n       **/\n      Created: AugmentedEvent<ApiType, [address: H160], { address: H160 }>;\n      /**\n       * A contract was attempted to be created, but the execution failed.\n       **/\n      CreatedFailed: AugmentedEvent<ApiType, [address: H160], { address: H160 }>;\n      /**\n       * A contract has been executed successfully with states applied.\n       **/\n      Executed: AugmentedEvent<ApiType, [address: H160], { address: H160 }>;\n      /**\n       * A contract has been executed with errors. States are reverted with only gas fees applied.\n       **/\n      ExecutedFailed: AugmentedEvent<ApiType, [address: H160], { address: H160 }>;\n      /**\n       * Ethereum events from contracts.\n       **/\n      Log: AugmentedEvent<ApiType, [log: EthereumLog], { log: EthereumLog }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    evmChainId: {\n      ChainIdSet: AugmentedEvent<ApiType, [u64]>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    feeControl: {\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    feeProxy: {\n      /**\n       * A call was made with specified payment asset\n       **/\n      CallWithFeePreferences: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, paymentAsset: u32, maxPayment: u128], { who: SeedPrimitivesSignatureAccountId20, paymentAsset: u32, maxPayment: u128 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    futurepass: {\n      /**\n       * Futurepass set as default proxy\n       **/\n      DefaultFuturepassSet: AugmentedEvent<ApiType, [delegate: SeedPrimitivesSignatureAccountId20, futurepass: Option<SeedPrimitivesSignatureAccountId20>], { delegate: SeedPrimitivesSignatureAccountId20, futurepass: Option<SeedPrimitivesSignatureAccountId20> }>;\n      /**\n       * Delegate registration to Futurepass account\n       **/\n      DelegateRegistered: AugmentedEvent<ApiType, [futurepass: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20, proxyType: SeedRuntimeImplsProxyType], { futurepass: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20, proxyType: SeedRuntimeImplsProxyType }>;\n      /**\n       * Delegate unregistration from Futurepass account\n       **/\n      DelegateUnregistered: AugmentedEvent<ApiType, [futurepass: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20], { futurepass: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Migration of Futurepass assets\n       **/\n      FuturepassAssetsMigrated: AugmentedEvent<ApiType, [evmFuturepass: SeedPrimitivesSignatureAccountId20, futurepass: SeedPrimitivesSignatureAccountId20, collectionId: u32], { evmFuturepass: SeedPrimitivesSignatureAccountId20, futurepass: SeedPrimitivesSignatureAccountId20, collectionId: u32 }>;\n      /**\n       * Futurepass creation\n       **/\n      FuturepassCreated: AugmentedEvent<ApiType, [futurepass: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20], { futurepass: SeedPrimitivesSignatureAccountId20, delegate: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Updating Futurepass migrator account\n       **/\n      FuturepassMigratorSet: AugmentedEvent<ApiType, [migrator: SeedPrimitivesSignatureAccountId20], { migrator: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Futurepass transfer\n       **/\n      FuturepassTransferred: AugmentedEvent<ApiType, [oldOwner: SeedPrimitivesSignatureAccountId20, newOwner: SeedPrimitivesSignatureAccountId20, futurepass: SeedPrimitivesSignatureAccountId20], { oldOwner: SeedPrimitivesSignatureAccountId20, newOwner: SeedPrimitivesSignatureAccountId20, futurepass: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A proxy call was executed with the given call\n       **/\n      ProxyExecuted: AugmentedEvent<ApiType, [delegate: SeedPrimitivesSignatureAccountId20, result: Result<Null, SpRuntimeDispatchError>], { delegate: SeedPrimitivesSignatureAccountId20, result: Result<Null, SpRuntimeDispatchError> }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    grandpa: {\n      /**\n       * New authority set has been applied.\n       **/\n      NewAuthorities: AugmentedEvent<ApiType, [authoritySet: Vec<ITuple<[SpFinalityGrandpaAppPublic, u64]>>], { authoritySet: Vec<ITuple<[SpFinalityGrandpaAppPublic, u64]>> }>;\n      /**\n       * Current authority set has been paused.\n       **/\n      Paused: AugmentedEvent<ApiType, []>;\n      /**\n       * Current authority set has been resumed.\n       **/\n      Resumed: AugmentedEvent<ApiType, []>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    imOnline: {\n      /**\n       * At the end of the session, no offence was committed.\n       **/\n      AllGood: AugmentedEvent<ApiType, []>;\n      /**\n       * A new heartbeat was received from `AuthorityId`.\n       **/\n      HeartbeatReceived: AugmentedEvent<ApiType, [authorityId: PalletImOnlineSr25519AppSr25519Public], { authorityId: PalletImOnlineSr25519AppSr25519Public }>;\n      /**\n       * At the end of the session, at least one validator was found to be offline.\n       **/\n      SomeOffline: AugmentedEvent<ApiType, [offline: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, PalletStakingExposure]>>], { offline: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, PalletStakingExposure]>> }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    nft: {\n      /**\n       * An auction has closed without selling\n       **/\n      AuctionClose: AugmentedEvent<ApiType, [collectionId: u32, listingId: u128, reason: PalletNftAuctionClosureReason], { collectionId: u32, listingId: u128, reason: PalletNftAuctionClosureReason }>;\n      /**\n       * An auction has opened\n       **/\n      AuctionOpen: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, paymentAsset: u32, reservePrice: u128, listingId: u128, marketplaceId: Option<u32>, seller: SeedPrimitivesSignatureAccountId20], { collectionId: u32, serialNumbers: Vec<u32>, paymentAsset: u32, reservePrice: u128, listingId: u128, marketplaceId: Option<u32>, seller: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * An auction has sold\n       **/\n      AuctionSold: AugmentedEvent<ApiType, [collectionId: u32, listingId: u128, paymentAsset: u32, hammerPrice: u128, winner: SeedPrimitivesSignatureAccountId20], { collectionId: u32, listingId: u128, paymentAsset: u32, hammerPrice: u128, winner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Base URI was set\n       **/\n      BaseUriSet: AugmentedEvent<ApiType, [collectionId: u32, baseUri: Bytes], { collectionId: u32, baseUri: Bytes }>;\n      /**\n       * A new highest bid was placed\n       **/\n      Bid: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, amount: u128, bidder: SeedPrimitivesSignatureAccountId20], { collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, amount: u128, bidder: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Token(s) were bridged\n       **/\n      BridgedMint: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, owner: SeedPrimitivesSignatureAccountId20], { collectionId: u32, serialNumbers: Vec<u32>, owner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A token was burned\n       **/\n      Burn: AugmentedEvent<ApiType, [collectionId: u32, serialNumber: u32], { collectionId: u32, serialNumber: u32 }>;\n      /**\n       * Collection has been claimed\n       **/\n      CollectionClaimed: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20, collectionId: u32], { account: SeedPrimitivesSignatureAccountId20, collectionId: u32 }>;\n      /**\n       * A new collection of tokens was created\n       **/\n      CollectionCreate: AugmentedEvent<ApiType, [collectionUuid: u32, initialIssuance: u32, maxIssuance: Option<u32>, collectionOwner: SeedPrimitivesSignatureAccountId20, metadataScheme: Bytes, name: Bytes, royaltiesSchedule: Option<PalletNftRoyaltiesSchedule>, originChain: PalletNftOriginChain, compatibility: PalletNftCrossChainCompatibility], { collectionUuid: u32, initialIssuance: u32, maxIssuance: Option<u32>, collectionOwner: SeedPrimitivesSignatureAccountId20, metadataScheme: Bytes, name: Bytes, royaltiesSchedule: Option<PalletNftRoyaltiesSchedule>, originChain: PalletNftOriginChain, compatibility: PalletNftCrossChainCompatibility }>;\n      /**\n       * A fixed price sale has closed without selling\n       **/\n      FixedPriceSaleClose: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, reason: PalletNftFixedPriceClosureReason], { collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, reason: PalletNftFixedPriceClosureReason }>;\n      /**\n       * A fixed price sale has completed\n       **/\n      FixedPriceSaleComplete: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, price: u128, paymentAsset: u32, buyer: SeedPrimitivesSignatureAccountId20, seller: SeedPrimitivesSignatureAccountId20], { collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, price: u128, paymentAsset: u32, buyer: SeedPrimitivesSignatureAccountId20, seller: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A fixed price sale has been listed\n       **/\n      FixedPriceSaleList: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, marketplaceId: Option<u32>, price: u128, paymentAsset: u32, seller: SeedPrimitivesSignatureAccountId20], { collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, marketplaceId: Option<u32>, price: u128, paymentAsset: u32, seller: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A fixed price sale has had its price updated\n       **/\n      FixedPriceSalePriceUpdate: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, newPrice: u128], { collectionId: u32, serialNumbers: Vec<u32>, listingId: u128, newPrice: u128 }>;\n      /**\n       * An account has been registered as a marketplace\n       **/\n      MarketplaceRegister: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20, entitlement: Permill, marketplaceId: u32], { account: SeedPrimitivesSignatureAccountId20, entitlement: Permill, marketplaceId: u32 }>;\n      /**\n       * Max issuance was set\n       **/\n      MaxIssuanceSet: AugmentedEvent<ApiType, [collectionId: u32, maxIssuance: u32], { collectionId: u32, maxIssuance: u32 }>;\n      /**\n       * Token(s) were minted\n       **/\n      Mint: AugmentedEvent<ApiType, [collectionId: u32, start: u32, end: u32, owner: SeedPrimitivesSignatureAccountId20], { collectionId: u32, start: u32, end: u32, owner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * An offer has been made on an NFT\n       **/\n      Offer: AugmentedEvent<ApiType, [offerId: u64, amount: u128, assetId: u32, marketplaceId: Option<u32>, buyer: SeedPrimitivesSignatureAccountId20], { offerId: u64, amount: u128, assetId: u32, marketplaceId: Option<u32>, buyer: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * An offer has been accepted\n       **/\n      OfferAccept: AugmentedEvent<ApiType, [offerId: u64, tokenId: ITuple<[u32, u32]>, amount: u128, assetId: u32], { offerId: u64, tokenId: ITuple<[u32, u32]>, amount: u128, assetId: u32 }>;\n      /**\n       * An offer has been cancelled\n       **/\n      OfferCancel: AugmentedEvent<ApiType, [offerId: u64, tokenId: ITuple<[u32, u32]>], { offerId: u64, tokenId: ITuple<[u32, u32]> }>;\n      /**\n       * A new owner was set\n       **/\n      OwnerSet: AugmentedEvent<ApiType, [collectionId: u32, newOwner: SeedPrimitivesSignatureAccountId20], { collectionId: u32, newOwner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A token was transferred\n       **/\n      Transfer: AugmentedEvent<ApiType, [previousOwner: SeedPrimitivesSignatureAccountId20, collectionId: u32, serialNumbers: Vec<u32>, newOwner: SeedPrimitivesSignatureAccountId20], { previousOwner: SeedPrimitivesSignatureAccountId20, collectionId: u32, serialNumbers: Vec<u32>, newOwner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    nftPeg: {\n      /**\n       * The NFT-peg contract address was set\n       **/\n      ContractAddressSet: AugmentedEvent<ApiType, [contract: H160], { contract: H160 }>;\n      /**\n       * An ERC721 deposit was made\n       **/\n      Erc721Deposit: AugmentedEvent<ApiType, [destination: SeedPrimitivesSignatureAccountId20], { destination: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Bridged ERC721 tokens were minted\n       **/\n      Erc721Mint: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, owner: SeedPrimitivesSignatureAccountId20], { collectionId: u32, serialNumbers: Vec<u32>, owner: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * An ERC721 withdraw was made\n       **/\n      Erc721Withdraw: AugmentedEvent<ApiType, [origin: SeedPrimitivesSignatureAccountId20, collectionIds: Vec<u32>, serialNumbers: Vec<Vec<u32>>, destination: H160], { origin: SeedPrimitivesSignatureAccountId20, collectionIds: Vec<u32>, serialNumbers: Vec<Vec<u32>>, destination: H160 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    offences: {\n      /**\n       * There is an offence reported of the given `kind` happened at the `session_index` and\n       * (kind-specific) time slot. This event is not deposited for duplicate slashes.\n       * \\[kind, timeslot\\].\n       **/\n      Offence: AugmentedEvent<ApiType, [kind: U8aFixed, timeslot: Bytes], { kind: U8aFixed, timeslot: Bytes }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    proxy: {\n      /**\n       * An announcement was placed to make a call in the future.\n       **/\n      Announced: AugmentedEvent<ApiType, [real: SeedPrimitivesSignatureAccountId20, proxy: SeedPrimitivesSignatureAccountId20, callHash: H256], { real: SeedPrimitivesSignatureAccountId20, proxy: SeedPrimitivesSignatureAccountId20, callHash: H256 }>;\n      /**\n       * Anonymous account has been created by new proxy with given\n       * disambiguation index and proxy type.\n       **/\n      AnonymousCreated: AugmentedEvent<ApiType, [anonymous: SeedPrimitivesSignatureAccountId20, who: SeedPrimitivesSignatureAccountId20, proxyType: SeedRuntimeImplsProxyType, disambiguationIndex: u16], { anonymous: SeedPrimitivesSignatureAccountId20, who: SeedPrimitivesSignatureAccountId20, proxyType: SeedRuntimeImplsProxyType, disambiguationIndex: u16 }>;\n      /**\n       * A proxy was added.\n       **/\n      ProxyAdded: AugmentedEvent<ApiType, [delegator: SeedPrimitivesSignatureAccountId20, delegatee: SeedPrimitivesSignatureAccountId20, proxyType: SeedRuntimeImplsProxyType, delay: u32], { delegator: SeedPrimitivesSignatureAccountId20, delegatee: SeedPrimitivesSignatureAccountId20, proxyType: SeedRuntimeImplsProxyType, delay: u32 }>;\n      /**\n       * A proxy was executed correctly, with the given.\n       **/\n      ProxyExecuted: AugmentedEvent<ApiType, [result: Result<Null, SpRuntimeDispatchError>], { result: Result<Null, SpRuntimeDispatchError> }>;\n      /**\n       * A proxy was removed.\n       **/\n      ProxyRemoved: AugmentedEvent<ApiType, [delegator: SeedPrimitivesSignatureAccountId20, delegatee: SeedPrimitivesSignatureAccountId20, proxyType: SeedRuntimeImplsProxyType, delay: u32], { delegator: SeedPrimitivesSignatureAccountId20, delegatee: SeedPrimitivesSignatureAccountId20, proxyType: SeedRuntimeImplsProxyType, delay: u32 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    recovery: {\n      /**\n       * Lost account has been successfully recovered by rescuer account.\n       **/\n      AccountRecovered: AugmentedEvent<ApiType, [lostAccount: SeedPrimitivesSignatureAccountId20, rescuerAccount: SeedPrimitivesSignatureAccountId20], { lostAccount: SeedPrimitivesSignatureAccountId20, rescuerAccount: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A recovery process for lost account by rescuer account has been closed.\n       **/\n      RecoveryClosed: AugmentedEvent<ApiType, [lostAccount: SeedPrimitivesSignatureAccountId20, rescuerAccount: SeedPrimitivesSignatureAccountId20], { lostAccount: SeedPrimitivesSignatureAccountId20, rescuerAccount: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A recovery process has been set up for an account.\n       **/\n      RecoveryCreated: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20], { account: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A recovery process has been initiated for lost account by rescuer account.\n       **/\n      RecoveryInitiated: AugmentedEvent<ApiType, [lostAccount: SeedPrimitivesSignatureAccountId20, rescuerAccount: SeedPrimitivesSignatureAccountId20], { lostAccount: SeedPrimitivesSignatureAccountId20, rescuerAccount: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A recovery process has been removed for an account.\n       **/\n      RecoveryRemoved: AugmentedEvent<ApiType, [lostAccount: SeedPrimitivesSignatureAccountId20], { lostAccount: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A recovery process for lost account by rescuer account has been vouched for by sender.\n       **/\n      RecoveryVouched: AugmentedEvent<ApiType, [lostAccount: SeedPrimitivesSignatureAccountId20, rescuerAccount: SeedPrimitivesSignatureAccountId20, sender: SeedPrimitivesSignatureAccountId20], { lostAccount: SeedPrimitivesSignatureAccountId20, rescuerAccount: SeedPrimitivesSignatureAccountId20, sender: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    scheduler: {\n      /**\n       * The call for the provided hash was not found so the task has been aborted.\n       **/\n      CallLookupFailed: AugmentedEvent<ApiType, [task: ITuple<[u32, u32]>, id: Option<Bytes>, error: FrameSupportScheduleLookupError], { task: ITuple<[u32, u32]>, id: Option<Bytes>, error: FrameSupportScheduleLookupError }>;\n      /**\n       * Canceled some task.\n       **/\n      Canceled: AugmentedEvent<ApiType, [when: u32, index: u32], { when: u32, index: u32 }>;\n      /**\n       * Dispatched some task.\n       **/\n      Dispatched: AugmentedEvent<ApiType, [task: ITuple<[u32, u32]>, id: Option<Bytes>, result: Result<Null, SpRuntimeDispatchError>], { task: ITuple<[u32, u32]>, id: Option<Bytes>, result: Result<Null, SpRuntimeDispatchError> }>;\n      /**\n       * Scheduled some task.\n       **/\n      Scheduled: AugmentedEvent<ApiType, [when: u32, index: u32], { when: u32, index: u32 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    session: {\n      /**\n       * New session has happened. Note that the argument is the session index, not the\n       * block number as the type might suggest.\n       **/\n      NewSession: AugmentedEvent<ApiType, [sessionIndex: u32], { sessionIndex: u32 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    staking: {\n      /**\n       * An account has bonded this amount. \\[stash, amount\\]\n       * \n       * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,\n       * it will not be emitted for staking rewards when they are added to stake.\n       **/\n      Bonded: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * An account has stopped participating as either a validator or nominator.\n       * \\[stash\\]\n       **/\n      Chilled: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The era payout has been set; the first balance is the validator-payout; the second is\n       * the remainder from the maximum amount of reward.\n       * \\[era_index, validator_payout, remainder\\]\n       **/\n      EraPaid: AugmentedEvent<ApiType, [u32, u128, u128]>;\n      /**\n       * A nominator has been kicked from a validator. \\[nominator, stash\\]\n       **/\n      Kicked: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * An old slashing report from a prior era was discarded because it could\n       * not be processed. \\[session_index\\]\n       **/\n      OldSlashingReportDiscarded: AugmentedEvent<ApiType, [u32]>;\n      /**\n       * The stakers' rewards are getting paid. \\[era_index, validator_stash\\]\n       **/\n      PayoutStarted: AugmentedEvent<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The nominator has been rewarded by this amount. \\[stash, amount\\]\n       **/\n      Rewarded: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * One validator (and its nominators) has been slashed by the given amount.\n       * \\[validator, amount\\]\n       **/\n      Slashed: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * A new set of stakers was elected.\n       **/\n      StakersElected: AugmentedEvent<ApiType, []>;\n      /**\n       * The election failed. No new era is planned.\n       **/\n      StakingElectionFailed: AugmentedEvent<ApiType, []>;\n      /**\n       * An account has unbonded this amount. \\[stash, amount\\]\n       **/\n      Unbonded: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * A validator has set their preferences.\n       **/\n      ValidatorPrefsSet: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, PalletStakingValidatorPrefs]>;\n      /**\n       * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`\n       * from the unlocking queue. \\[stash, amount\\]\n       **/\n      Withdrawn: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    sudo: {\n      /**\n       * The \\[sudoer\\] just switched identity; the old key is supplied if one existed.\n       **/\n      KeyChanged: AugmentedEvent<ApiType, [oldSudoer: Option<SeedPrimitivesSignatureAccountId20>], { oldSudoer: Option<SeedPrimitivesSignatureAccountId20> }>;\n      /**\n       * A sudo just took place. \\[result\\]\n       **/\n      Sudid: AugmentedEvent<ApiType, [sudoResult: Result<Null, SpRuntimeDispatchError>], { sudoResult: Result<Null, SpRuntimeDispatchError> }>;\n      /**\n       * A sudo just took place. \\[result\\]\n       **/\n      SudoAsDone: AugmentedEvent<ApiType, [sudoResult: Result<Null, SpRuntimeDispatchError>], { sudoResult: Result<Null, SpRuntimeDispatchError> }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    system: {\n      /**\n       * `:code` was updated.\n       **/\n      CodeUpdated: AugmentedEvent<ApiType, []>;\n      /**\n       * An extrinsic failed.\n       **/\n      ExtrinsicFailed: AugmentedEvent<ApiType, [dispatchError: SpRuntimeDispatchError, dispatchInfo: FrameSupportWeightsDispatchInfo], { dispatchError: SpRuntimeDispatchError, dispatchInfo: FrameSupportWeightsDispatchInfo }>;\n      /**\n       * An extrinsic completed successfully.\n       **/\n      ExtrinsicSuccess: AugmentedEvent<ApiType, [dispatchInfo: FrameSupportWeightsDispatchInfo], { dispatchInfo: FrameSupportWeightsDispatchInfo }>;\n      /**\n       * An account was reaped.\n       **/\n      KilledAccount: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20], { account: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A new account was created.\n       **/\n      NewAccount: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20], { account: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * On on-chain remark happened.\n       **/\n      Remarked: AugmentedEvent<ApiType, [sender: SeedPrimitivesSignatureAccountId20, hash_: H256], { sender: SeedPrimitivesSignatureAccountId20, hash_: H256 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    transactionPayment: {\n      /**\n       * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,\n       * has been paid by `who`.\n       **/\n      TransactionFeePaid: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, actualFee: u128, tip: u128], { who: SeedPrimitivesSignatureAccountId20, actualFee: u128, tip: u128 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    utility: {\n      /**\n       * Batch of dispatches completed fully with no error.\n       **/\n      BatchCompleted: AugmentedEvent<ApiType, []>;\n      /**\n       * Batch of dispatches completed but has errors.\n       **/\n      BatchCompletedWithErrors: AugmentedEvent<ApiType, []>;\n      /**\n       * Batch of dispatches did not complete fully. Index of first failing dispatch given, as\n       * well as the error.\n       **/\n      BatchInterrupted: AugmentedEvent<ApiType, [index: u32, error: SpRuntimeDispatchError], { index: u32, error: SpRuntimeDispatchError }>;\n      /**\n       * A call was dispatched.\n       **/\n      DispatchedAs: AugmentedEvent<ApiType, [result: Result<Null, SpRuntimeDispatchError>], { result: Result<Null, SpRuntimeDispatchError> }>;\n      /**\n       * A single item within a Batch of dispatches has completed with no error.\n       **/\n      ItemCompleted: AugmentedEvent<ApiType, []>;\n      /**\n       * A single item within a Batch of dispatches has completed with error.\n       **/\n      ItemFailed: AugmentedEvent<ApiType, [error: SpRuntimeDispatchError], { error: SpRuntimeDispatchError }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    voterList: {\n      /**\n       * Moved an account from one bag to another.\n       **/\n      Rebagged: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, from: u64, to: u64], { who: SeedPrimitivesSignatureAccountId20, from: u64, to: u64 }>;\n      /**\n       * Updated the score of some account to the given amount.\n       **/\n      ScoreUpdated: AugmentedEvent<ApiType, [who: SeedPrimitivesSignatureAccountId20, newScore: u64], { who: SeedPrimitivesSignatureAccountId20, newScore: u64 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    xls20: {\n      /**\n       * A new relayer has been set\n       **/\n      RelayerSet: AugmentedEvent<ApiType, [account: SeedPrimitivesSignatureAccountId20], { account: SeedPrimitivesSignatureAccountId20 }>;\n      /**\n       * A collection has had XLS-20 compatibility enabled\n       **/\n      Xls20CompatibilityEnabled: AugmentedEvent<ApiType, [collectionId: u32], { collectionId: u32 }>;\n      /**\n       * A new XLS20 mapping has been set\n       **/\n      Xls20MappingSet: AugmentedEvent<ApiType, [collectionId: u32, mappings: Vec<ITuple<[u32, U8aFixed]>>], { collectionId: u32, mappings: Vec<ITuple<[u32, U8aFixed]>> }>;\n      /**\n       * Additional mint fee for XLS-20 mint has been paid to relayer\n       **/\n      Xls20MintFeePaid: AugmentedEvent<ApiType, [collectionOwner: SeedPrimitivesSignatureAccountId20, totalFee: u128], { collectionOwner: SeedPrimitivesSignatureAccountId20, totalFee: u128 }>;\n      /**\n       * A new Xls20 Mint Fee has been set\n       **/\n      Xls20MintFeeSet: AugmentedEvent<ApiType, [newFee: u128], { newFee: u128 }>;\n      /**\n       * Request sent to XLS20 Relayer\n       **/\n      Xls20MintRequest: AugmentedEvent<ApiType, [collectionId: u32, serialNumbers: Vec<u32>, tokenUris: Vec<Bytes>], { collectionId: u32, serialNumbers: Vec<u32>, tokenUris: Vec<Bytes> }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n    xrplBridge: {\n      DoorAddressSet: AugmentedEvent<ApiType, [H160]>;\n      DoorNextTicketSequenceParamSet: AugmentedEvent<ApiType, [ticketSequenceStartNext: u32, ticketBucketSizeNext: u32], { ticketSequenceStartNext: u32, ticketBucketSizeNext: u32 }>;\n      DoorTicketSequenceParamSet: AugmentedEvent<ApiType, [ticketSequence: u32, ticketSequenceStart: u32, ticketBucketSize: u32], { ticketSequence: u32, ticketSequenceStart: u32, ticketBucketSize: u32 }>;\n      /**\n       * Transaction not supported\n       **/\n      NotSupportedTransaction: AugmentedEvent<ApiType, []>;\n      /**\n       * Processing an event failed\n       **/\n      ProcessingFailed: AugmentedEvent<ApiType, [u64, H512, SpRuntimeDispatchError]>;\n      /**\n       * Processing an event succeeded\n       **/\n      ProcessingOk: AugmentedEvent<ApiType, [u64, H512]>;\n      RelayerAdded: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      RelayerRemoved: AugmentedEvent<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      TicketSequenceThresholdReached: AugmentedEvent<ApiType, [u32]>;\n      TransactionAdded: AugmentedEvent<ApiType, [u64, H512]>;\n      TransactionChallenge: AugmentedEvent<ApiType, [u64, H512]>;\n      /**\n       * Request to withdraw some XRP amount to XRPL\n       **/\n      WithdrawRequest: AugmentedEvent<ApiType, [proofId: u64, sender: SeedPrimitivesSignatureAccountId20, amount: u128, destination: H160], { proofId: u64, sender: SeedPrimitivesSignatureAccountId20, amount: u128, destination: H160 }>;\n      /**\n       * Generic event\n       **/\n      [key: string]: AugmentedEvent<ApiType>;\n    };\n  } // AugmentedEvents\n} // declare module\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/types.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-query.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/api-base/types/storage';\n\nimport type { ApiTypes, AugmentedQuery, QueryableStorageEntry } from '@polkadot/api-base/types';\nimport type { BTreeMap, Bytes, Option, U256, U8aFixed, Vec, WrapperOpaque, bool, u128, u32, u64, u8 } from '@polkadot/types-codec';\nimport type { AnyNumber, ITuple } from '@polkadot/types-codec/types';\nimport type { EthereumBlock, EthereumReceiptReceiptV3, EthereumTransactionTransactionV2, FpRpcTransactionStatus, FrameSupportWeightsPerDispatchClassU64, FrameSystemAccountInfo, FrameSystemEventRecord, FrameSystemLastRuntimeUpgradeInfo, FrameSystemPhase, PalletAssetsApproval, PalletAssetsAssetAccount, PalletAssetsAssetDetails, PalletAssetsAssetMetadata, PalletAuthorshipUncleEntryItem, PalletBagsListListBag, PalletBagsListListNode, PalletBalancesAccountData, PalletBalancesBalanceLock, PalletBalancesReleases, PalletBalancesReserveData, PalletDexTradingPair, PalletDexTradingPairStatus, PalletElectionProviderMultiPhasePhase, PalletElectionProviderMultiPhaseReadySolution, PalletElectionProviderMultiPhaseRoundSnapshot, PalletElectionProviderMultiPhaseSignedSignedSubmission, PalletElectionProviderMultiPhaseSolutionOrSnapshotSize, PalletErc20PegPendingPayment, PalletEthyCheckedEthCallRequest, PalletEthyCheckedEthCallResult, PalletEthyEthySigningRequest, PalletEthyEventClaim, PalletEthyEventClaimResult, PalletEthyEventClaimStatus, PalletFeeControlFeeConfig, PalletGrandpaStoredPendingChange, PalletGrandpaStoredState, PalletImOnlineBoundedOpaqueNetworkState, PalletImOnlineSr25519AppSr25519Public, PalletNftCollectionInformation, PalletNftListing, PalletNftMarketplace, PalletNftOfferType, PalletNftTokenLockReason, PalletProxyAnnouncement, PalletProxyProxyDefinition, PalletRecoveryActiveRecovery, PalletRecoveryRecoveryConfig, PalletSchedulerScheduledV3, PalletStakingActiveEraInfo, PalletStakingEraRewardPoints, PalletStakingExposure, PalletStakingForcing, PalletStakingNominations, PalletStakingReleases, PalletStakingRewardDestination, PalletStakingSlashingSlashingSpans, PalletStakingSlashingSpanRecord, PalletStakingStakingLedger, PalletStakingUnappliedSlash, PalletStakingValidatorPrefs, PalletTransactionPaymentReleases, PalletXrplBridgeHelpersXrpTransaction, PalletXrplBridgeHelpersXrplTicketSequenceParams, SeedPrimitivesEthyCryptoAppCryptoPublic, SeedPrimitivesSignatureAccountId20, SeedRuntimeSessionKeys, SpConsensusBabeAppPublic, SpConsensusBabeBabeEpochConfiguration, SpConsensusBabeDigestsNextConfigDescriptor, SpConsensusBabeDigestsPreDigest, SpCoreCryptoKeyTypeId, SpNposElectionsElectionScore, SpRuntimeDigest, SpStakingOffenceOffenceDetails } from '@polkadot/types/lookup';\nimport type { Observable } from '@polkadot/types/types';\nimport type { H160, H256, H512, Perbill, Percent } from '@therootnetwork/types/interfaces/runtime';\n\nexport type __AugmentedQuery<ApiType extends ApiTypes> = AugmentedQuery<ApiType, () => unknown>;\nexport type __QueryableStorageEntry<ApiType extends ApiTypes> = QueryableStorageEntry<ApiType>;\n\ndeclare module '@polkadot/api-base/types/storage' {\n  interface AugmentedQueries<ApiType extends ApiTypes> {\n    assets: {\n      /**\n       * The holdings of a specific account for a specific asset.\n       **/\n      account: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletAssetsAssetAccount>>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Approved balance transfers. First balance is the amount approved for transfer. Second\n       * is the amount of `T::Currency` reserved for storing this.\n       * First key is the asset ID, second key is the owner and third key is the delegate.\n       **/\n      approvals: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, arg3: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletAssetsApproval>>, [u32, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Details of an asset.\n       **/\n      asset: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<PalletAssetsAssetDetails>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Metadata of an asset.\n       **/\n      metadata: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<PalletAssetsAssetMetadata>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    assetsExt: {\n      /**\n       * The holdings of a specific account for a specific asset.\n       **/\n      holds: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Vec<ITuple<[U8aFixed, u128]>>>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The total units issued in the system.\n       **/\n      nextAssetId: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    authorship: {\n      /**\n       * Author of current block.\n       **/\n      author: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Whether uncles were already set in this block.\n       **/\n      didSetUncles: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Uncles\n       **/\n      uncles: AugmentedQuery<ApiType, () => Observable<Vec<PalletAuthorshipUncleEntryItem>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    babe: {\n      /**\n       * Current epoch authorities.\n       **/\n      authorities: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[SpConsensusBabeAppPublic, u64]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * This field should always be populated during block processing unless\n       * secondary plain slots are enabled (which don't contain a VRF output).\n       * \n       * It is set in `on_finalize`, before it will contain the value from the last block.\n       **/\n      authorVrfRandomness: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current slot number.\n       **/\n      currentSlot: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The configuration for the current epoch. Should never be `None` as it is initialized in\n       * genesis.\n       **/\n      epochConfig: AugmentedQuery<ApiType, () => Observable<Option<SpConsensusBabeBabeEpochConfiguration>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current epoch index.\n       **/\n      epochIndex: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The block numbers when the last and current epoch have started, respectively `N-1` and\n       * `N`.\n       * NOTE: We track this is in order to annotate the block number when a given pool of\n       * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in\n       * slots, which may be skipped, the block numbers may not line up with the slot numbers.\n       **/\n      epochStart: AugmentedQuery<ApiType, () => Observable<ITuple<[u32, u32]>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The slot at which the first epoch actually started. This is 0\n       * until the first block of the chain.\n       **/\n      genesisSlot: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Temporary value (cleared at block finalization) which is `Some`\n       * if per-block initialization has already been called for current block.\n       **/\n      initialized: AugmentedQuery<ApiType, () => Observable<Option<Option<SpConsensusBabeDigestsPreDigest>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * How late the current block is compared to its parent.\n       * \n       * This entry is populated as part of block execution and is cleaned up\n       * on block finalization. Querying this storage entry outside of block\n       * execution context should always yield zero.\n       **/\n      lateness: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Next epoch authorities.\n       **/\n      nextAuthorities: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[SpConsensusBabeAppPublic, u64]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The configuration for the next epoch, `None` if the config will not change\n       * (you can fallback to `EpochConfig` instead in that case).\n       **/\n      nextEpochConfig: AugmentedQuery<ApiType, () => Observable<Option<SpConsensusBabeBabeEpochConfiguration>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Next epoch randomness.\n       **/\n      nextRandomness: AugmentedQuery<ApiType, () => Observable<U8aFixed>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Pending epoch configuration change that will be applied when the next epoch is enacted.\n       **/\n      pendingEpochConfigChange: AugmentedQuery<ApiType, () => Observable<Option<SpConsensusBabeDigestsNextConfigDescriptor>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The epoch randomness for the *current* epoch.\n       * \n       * # Security\n       * \n       * This MUST NOT be used for gambling, as it can be influenced by a\n       * malicious validator in the short term. It MAY be used in many\n       * cryptographic protocols, however, so long as one remembers that this\n       * (like everything else on-chain) it is public. For example, it can be\n       * used where a number is needed that cannot have been chosen by an\n       * adversary, for purposes such as public-coin zero-knowledge proofs.\n       **/\n      randomness: AugmentedQuery<ApiType, () => Observable<U8aFixed>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Randomness under construction.\n       * \n       * We make a trade-off between storage accesses and list length.\n       * We store the under-construction randomness in segments of up to\n       * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.\n       * \n       * Once a segment reaches this length, we begin the next one.\n       * We reset all segments and return to `0` at the beginning of every\n       * epoch.\n       **/\n      segmentIndex: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.\n       **/\n      underConstruction: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<U8aFixed>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    balances: {\n      /**\n       * The Balances pallet example of storing the balance of an account.\n       * \n       * # Example\n       * \n       * ```nocompile\n       * impl pallet_balances::Config for Runtime {\n       * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>\n       * }\n       * ```\n       * \n       * You can also store the balance of an account in the `System` pallet.\n       * \n       * # Example\n       * \n       * ```nocompile\n       * impl pallet_balances::Config for Runtime {\n       * type AccountStore = System\n       * }\n       * ```\n       * \n       * But this comes with tradeoffs, storing account balances in the system pallet stores\n       * `frame_system` data alongside the account data contrary to storing account balances in the\n       * `Balances` pallet, which uses a `StorageMap` to store balances data only.\n       * NOTE: This is only used in the case that this pallet is used to store balances.\n       **/\n      account: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletBalancesAccountData>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Any liquidity locks on some account balances.\n       * NOTE: Should only be accessed when setting, changing and freeing a lock.\n       **/\n      locks: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Vec<PalletBalancesBalanceLock>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Named reserves on some account balances.\n       **/\n      reserves: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Vec<PalletBalancesReserveData>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Storage version of the pallet.\n       * \n       * This is set to v2.0.0 for new networks.\n       **/\n      storageVersion: AugmentedQuery<ApiType, () => Observable<PalletBalancesReleases>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The total units issued in the system.\n       **/\n      totalIssuance: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    dex: {\n      liquidityPool: AugmentedQuery<ApiType, (arg: PalletDexTradingPair) => Observable<ITuple<[u128, u128]>>, [PalletDexTradingPair]> & QueryableStorageEntry<ApiType, [PalletDexTradingPair]>;\n      tradingPairLPToken: AugmentedQuery<ApiType, (arg: PalletDexTradingPair) => Observable<Option<u32>>, [PalletDexTradingPair]> & QueryableStorageEntry<ApiType, [PalletDexTradingPair]>;\n      tradingPairStatuses: AugmentedQuery<ApiType, (arg: PalletDexTradingPair) => Observable<PalletDexTradingPairStatus>, [PalletDexTradingPair]> & QueryableStorageEntry<ApiType, [PalletDexTradingPair]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    echo: {\n      /**\n       * The next available offer_id\n       **/\n      nextSessionId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    electionProviderMultiPhase: {\n      /**\n       * Current phase.\n       **/\n      currentPhase: AugmentedQuery<ApiType, () => Observable<PalletElectionProviderMultiPhasePhase>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Desired number of targets to elect for this round.\n       * \n       * Only exists when [`Snapshot`] is present.\n       **/\n      desiredTargets: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum score that each 'untrusted' solution must attain in order to be considered\n       * feasible.\n       * \n       * Can be set via `set_minimum_untrusted_score`.\n       **/\n      minimumUntrustedScore: AugmentedQuery<ApiType, () => Observable<Option<SpNposElectionsElectionScore>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current best solution, signed or unsigned, queued to be returned upon `elect`.\n       **/\n      queuedSolution: AugmentedQuery<ApiType, () => Observable<Option<PalletElectionProviderMultiPhaseReadySolution>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Internal counter for the number of rounds.\n       * \n       * This is useful for de-duplication of transactions submitted to the pool, and general\n       * diagnostics of the pallet.\n       * \n       * This is merely incremented once per every time that an upstream `elect` is called.\n       **/\n      round: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * A sorted, bounded set of `(score, index)`, where each `index` points to a value in\n       * `SignedSubmissions`.\n       * \n       * We never need to process more than a single signed submission at a time. Signed submissions\n       * can be quite large, so we're willing to pay the cost of multiple database accesses to access\n       * them one at a time instead of reading and decoding all of them at once.\n       **/\n      signedSubmissionIndices: AugmentedQuery<ApiType, () => Observable<BTreeMap<SpNposElectionsElectionScore, u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next index to be assigned to an incoming signed submission.\n       * \n       * Every accepted submission is assigned a unique index; that index is bound to that particular\n       * submission for the duration of the election. On election finalization, the next index is\n       * reset to 0.\n       * \n       * We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its\n       * capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,\n       * because iteration is slow. Instead, we store the value here.\n       **/\n      signedSubmissionNextIndex: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Unchecked, signed solutions.\n       * \n       * Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while\n       * allowing us to keep only a single one in memory at a time.\n       * \n       * Twox note: the key of the map is an auto-incrementing index which users cannot inspect or\n       * affect; we shouldn't need a cryptographically secure hasher.\n       **/\n      signedSubmissionsMap: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<PalletElectionProviderMultiPhaseSignedSignedSubmission>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Snapshot data of the round.\n       * \n       * This is created at the beginning of the signed phase and cleared upon calling `elect`.\n       **/\n      snapshot: AugmentedQuery<ApiType, () => Observable<Option<PalletElectionProviderMultiPhaseRoundSnapshot>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The metadata of the [`RoundSnapshot`]\n       * \n       * Only exists when [`Snapshot`] is present.\n       **/\n      snapshotMetadata: AugmentedQuery<ApiType, () => Observable<Option<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    erc20Peg: {\n      /**\n       * Map GA asset Id to ERC20 address\n       **/\n      assetIdToErc20: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<H160>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The peg contract address on Ethereum\n       **/\n      contractAddress: AugmentedQuery<ApiType, () => Observable<H160>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from DelayedPaymentId to PendingPayment\n       **/\n      delayedPayments: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletErc20PegPendingPayment>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Map from block number to DelayedPaymentIds scheduled for that block\n       **/\n      delayedPaymentSchedule: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<u64>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Whether deposit are active\n       **/\n      depositsActive: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Metadata for well-known erc20 tokens (symbol, decimals)\n       **/\n      erc20Meta: AugmentedQuery<ApiType, (arg: H160 | string | Uint8Array) => Observable<Option<ITuple<[Bytes, u8]>>>, [H160]> & QueryableStorageEntry<ApiType, [H160]>;\n      /**\n       * Map ERC20 address to GA asset Id\n       **/\n      erc20ToAssetId: AugmentedQuery<ApiType, (arg: H160 | string | Uint8Array) => Observable<Option<u32>>, [H160]> & QueryableStorageEntry<ApiType, [H160]>;\n      /**\n       * The next available payment id for withdrawals and deposits\n       **/\n      nextDelayedPaymentId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from asset_id to minimum amount and delay\n       **/\n      paymentDelay: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<ITuple<[u128, u32]>>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The blocks with payments that are ready to be processed\n       **/\n      readyBlocks: AugmentedQuery<ApiType, () => Observable<Vec<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Whether withdrawals are active\n       **/\n      withdrawalsActive: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    ethBridge: {\n      /**\n       * Flag to indicate whether authorities have been changed during the current era\n       **/\n      authoritiesChangedThisEra: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Whether the bridge is paused (e.g. during validator transitions or by governance)\n       **/\n      bridgePaused: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The (optimistic) challenge period after which a submitted event is considered valid\n       **/\n      challengePeriod: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Maps from event claim id to challenger and bond amount paid\n       **/\n      challengerAccount: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<ITuple<[SeedPrimitivesSignatureAccountId20, u128]>>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * The bridge contract address on Ethereum\n       **/\n      contractAddress: AugmentedQuery<ApiType, () => Observable<H160>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The maximum number of delayed events that can be processed in on_initialize()\n       **/\n      delayedEventProofsPerBlock: AugmentedQuery<ApiType, () => Observable<u8>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * EthCallOracle notarizations keyed by (Id, Notary)\n       **/\n      ethCallNotarizations: AugmentedQuery<ApiType, (arg1: u64 | AnyNumber | Uint8Array, arg2: SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array) => Observable<Option<PalletEthyCheckedEthCallResult>>, [u64, SeedPrimitivesEthyCryptoAppCryptoPublic]> & QueryableStorageEntry<ApiType, [u64, SeedPrimitivesEthyCryptoAppCryptoPublic]>;\n      /**\n       * map from EthCallOracle notarizations to an aggregated count\n       **/\n      ethCallNotarizationsAggregated: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<BTreeMap<PalletEthyCheckedEthCallResult, u32>>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * EthCallOracle request info\n       **/\n      ethCallRequestInfo: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletEthyCheckedEthCallRequest>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Queue of pending EthCallOracle requests\n       **/\n      ethCallRequests: AugmentedQuery<ApiType, () => Observable<Vec<u64>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum number of block confirmations needed to notarize an Ethereum event\n       **/\n      eventBlockConfirmations: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Notarizations for queued events\n       * Either: None = no notarization exists OR Some(yay/nay)\n       **/\n      eventNotarizations: AugmentedQuery<ApiType, (arg1: u64 | AnyNumber | Uint8Array, arg2: SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array) => Observable<Option<PalletEthyEventClaimResult>>, [u64, SeedPrimitivesEthyCryptoAppCryptoPublic]> & QueryableStorageEntry<ApiType, [u64, SeedPrimitivesEthyCryptoAppCryptoPublic]>;\n      /**\n       * Map from block number to list of EventClaims that will be considered valid and should be forwarded to handlers (i.e after the optimistic challenge period has passed without issue)\n       **/\n      messagesValidAt: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<u64>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The block in which we process the next authority change\n       **/\n      nextAuthorityChange: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Subscription Id for EthCall requests\n       **/\n      nextEthCallId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Id of the next event proof\n       **/\n      nextEventProofId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Scheduled notary (validator) public keys for the next session\n       **/\n      nextNotaryKeys: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Active notary (validator) public keys\n       **/\n      notaryKeys: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current validator set id\n       **/\n      notarySetId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The event proof Id generated by the previous validator set to notarize the current set.\n       * Useful for syncing the latest proof to Ethereum\n       **/\n      notarySetProofId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Active xrpl notary (validator) public keys\n       **/\n      notaryXrplKeys: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * List of all event ids that are currently being challenged\n       **/\n      pendingClaimChallenges: AugmentedQuery<ApiType, () => Observable<Vec<u64>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Status of pending event claims\n       **/\n      pendingClaimStatus: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletEthyEventClaimStatus>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Queued event claims, can be challenged within challenge period\n       **/\n      pendingEventClaims: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletEthyEventClaim>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Queued event proofs to be processed once bridge has been re-enabled\n       **/\n      pendingEventProofs: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletEthyEthySigningRequest>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Tracks processed message Ids (prevent replay)\n       **/\n      processedMessageIds: AugmentedQuery<ApiType, () => Observable<Vec<u64>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The permissioned relayer\n       **/\n      relayer: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Maps from relayer account to their paid bond amount\n       **/\n      relayerPaidBond: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<u128>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Door Signers set by sudo (white list)\n       **/\n      xrplDoorSigners: AugmentedQuery<ApiType, (arg: SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array) => Observable<bool>, [SeedPrimitivesEthyCryptoAppCryptoPublic]> & QueryableStorageEntry<ApiType, [SeedPrimitivesEthyCryptoAppCryptoPublic]>;\n      /**\n       * The event proof Id generated by the previous validator set to notarize the current set.\n       * Useful for syncing the latest proof to Xrpl\n       **/\n      xrplNotarySetProofId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    ethereum: {\n      blockHash: AugmentedQuery<ApiType, (arg: U256 | AnyNumber | Uint8Array) => Observable<H256>, [U256]> & QueryableStorageEntry<ApiType, [U256]>;\n      /**\n       * The current Ethereum block.\n       **/\n      currentBlock: AugmentedQuery<ApiType, () => Observable<Option<EthereumBlock>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current Ethereum receipts.\n       **/\n      currentReceipts: AugmentedQuery<ApiType, () => Observable<Option<Vec<EthereumReceiptReceiptV3>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current transaction statuses.\n       **/\n      currentTransactionStatuses: AugmentedQuery<ApiType, () => Observable<Option<Vec<FpRpcTransactionStatus>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current building block's transactions and receipts.\n       **/\n      pending: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[EthereumTransactionTransactionV2, FpRpcTransactionStatus, EthereumReceiptReceiptV3]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    evm: {\n      accountCodes: AugmentedQuery<ApiType, (arg: H160 | string | Uint8Array) => Observable<Bytes>, [H160]> & QueryableStorageEntry<ApiType, [H160]>;\n      accountStorages: AugmentedQuery<ApiType, (arg1: H160 | string | Uint8Array, arg2: H256 | string | Uint8Array) => Observable<H256>, [H160, H256]> & QueryableStorageEntry<ApiType, [H160, H256]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    evmChainId: {\n      /**\n       * The EVM chain ID.\n       **/\n      chainId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    feeControl: {\n      data: AugmentedQuery<ApiType, () => Observable<PalletFeeControlFeeConfig>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    futurepass: {\n      /**\n       * Accounts which have set futurepass as default proxied on-chain account (delegate ->\n       * futurepass)\n       **/\n      defaultProxy: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Futurepass holders (account -> futurepass)\n       **/\n      holders: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Migration data for user (root) and collections they can migrate\n       **/\n      migrationAdmin: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next available incrementing futurepass id\n       **/\n      nextFuturepassId: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    grandpa: {\n      /**\n       * The number of changes (both in terms of keys and underlying economic responsibilities)\n       * in the \"set\" of Grandpa validators from genesis.\n       **/\n      currentSetId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * next block number where we can force a change.\n       **/\n      nextForced: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Pending change: (signaled at, scheduled change).\n       **/\n      pendingChange: AugmentedQuery<ApiType, () => Observable<Option<PalletGrandpaStoredPendingChange>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * A mapping from grandpa set ID to the index of the *most recent* session for which its\n       * members were responsible.\n       * \n       * TWOX-NOTE: `SetId` is not under user control.\n       **/\n      setIdSession: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<u32>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * `true` if we are currently stalled.\n       **/\n      stalled: AugmentedQuery<ApiType, () => Observable<Option<ITuple<[u32, u32]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * State of the current authority set.\n       **/\n      state: AugmentedQuery<ApiType, () => Observable<PalletGrandpaStoredState>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    imOnline: {\n      /**\n       * For each session index, we keep a mapping of `ValidatorId<T>` to the\n       * number of blocks authored by the given authority.\n       **/\n      authoredBlocks: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<u32>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The block number after which it's ok to send heartbeats in the current\n       * session.\n       * \n       * At the beginning of each session we set this to a value that should fall\n       * roughly in the middle of the session duration. The idea is to first wait for\n       * the validators to produce a block in the current session, so that the\n       * heartbeat later on will not be necessary.\n       * \n       * This value will only be used as a fallback if we fail to get a proper session\n       * progress estimate from `NextSessionRotation`, as those estimates should be\n       * more accurate then the value we calculate for `HeartbeatAfter`.\n       **/\n      heartbeatAfter: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current set of keys that may issue a heartbeat.\n       **/\n      keys: AugmentedQuery<ApiType, () => Observable<Vec<PalletImOnlineSr25519AppSr25519Public>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to\n       * `WrapperOpaque<BoundedOpaqueNetworkState>`.\n       **/\n      receivedHeartbeats: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: u32 | AnyNumber | Uint8Array) => Observable<Option<WrapperOpaque<PalletImOnlineBoundedOpaqueNetworkState>>>, [u32, u32]> & QueryableStorageEntry<ApiType, [u32, u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    nft: {\n      /**\n       * Map from collection to its information\n       **/\n      collectionInfo: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<PalletNftCollectionInformation>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Block numbers where listings will close. Value is `true` if at block number `listing_id` is\n       * scheduled to close.\n       **/\n      listingEndSchedule: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: u128 | AnyNumber | Uint8Array) => Observable<Option<bool>>, [u32, u128]> & QueryableStorageEntry<ApiType, [u32, u128]>;\n      /**\n       * NFT sale/auction listings keyed by listing id\n       **/\n      listings: AugmentedQuery<ApiType, (arg: u128 | AnyNumber | Uint8Array) => Observable<Option<PalletNftListing>>, [u128]> & QueryableStorageEntry<ApiType, [u128]>;\n      /**\n       * Winning bids on open listings.\n       **/\n      listingWinningBid: AugmentedQuery<ApiType, (arg: u128 | AnyNumber | Uint8Array) => Observable<Option<ITuple<[SeedPrimitivesSignatureAccountId20, u128]>>>, [u128]> & QueryableStorageEntry<ApiType, [u128]>;\n      /**\n       * The next available incrementing collection id\n       **/\n      nextCollectionId: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next available listing Id\n       **/\n      nextListingId: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next available marketplace id\n       **/\n      nextMarketplaceId: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next available offer_id\n       **/\n      nextOfferId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from offer_id to the information related to the offer\n       **/\n      offers: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletNftOfferType>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Map from collection to any open listings\n       **/\n      openCollectionListings: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: u128 | AnyNumber | Uint8Array) => Observable<Option<bool>>, [u32, u128]> & QueryableStorageEntry<ApiType, [u32, u128]>;\n      /**\n       * Map from marketplace account_id to royalties schedule\n       **/\n      registeredMarketplaces: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<PalletNftMarketplace>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Map from a token to lock status if any\n       **/\n      tokenLocks: AugmentedQuery<ApiType, (arg: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => Observable<Option<PalletNftTokenLockReason>>, [ITuple<[u32, u32]>]> & QueryableStorageEntry<ApiType, [ITuple<[u32, u32]>]>;\n      /**\n       * Maps from token_id to a vector of offer_ids on that token\n       **/\n      tokenOffers: AugmentedQuery<ApiType, (arg: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => Observable<Option<Vec<u64>>>, [ITuple<[u32, u32]>]> & QueryableStorageEntry<ApiType, [ITuple<[u32, u32]>]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    nftPeg: {\n      contractAddress: AugmentedQuery<ApiType, () => Observable<H160>, []> & QueryableStorageEntry<ApiType, []>;\n      ethToRootNft: AugmentedQuery<ApiType, (arg: H160 | string | Uint8Array) => Observable<Option<u32>>, [H160]> & QueryableStorageEntry<ApiType, [H160]>;\n      rootNftToErc721: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<H160>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    offences: {\n      /**\n       * A vector of reports of the same kind that happened at the same time slot.\n       **/\n      concurrentReportsIndex: AugmentedQuery<ApiType, (arg1: U8aFixed | string | Uint8Array, arg2: Bytes | string | Uint8Array) => Observable<Vec<H256>>, [U8aFixed, Bytes]> & QueryableStorageEntry<ApiType, [U8aFixed, Bytes]>;\n      /**\n       * The primary structure that holds all offence records keyed by report identifiers.\n       **/\n      reports: AugmentedQuery<ApiType, (arg: H256 | string | Uint8Array) => Observable<Option<SpStakingOffenceOffenceDetails>>, [H256]> & QueryableStorageEntry<ApiType, [H256]>;\n      /**\n       * Enumerates all reports of a kind along with the time they happened.\n       * \n       * All reports are sorted by the time of offence.\n       * \n       * Note that the actual type of this mapping is `Vec<u8>`, this is because values of\n       * different types are not supported at the moment so we are doing the manual serialization.\n       **/\n      reportsByKindIndex: AugmentedQuery<ApiType, (arg: U8aFixed | string | Uint8Array) => Observable<Bytes>, [U8aFixed]> & QueryableStorageEntry<ApiType, [U8aFixed]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    proxy: {\n      /**\n       * The announcements made by the proxy (key).\n       **/\n      announcements: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<ITuple<[Vec<PalletProxyAnnouncement>, u128]>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The set of account proxies. Maps the account which has delegated to the accounts\n       * which are being delegated to, together with the amount held on deposit.\n       **/\n      proxies: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<ITuple<[Vec<PalletProxyProxyDefinition>, u128]>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    recovery: {\n      /**\n       * Active recovery attempts.\n       * \n       * First account is the account to be recovered, and the second account\n       * is the user trying to recover the account.\n       **/\n      activeRecoveries: AugmentedQuery<ApiType, (arg1: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletRecoveryActiveRecovery>>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The list of allowed proxy accounts.\n       * \n       * Map from the user who can access it to the recovered account.\n       **/\n      proxy: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The set of recoverable accounts and their recovery configuration.\n       **/\n      recoverable: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletRecoveryRecoveryConfig>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    scheduler: {\n      /**\n       * Items to be executed, indexed by the block number that they should be executed on.\n       **/\n      agenda: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<Option<PalletSchedulerScheduledV3>>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Lookup from identity to the block number and index of the task.\n       **/\n      lookup: AugmentedQuery<ApiType, (arg: Bytes | string | Uint8Array) => Observable<Option<ITuple<[u32, u32]>>>, [Bytes]> & QueryableStorageEntry<ApiType, [Bytes]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    session: {\n      /**\n       * Current index of the session.\n       **/\n      currentIndex: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Indices of disabled validators.\n       * \n       * The vec is always kept sorted so that we can find whether a given validator is\n       * disabled using binary search. It gets cleared when `on_session_ending` returns\n       * a new set of identities.\n       **/\n      disabledValidators: AugmentedQuery<ApiType, () => Observable<Vec<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The owner of a key. The key is the `KeyTypeId` + the encoded key.\n       **/\n      keyOwner: AugmentedQuery<ApiType, (arg: ITuple<[SpCoreCryptoKeyTypeId, Bytes]> | [SpCoreCryptoKeyTypeId | string | Uint8Array, Bytes | string | Uint8Array]) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [ITuple<[SpCoreCryptoKeyTypeId, Bytes]>]> & QueryableStorageEntry<ApiType, [ITuple<[SpCoreCryptoKeyTypeId, Bytes]>]>;\n      /**\n       * The next session keys for a validator.\n       **/\n      nextKeys: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedRuntimeSessionKeys>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * True if the underlying economic identities or weighting behind the validators\n       * has changed in the queued validator set.\n       **/\n      queuedChanged: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The queued keys for the next session. When the next session begins, these keys\n       * will be used to determine the validator's session keys.\n       **/\n      queuedKeys: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[SeedPrimitivesSignatureAccountId20, SeedRuntimeSessionKeys]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current set of validators.\n       **/\n      validators: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesSignatureAccountId20>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    staking: {\n      /**\n       * The active era information, it holds index and start.\n       * \n       * The active era is the era being currently rewarded. Validator set of this era must be\n       * equal to [`SessionInterface::validators`].\n       **/\n      activeEra: AugmentedQuery<ApiType, () => Observable<Option<PalletStakingActiveEraInfo>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from all locked \"stash\" accounts to the controller account.\n       **/\n      bonded: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * A mapping from still-bonded eras to the first session index of that era.\n       * \n       * Must contains information for eras for the range:\n       * `[active_era - bounding_duration; active_era]`\n       **/\n      bondedEras: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[u32, u32]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The amount of currency given to reporters of a slash event which was\n       * canceled by extraordinary circumstances (e.g. governance).\n       **/\n      canceledSlashPayout: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The threshold for when users can start calling `chill_other` for other validators /\n       * nominators. The threshold is compared to the actual number of validators / nominators\n       * (`CountFor*`) in the system compared to the configured max (`Max*Count`).\n       **/\n      chillThreshold: AugmentedQuery<ApiType, () => Observable<Option<Percent>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Counter for the related counted storage map\n       **/\n      counterForNominators: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Counter for the related counted storage map\n       **/\n      counterForValidators: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current era index.\n       * \n       * This is the latest planned era, depending on how the Session pallet queues the validator\n       * set, it might be active or not.\n       **/\n      currentEra: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The last planned session scheduled by the session pallet.\n       * \n       * This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].\n       **/\n      currentPlannedSession: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Rewards for the last `HISTORY_DEPTH` eras.\n       * If reward hasn't been set or has been removed then 0 reward is returned.\n       **/\n      erasRewardPoints: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<PalletStakingEraRewardPoints>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Exposure of validator at era.\n       * \n       * This is keyed first by the era index to allow bulk deletion and then the stash account.\n       * \n       * Is it removed after `HISTORY_DEPTH` eras.\n       * If stakers hasn't been set or has been removed then empty exposure is returned.\n       **/\n      erasStakers: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingExposure>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Clipped Exposure of validator at era.\n       * \n       * This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the\n       * `T::MaxNominatorRewardedPerValidator` biggest stakers.\n       * (Note: the field `total` and `own` of the exposure remains unchanged).\n       * This is used to limit the i/o cost for the nominator payout.\n       * \n       * This is keyed fist by the era index to allow bulk deletion and then the stash account.\n       * \n       * Is it removed after `HISTORY_DEPTH` eras.\n       * If stakers hasn't been set or has been removed then empty exposure is returned.\n       **/\n      erasStakersClipped: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingExposure>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The session index at which the era start for the last `HISTORY_DEPTH` eras.\n       * \n       * Note: This tracks the starting session (i.e. session index when era start being active)\n       * for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.\n       **/\n      erasStartSessionIndex: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<u32>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The total amount staked for the last `HISTORY_DEPTH` eras.\n       * If total hasn't been set or has been removed then 0 stake is returned.\n       **/\n      erasTotalStake: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<u128>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Similar to `ErasStakers`, this holds the preferences of validators.\n       * \n       * This is keyed first by the era index to allow bulk deletion and then the stash account.\n       * \n       * Is it removed after `HISTORY_DEPTH` eras.\n       **/\n      erasValidatorPrefs: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingValidatorPrefs>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The total validator era payout for the last `HISTORY_DEPTH` eras.\n       * \n       * Eras that haven't finished yet or has been removed doesn't have reward.\n       **/\n      erasValidatorReward: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<u128>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Mode of era forcing.\n       **/\n      forceEra: AugmentedQuery<ApiType, () => Observable<PalletStakingForcing>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Number of eras to keep in history.\n       * \n       * Information is kept for eras in `[current_era - history_depth; current_era]`.\n       * \n       * Must be more than the number of eras delayed by session otherwise. I.e. active era must\n       * always be in history. I.e. `active_era > current_era - history_depth` must be\n       * guaranteed.\n       **/\n      historyDepth: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Any validators that may never be slashed or forcibly kicked. It's a Vec since they're\n       * easy to initialize and the performance hit is minimal (we expect no more than four\n       * invulnerables) and restricted to testnets.\n       **/\n      invulnerables: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesSignatureAccountId20>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from all (unlocked) \"controller\" accounts to the info regarding the staking.\n       **/\n      ledger: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletStakingStakingLedger>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The maximum nominator count before we stop allowing new validators to join.\n       * \n       * When this value is not set, no limits are enforced.\n       **/\n      maxNominatorsCount: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The maximum validator count before we stop allowing new validators to join.\n       * \n       * When this value is not set, no limits are enforced.\n       **/\n      maxValidatorsCount: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum amount of commission that validators can set.\n       * \n       * If set to `0`, no limit exists.\n       **/\n      minCommission: AugmentedQuery<ApiType, () => Observable<Perbill>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Minimum number of staking participants before emergency conditions are imposed.\n       **/\n      minimumValidatorCount: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum active bond to become and maintain the role of a nominator.\n       **/\n      minNominatorBond: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum active bond to become and maintain the role of a validator.\n       **/\n      minValidatorBond: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The map from nominator stash key to their nomination preferences, namely the validators that\n       * they wish to support.\n       * \n       * Note that the keys of this storage map might become non-decodable in case the\n       * [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators\n       * are still existent in storage, their key is correct and retrievable (i.e. `contains_key`\n       * indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable\n       * nominators will effectively not-exist, until they re-submit their preferences such that it\n       * is within the bounds of the newly set `Config::MaxNominations`.\n       * \n       * This implies that `::iter_keys().count()` and `::iter().count()` might return different\n       * values for this map. Moreover, the main `::count()` is aligned with the former, namely the\n       * number of keys that exist.\n       * \n       * Lastly, if any of the nominators become non-decodable, they can be chilled immediately via\n       * [`Call::chill_other`] dispatchable by anyone.\n       **/\n      nominators: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletStakingNominations>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * All slashing events on nominators, mapped by era to the highest slash value of the era.\n       **/\n      nominatorSlashInEra: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<u128>>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Indices of validators that have offended in the active era and whether they are currently\n       * disabled.\n       * \n       * This value should be a superset of disabled validators since not all offences lead to the\n       * validator being disabled (if there was no slash). This is needed to track the percentage of\n       * validators that have offended in the current era, ensuring a new era is forced if\n       * `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find\n       * whether a given validator has previously offended using binary search. It gets cleared when\n       * the era ends.\n       **/\n      offendingValidators: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[u32, bool]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Where the reward payment should be made. Keyed by stash.\n       **/\n      payee: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingRewardDestination>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Slashing spans for stash accounts.\n       **/\n      slashingSpans: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletStakingSlashingSlashingSpans>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The percentage of the slash that is distributed to reporters.\n       * \n       * The rest of the slashed value is handled by the `Slash`.\n       **/\n      slashRewardFraction: AugmentedQuery<ApiType, () => Observable<Perbill>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Records information about the maximum slash of a stash within a slashing span,\n       * as well as how much reward has been paid out.\n       **/\n      spanSlash: AugmentedQuery<ApiType, (arg: ITuple<[SeedPrimitivesSignatureAccountId20, u32]> | [SeedPrimitivesSignatureAccountId20 | string | Uint8Array, u32 | AnyNumber | Uint8Array]) => Observable<PalletStakingSlashingSpanRecord>, [ITuple<[SeedPrimitivesSignatureAccountId20, u32]>]> & QueryableStorageEntry<ApiType, [ITuple<[SeedPrimitivesSignatureAccountId20, u32]>]>;\n      /**\n       * True if network has been upgraded to this version.\n       * Storage version of the pallet.\n       * \n       * This is set to v7.0.0 for new networks.\n       **/\n      storageVersion: AugmentedQuery<ApiType, () => Observable<PalletStakingReleases>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * All unapplied slashes that are queued for later.\n       **/\n      unappliedSlashes: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<PalletStakingUnappliedSlash>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The ideal number of staking participants.\n       **/\n      validatorCount: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The map from (wannabe) validator stash key to the preferences of that validator.\n       **/\n      validators: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingValidatorPrefs>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * All slashing events on validators, mapped by era to the highest slash proportion\n       * and slash value of the era.\n       **/\n      validatorSlashInEra: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<ITuple<[Perbill, u128]>>>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    sudo: {\n      /**\n       * The `AccountId` of the sudo key.\n       **/\n      key: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    system: {\n      /**\n       * The full account information for a particular account ID.\n       **/\n      account: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<FrameSystemAccountInfo>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Total length (in bytes) for all extrinsics put together, for the current block.\n       **/\n      allExtrinsicsLen: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map of block numbers to block hashes.\n       **/\n      blockHash: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<H256>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The current weight for the block.\n       **/\n      blockWeight: AugmentedQuery<ApiType, () => Observable<FrameSupportWeightsPerDispatchClassU64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Digest of the current block, also part of the block header.\n       **/\n      digest: AugmentedQuery<ApiType, () => Observable<SpRuntimeDigest>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The number of events in the `Events<T>` list.\n       **/\n      eventCount: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Events deposited for the current block.\n       * \n       * NOTE: The item is unbound and should therefore never be read on chain.\n       * It could otherwise inflate the PoV size of a block.\n       * \n       * Events have a large in-memory size. Box the events to not go out-of-memory\n       * just in case someone still reads them from within the runtime.\n       **/\n      events: AugmentedQuery<ApiType, () => Observable<Vec<FrameSystemEventRecord>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Mapping between a topic (represented by T::Hash) and a vector of indexes\n       * of events in the `<Events<T>>` list.\n       * \n       * All topic vectors have deterministic storage locations depending on the topic. This\n       * allows light-clients to leverage the changes trie storage tracking mechanism and\n       * in case of changes fetch the list of events of interest.\n       * \n       * The value has the type `(T::BlockNumber, EventIndex)` because if we used only just\n       * the `EventIndex` then in case if the topic has the same contents on the next block\n       * no notification will be triggered thus the event might be lost.\n       **/\n      eventTopics: AugmentedQuery<ApiType, (arg: H256 | string | Uint8Array) => Observable<Vec<ITuple<[u32, u32]>>>, [H256]> & QueryableStorageEntry<ApiType, [H256]>;\n      /**\n       * The execution phase of the block.\n       **/\n      executionPhase: AugmentedQuery<ApiType, () => Observable<Option<FrameSystemPhase>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Total extrinsics count for the current block.\n       **/\n      extrinsicCount: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Extrinsics data for the current block (maps an extrinsic's index to its data).\n       **/\n      extrinsicData: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Bytes>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.\n       **/\n      lastRuntimeUpgrade: AugmentedQuery<ApiType, () => Observable<Option<FrameSystemLastRuntimeUpgradeInfo>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current block number being processed. Set by `execute_block`.\n       **/\n      number: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Hash of the previous block.\n       **/\n      parentHash: AugmentedQuery<ApiType, () => Observable<H256>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False\n       * (default) if not.\n       **/\n      upgradedToTripleRefCount: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.\n       **/\n      upgradedToU32RefCount: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    timestamp: {\n      /**\n       * Did the timestamp get updated in this block?\n       **/\n      didUpdate: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current time for the current block.\n       **/\n      now: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    tokenApprovals: {\n      erc20Approvals: AugmentedQuery<ApiType, (arg1: ITuple<[SeedPrimitivesSignatureAccountId20, u32]> | [SeedPrimitivesSignatureAccountId20 | string | Uint8Array, u32 | AnyNumber | Uint8Array], arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<u128>>, [ITuple<[SeedPrimitivesSignatureAccountId20, u32]>, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [ITuple<[SeedPrimitivesSignatureAccountId20, u32]>, SeedPrimitivesSignatureAccountId20]>;\n      erc721Approvals: AugmentedQuery<ApiType, (arg: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [ITuple<[u32, u32]>]> & QueryableStorageEntry<ApiType, [ITuple<[u32, u32]>]>;\n      erc721ApprovalsForAll: AugmentedQuery<ApiType, (arg1: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, arg2: ITuple<[u32, SeedPrimitivesSignatureAccountId20]> | [u32 | AnyNumber | Uint8Array, SeedPrimitivesSignatureAccountId20 | string | Uint8Array]) => Observable<Option<bool>>, [SeedPrimitivesSignatureAccountId20, ITuple<[u32, SeedPrimitivesSignatureAccountId20]>]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20, ITuple<[u32, SeedPrimitivesSignatureAccountId20]>]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    transactionPayment: {\n      nextFeeMultiplier: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      storageVersion: AugmentedQuery<ApiType, () => Observable<PalletTransactionPaymentReleases>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    txFeePot: {\n      /**\n       * Accrued transaction fees in the current staking Era\n       **/\n      eraTxFees: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    voterList: {\n      /**\n       * Counter for the related counted storage map\n       **/\n      counterForListNodes: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * A bag stored in storage.\n       * \n       * Stores a `Bag` struct, which stores head and tail pointers to itself.\n       **/\n      listBags: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletBagsListListBag>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * A single node, within some bag.\n       * \n       * Nodes store links forward and back within their respective bags.\n       **/\n      listNodes: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletBagsListListNode>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    xls20: {\n      /**\n       * The permissioned relayer\n       **/\n      relayer: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The extra cost of minting an XLS-20 compatible NFT\n       **/\n      xls20MintFee: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Maps from TRN native token_id to XLS-20 TokenId\n       **/\n      xls20TokenMap: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: u32 | AnyNumber | Uint8Array) => Observable<Option<U8aFixed>>, [u32, u32]> & QueryableStorageEntry<ApiType, [u32, u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    xrplBridge: {\n      /**\n       * Challenge received for a transaction mapped by hash, will be cleared when validator\n       * validates\n       **/\n      challengeXRPTransactionList: AugmentedQuery<ApiType, (arg: H512 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [H512]> & QueryableStorageEntry<ApiType, [H512]>;\n      /**\n       * The door address on XRPL\n       **/\n      doorAddress: AugmentedQuery<ApiType, () => Observable<Option<H160>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current ticket sequence of the XRPL door account\n       **/\n      doorTicketSequence: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The Ticket sequence params of the XRPL door account for the current allocation\n       **/\n      doorTicketSequenceParams: AugmentedQuery<ApiType, () => Observable<PalletXrplBridgeHelpersXrplTicketSequenceParams>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The Ticket sequence params of the XRPL door account for the next allocation\n       **/\n      doorTicketSequenceParamsNext: AugmentedQuery<ApiType, () => Observable<PalletXrplBridgeHelpersXrplTicketSequenceParams>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The flat fee for XRPL door txs\n       **/\n      doorTxFee: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Temporary storage to set the transactions ready to be processed at specified block number\n       **/\n      processXRPTransaction: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<Vec<H512>>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Stores submitted transactions from XRPL waiting to be processed\n       * Transactions will be cleared `ClearTxPeriod` blocks after processing\n       **/\n      processXRPTransactionDetails: AugmentedQuery<ApiType, (arg: H512 | string | Uint8Array) => Observable<Option<ITuple<[u64, PalletXrplBridgeHelpersXrpTransaction, SeedPrimitivesSignatureAccountId20]>>>, [H512]> & QueryableStorageEntry<ApiType, [H512]>;\n      /**\n       * List of all XRP transaction relayers\n       **/\n      relayer: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<bool>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Settled xrp transactions stored as history for a specific period\n       **/\n      settledXRPTransactionDetails: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<Vec<H512>>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Keeps track whether the TicketSequenceThresholdReached event is emitted\n       **/\n      ticketSequenceThresholdReachedEmitted: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n  } // AugmentedQueries\n} // declare module\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/types.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-tx.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/api-base/types/submittable';\n\nimport type { ApiTypes, AugmentedSubmittable, SubmittableExtrinsic, SubmittableExtrinsicFunction } from '@polkadot/api-base/types';\nimport type { Bytes, Compact, Option, U256, U8aFixed, Vec, bool, u128, u16, u32, u64, u8 } from '@polkadot/types-codec';\nimport type { AnyNumber, IMethod, ITuple } from '@polkadot/types-codec/types';\nimport type { EthereumTransactionTransactionV2, FrameSupportScheduleMaybeHashed, PalletAssetsDestroyWitness, PalletElectionProviderMultiPhaseRawSolution, PalletElectionProviderMultiPhaseSolutionOrSnapshotSize, PalletEthyNotarizationPayload, PalletImOnlineHeartbeat, PalletImOnlineSr25519AppSr25519Signature, PalletNftCrossChainCompatibility, PalletNftRoyaltiesSchedule, PalletStakingPalletConfigOpPerbill, PalletStakingPalletConfigOpPercent, PalletStakingPalletConfigOpU128, PalletStakingPalletConfigOpU32, PalletStakingRewardDestination, PalletStakingValidatorPrefs, PalletXrplBridgeHelpersXrplTxData, SeedPrimitivesEthyCryptoAppCryptoPublic, SeedPrimitivesEthyCryptoAppCryptoSignature, SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, SeedRuntimeOriginCaller, SeedRuntimeSessionKeys, SpConsensusBabeDigestsNextConfigDescriptor, SpConsensusSlotsEquivocationProof, SpCoreVoid, SpFinalityGrandpaEquivocationProof, SpNposElectionsElectionScore, SpNposElectionsSupport, SpRuntimeHeader, SpSessionMembershipProof } from '@polkadot/types/lookup';\nimport type { Call, H160, H256, H512, Perbill, Percent, Permill } from '@therootnetwork/types/interfaces/runtime';\n\nexport type __AugmentedSubmittable = AugmentedSubmittable<() => unknown>;\nexport type __SubmittableExtrinsic<ApiType extends ApiTypes> = SubmittableExtrinsic<ApiType>;\nexport type __SubmittableExtrinsicFunction<ApiType extends ApiTypes> = SubmittableExtrinsicFunction<ApiType>;\n\ndeclare module '@polkadot/api-base/types/submittable' {\n  interface AugmentedSubmittables<ApiType extends ApiTypes> {\n    assets: {\n      /**\n       * Approve an amount of asset for transfer by a delegated third-party account.\n       * \n       * Origin must be Signed.\n       * \n       * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account\n       * for the purpose of holding the approval. If some non-zero amount of assets is already\n       * approved from signing account to `delegate`, then it is topped up or unreserved to\n       * meet the right value.\n       * \n       * NOTE: The signing account does not need to own `amount` of assets at the point of\n       * making this call.\n       * \n       * - `id`: The identifier of the asset.\n       * - `delegate`: The account to delegate permission to transfer asset.\n       * - `amount`: The amount of asset that may be transferred by `delegate`. If there is\n       * already an approval in place, then this acts additively.\n       * \n       * Emits `ApprovedTransfer` on success.\n       * \n       * Weight: `O(1)`\n       **/\n      approveTransfer: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.\n       * \n       * Origin must be Signed and the sender should be the Manager of the asset `id`.\n       * \n       * Bails with `NoAccount` if the `who` is already dead.\n       * \n       * - `id`: The identifier of the asset to have some amount burned.\n       * - `who`: The account to be debited from.\n       * - `amount`: The maximum amount by which `who`'s balance should be reduced.\n       * \n       * Emits `Burned` with the actual amount burned. If this takes the balance to below the\n       * minimum for the asset, then the amount burned is increased to take it to zero.\n       * \n       * Weight: `O(1)`\n       * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.\n       **/\n      burn: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Cancel all of some asset approved for delegated transfer by a third-party account.\n       * \n       * Origin must be Signed and there must be an approval in place between signer and\n       * `delegate`.\n       * \n       * Unreserves any deposit previously reserved by `approve_transfer` for the approval.\n       * \n       * - `id`: The identifier of the asset.\n       * - `delegate`: The account delegated permission to transfer asset.\n       * \n       * Emits `ApprovalCancelled` on success.\n       * \n       * Weight: `O(1)`\n       **/\n      cancelApproval: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Clear the metadata for an asset.\n       * \n       * Origin must be Signed and the sender should be the Owner of the asset `id`.\n       * \n       * Any deposit is freed for the asset owner.\n       * \n       * - `id`: The identifier of the asset to clear.\n       * \n       * Emits `MetadataCleared`.\n       * \n       * Weight: `O(1)`\n       **/\n      clearMetadata: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Issue a new class of fungible assets from a public origin.\n       * \n       * This new asset class has no assets initially and its owner is the origin.\n       * \n       * The origin must be Signed and the sender must have sufficient funds free.\n       * \n       * Funds of sender are reserved by `AssetDeposit`.\n       * \n       * Parameters:\n       * - `id`: The identifier of the new asset. This must not be currently in use to identify\n       * an existing asset.\n       * - `admin`: The admin of this class of assets. The admin is the initial address of each\n       * member of the asset class's admin team.\n       * - `min_balance`: The minimum balance of this new asset that any single account must\n       * have. If an account's balance is reduced below this, then it collapses to zero.\n       * \n       * Emits `Created` event when successful.\n       * \n       * Weight: `O(1)`\n       **/\n      create: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, admin: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, minBalance: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * Destroy a class of fungible assets.\n       * \n       * The origin must conform to `ForceOrigin` or must be Signed and the sender must be the\n       * owner of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be destroyed. This must identify an existing\n       * asset.\n       * \n       * Emits `Destroyed` event when successful.\n       * \n       * NOTE: It can be helpful to first freeze an asset before destroying it so that you\n       * can provide accurate witness information and prevent users from manipulating state\n       * in a way that can make it harder to destroy.\n       * \n       * Weight: `O(c + p + a)` where:\n       * - `c = (witness.accounts - witness.sufficients)`\n       * - `s = witness.sufficients`\n       * - `a = witness.approvals`\n       **/\n      destroy: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, witness: PalletAssetsDestroyWitness | { accounts?: any; sufficients?: any; approvals?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, PalletAssetsDestroyWitness]>;\n      /**\n       * Alter the attributes of a given asset.\n       * \n       * Origin must be `ForceOrigin`.\n       * \n       * - `id`: The identifier of the asset.\n       * - `owner`: The new Owner of this asset.\n       * - `issuer`: The new Issuer of this asset.\n       * - `admin`: The new Admin of this asset.\n       * - `freezer`: The new Freezer of this asset.\n       * - `min_balance`: The minimum balance of this new asset that any single account must\n       * have. If an account's balance is reduced below this, then it collapses to zero.\n       * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient\n       * value to account for the state bloat associated with its balance storage. If set to\n       * `true`, then non-zero balances may be stored without a `consumer` reference (and thus\n       * an ED in the Balances pallet or whatever else is used to control user-account state\n       * growth).\n       * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin\n       * instructions.\n       * \n       * Emits `AssetStatusChanged` with the identity of the asset.\n       * \n       * Weight: `O(1)`\n       **/\n      forceAssetStatus: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, issuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, admin: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, freezer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, minBalance: Compact<u128> | AnyNumber | Uint8Array, isSufficient: bool | boolean | Uint8Array, isFrozen: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Compact<u128>, bool, bool]>;\n      /**\n       * Cancel all of some asset approved for delegated transfer by a third-party account.\n       * \n       * Origin must be either ForceOrigin or Signed origin with the signer being the Admin\n       * account of the asset `id`.\n       * \n       * Unreserves any deposit previously reserved by `approve_transfer` for the approval.\n       * \n       * - `id`: The identifier of the asset.\n       * - `delegate`: The account delegated permission to transfer asset.\n       * \n       * Emits `ApprovalCancelled` on success.\n       * \n       * Weight: `O(1)`\n       **/\n      forceCancelApproval: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Clear the metadata for an asset.\n       * \n       * Origin must be ForceOrigin.\n       * \n       * Any deposit is returned.\n       * \n       * - `id`: The identifier of the asset to clear.\n       * \n       * Emits `MetadataCleared`.\n       * \n       * Weight: `O(1)`\n       **/\n      forceClearMetadata: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Issue a new class of fungible assets from a privileged origin.\n       * \n       * This new asset class has no assets initially.\n       * \n       * The origin must conform to `ForceOrigin`.\n       * \n       * Unlike `create`, no funds are reserved.\n       * \n       * - `id`: The identifier of the new asset. This must not be currently in use to identify\n       * an existing asset.\n       * - `owner`: The owner of this class of assets. The owner has full superuser permissions\n       * over this asset, but may later change and configure the permissions using\n       * `transfer_ownership` and `set_team`.\n       * - `min_balance`: The minimum balance of this new asset that any single account must\n       * have. If an account's balance is reduced below this, then it collapses to zero.\n       * \n       * Emits `ForceCreated` event when successful.\n       * \n       * Weight: `O(1)`\n       **/\n      forceCreate: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, isSufficient: bool | boolean | Uint8Array, minBalance: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, bool, Compact<u128>]>;\n      /**\n       * Force the metadata for an asset to some value.\n       * \n       * Origin must be ForceOrigin.\n       * \n       * Any deposit is left alone.\n       * \n       * - `id`: The identifier of the asset to update.\n       * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.\n       * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.\n       * - `decimals`: The number of decimals this asset uses to represent one unit.\n       * \n       * Emits `MetadataSet`.\n       * \n       * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.\n       **/\n      forceSetMetadata: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, name: Bytes | string | Uint8Array, symbol: Bytes | string | Uint8Array, decimals: u8 | AnyNumber | Uint8Array, isFrozen: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, Bytes, Bytes, u8, bool]>;\n      /**\n       * Move some assets from one account to another.\n       * \n       * Origin must be Signed and the sender should be the Admin of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to have some amount transferred.\n       * - `source`: The account to be debited.\n       * - `dest`: The account to be credited.\n       * - `amount`: The amount by which the `source`'s balance of assets should be reduced and\n       * `dest`'s balance increased. The amount actually transferred may be slightly greater in\n       * the case that the transfer would otherwise take the `source` balance above zero but\n       * below the minimum balance. Must be greater than zero.\n       * \n       * Emits `Transferred` with the actual amount transferred. If this takes the source balance\n       * to below the minimum for the asset, then the amount transferred is increased to take it\n       * to zero.\n       * \n       * Weight: `O(1)`\n       * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of\n       * `dest`.\n       **/\n      forceTransfer: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, source: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Disallow further unprivileged transfers from an account.\n       * \n       * Origin must be Signed and the sender should be the Freezer of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be frozen.\n       * - `who`: The account to be frozen.\n       * \n       * Emits `Frozen`.\n       * \n       * Weight: `O(1)`\n       **/\n      freeze: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Disallow further unprivileged transfers for the asset class.\n       * \n       * Origin must be Signed and the sender should be the Freezer of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be frozen.\n       * \n       * Emits `Frozen`.\n       * \n       * Weight: `O(1)`\n       **/\n      freezeAsset: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Mint assets of a particular class.\n       * \n       * The origin must be Signed and the sender must be the Issuer of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to have some amount minted.\n       * - `beneficiary`: The account to be credited with the minted assets.\n       * - `amount`: The amount of the asset to be minted.\n       * \n       * Emits `Issued` event when successful.\n       * \n       * Weight: `O(1)`\n       * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.\n       **/\n      mint: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, beneficiary: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Return the deposit (if any) of an asset account.\n       * \n       * The origin must be Signed.\n       * \n       * - `id`: The identifier of the asset for the account to be created.\n       * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.\n       * \n       * Emits `Refunded` event when successful.\n       **/\n      refund: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, allowBurn: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, bool]>;\n      /**\n       * Set the metadata for an asset.\n       * \n       * Origin must be Signed and the sender should be the Owner of the asset `id`.\n       * \n       * Funds of sender are reserved according to the formula:\n       * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into\n       * account any already reserved funds.\n       * \n       * - `id`: The identifier of the asset to update.\n       * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.\n       * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.\n       * - `decimals`: The number of decimals this asset uses to represent one unit.\n       * \n       * Emits `MetadataSet`.\n       * \n       * Weight: `O(1)`\n       **/\n      setMetadata: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, name: Bytes | string | Uint8Array, symbol: Bytes | string | Uint8Array, decimals: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, Bytes, Bytes, u8]>;\n      /**\n       * Change the Issuer, Admin and Freezer of an asset.\n       * \n       * Origin must be Signed and the sender should be the Owner of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be frozen.\n       * - `issuer`: The new Issuer of this asset.\n       * - `admin`: The new Admin of this asset.\n       * - `freezer`: The new Freezer of this asset.\n       * \n       * Emits `TeamChanged`.\n       * \n       * Weight: `O(1)`\n       **/\n      setTeam: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, issuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, admin: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, freezer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Allow unprivileged transfers from an account again.\n       * \n       * Origin must be Signed and the sender should be the Admin of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be frozen.\n       * - `who`: The account to be unfrozen.\n       * \n       * Emits `Thawed`.\n       * \n       * Weight: `O(1)`\n       **/\n      thaw: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Allow unprivileged transfers for the asset again.\n       * \n       * Origin must be Signed and the sender should be the Admin of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be thawed.\n       * \n       * Emits `Thawed`.\n       * \n       * Weight: `O(1)`\n       **/\n      thawAsset: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Create an asset account for non-provider assets.\n       * \n       * A deposit will be taken from the signer account.\n       * \n       * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit\n       * to be taken.\n       * - `id`: The identifier of the asset for the account to be created.\n       * \n       * Emits `Touched` event when successful.\n       **/\n      touch: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Move some assets from the sender account to another.\n       * \n       * Origin must be Signed.\n       * \n       * - `id`: The identifier of the asset to have some amount transferred.\n       * - `target`: The account to be credited.\n       * - `amount`: The amount by which the sender's balance of assets should be reduced and\n       * `target`'s balance increased. The amount actually transferred may be slightly greater in\n       * the case that the transfer would otherwise take the sender balance above zero but below\n       * the minimum balance. Must be greater than zero.\n       * \n       * Emits `Transferred` with the actual amount transferred. If this takes the source balance\n       * to below the minimum for the asset, then the amount transferred is increased to take it\n       * to zero.\n       * \n       * Weight: `O(1)`\n       * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of\n       * `target`.\n       **/\n      transfer: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, target: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Transfer some asset balance from a previously delegated account to some third-party\n       * account.\n       * \n       * Origin must be Signed and there must be an approval in place by the `owner` to the\n       * signer.\n       * \n       * If the entire amount approved for transfer is transferred, then any deposit previously\n       * reserved by `approve_transfer` is unreserved.\n       * \n       * - `id`: The identifier of the asset.\n       * - `owner`: The account which previously approved for a transfer of at least `amount` and\n       * from which the asset balance will be withdrawn.\n       * - `destination`: The account to which the asset balance of `amount` will be transferred.\n       * - `amount`: The amount of assets to transfer.\n       * \n       * Emits `TransferredApproved` on success.\n       * \n       * Weight: `O(1)`\n       **/\n      transferApproved: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, destination: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Move some assets from the sender account to another, keeping the sender account alive.\n       * \n       * Origin must be Signed.\n       * \n       * - `id`: The identifier of the asset to have some amount transferred.\n       * - `target`: The account to be credited.\n       * - `amount`: The amount by which the sender's balance of assets should be reduced and\n       * `target`'s balance increased. The amount actually transferred may be slightly greater in\n       * the case that the transfer would otherwise take the sender balance above zero but below\n       * the minimum balance. Must be greater than zero.\n       * \n       * Emits `Transferred` with the actual amount transferred. If this takes the source balance\n       * to below the minimum for the asset, then the amount transferred is increased to take it\n       * to zero.\n       * \n       * Weight: `O(1)`\n       * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of\n       * `target`.\n       **/\n      transferKeepAlive: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, target: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Change the Owner of an asset.\n       * \n       * Origin must be Signed and the sender should be the Owner of the asset `id`.\n       * \n       * - `id`: The identifier of the asset.\n       * - `owner`: The new Owner of this asset.\n       * \n       * Emits `OwnerChanged`.\n       * \n       * Weight: `O(1)`\n       **/\n      transferOwnership: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    assetsExt: {\n      /**\n       * Creates a new asset with unique ID according to the network asset id scheme.\n       **/\n      createAsset: AugmentedSubmittable<(name: Bytes | string | Uint8Array, symbol: Bytes | string | Uint8Array, decimals: u8 | AnyNumber | Uint8Array, minBalance: Option<u128> | null | Uint8Array | u128 | AnyNumber, owner: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string) => SubmittableExtrinsic<ApiType>, [Bytes, Bytes, u8, Option<u128>, Option<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    authorship: {\n      /**\n       * Provide a set of uncles.\n       **/\n      setUncles: AugmentedSubmittable<(newUncles: Vec<SpRuntimeHeader> | (SpRuntimeHeader | { parentHash?: any; number?: any; stateRoot?: any; extrinsicsRoot?: any; digest?: any } | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SpRuntimeHeader>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    babe: {\n      /**\n       * Plan an epoch config change. The epoch config change is recorded and will be enacted on\n       * the next call to `enact_epoch_change`. The config will be activated one epoch after.\n       * Multiple calls to this method will replace any existing planned config change that had\n       * not been enacted yet.\n       **/\n      planConfigChange: AugmentedSubmittable<(config: SpConsensusBabeDigestsNextConfigDescriptor | { V1: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SpConsensusBabeDigestsNextConfigDescriptor]>;\n      /**\n       * Report authority equivocation/misbehavior. This method will verify\n       * the equivocation proof and validate the given key ownership proof\n       * against the extracted offender. If both are valid, the offence will\n       * be reported.\n       **/\n      reportEquivocation: AugmentedSubmittable<(equivocationProof: SpConsensusSlotsEquivocationProof | { offender?: any; slot?: any; firstHeader?: any; secondHeader?: any } | string | Uint8Array, keyOwnerProof: SpSessionMembershipProof | { session?: any; trieNodes?: any; validatorCount?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SpConsensusSlotsEquivocationProof, SpSessionMembershipProof]>;\n      /**\n       * Report authority equivocation/misbehavior. This method will verify\n       * the equivocation proof and validate the given key ownership proof\n       * against the extracted offender. If both are valid, the offence will\n       * be reported.\n       * This extrinsic must be called unsigned and it is expected that only\n       * block authors will call it (validated in `ValidateUnsigned`), as such\n       * if the block author is defined it will be defined as the equivocation\n       * reporter.\n       **/\n      reportEquivocationUnsigned: AugmentedSubmittable<(equivocationProof: SpConsensusSlotsEquivocationProof | { offender?: any; slot?: any; firstHeader?: any; secondHeader?: any } | string | Uint8Array, keyOwnerProof: SpSessionMembershipProof | { session?: any; trieNodes?: any; validatorCount?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SpConsensusSlotsEquivocationProof, SpSessionMembershipProof]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    balances: {\n      /**\n       * Exactly as `transfer`, except the origin must be root and the source account may be\n       * specified.\n       * # <weight>\n       * - Same as transfer, but additional read and write because the source account is not\n       * assumed to be in the overlay.\n       * # </weight>\n       **/\n      forceTransfer: AugmentedSubmittable<(source: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Unreserve some balance from a user by force.\n       * \n       * Can only be called by ROOT.\n       **/\n      forceUnreserve: AugmentedSubmittable<(who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * Set the balances of a given account.\n       * \n       * This will alter `FreeBalance` and `ReservedBalance` in storage. it will\n       * also alter the total issuance of the system (`TotalIssuance`) appropriately.\n       * If the new free or reserved balance is below the existential deposit,\n       * it will reset the account nonce (`frame_system::AccountNonce`).\n       * \n       * The dispatch origin for this call is `root`.\n       **/\n      setBalance: AugmentedSubmittable<(who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, newFree: Compact<u128> | AnyNumber | Uint8Array, newReserved: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Compact<u128>, Compact<u128>]>;\n      /**\n       * Transfer some liquid free balance to another account.\n       * \n       * `transfer` will set the `FreeBalance` of the sender and receiver.\n       * If the sender's account is below the existential deposit as a result\n       * of the transfer, the account will be reaped.\n       * \n       * The dispatch origin for this call must be `Signed` by the transactor.\n       * \n       * # <weight>\n       * - Dependent on arguments but not critical, given proper implementations for input config\n       * types. See related functions below.\n       * - It contains a limited number of reads and writes internally and no complex\n       * computation.\n       * \n       * Related functions:\n       * \n       * - `ensure_can_withdraw` is always called internally but has a bounded complexity.\n       * - Transferring balances to accounts that did not exist before will cause\n       * `T::OnNewAccount::on_new_account` to be called.\n       * - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.\n       * - `transfer_keep_alive` works the same way as `transfer`, but has an additional check\n       * that the transfer will not kill the origin account.\n       * ---------------------------------\n       * - Origin account is already in memory, so no DB operations for them.\n       * # </weight>\n       **/\n      transfer: AugmentedSubmittable<(dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Transfer the entire transferable balance from the caller account.\n       * \n       * NOTE: This function only attempts to transfer _transferable_ balances. This means that\n       * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be\n       * transferred by this function. To ensure that this function results in a killed account,\n       * you might need to prepare the account by removing any reference counters, storage\n       * deposits, etc...\n       * \n       * The dispatch origin of this call must be Signed.\n       * \n       * - `dest`: The recipient of the transfer.\n       * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all\n       * of the funds the account has, causing the sender account to be killed (false), or\n       * transfer everything except at least the existential deposit, which will guarantee to\n       * keep the sender account alive (true). # <weight>\n       * - O(1). Just like transfer, but reading the user's transferable balance first.\n       * #</weight>\n       **/\n      transferAll: AugmentedSubmittable<(dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, keepAlive: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, bool]>;\n      /**\n       * Same as the [`transfer`] call, but with a check that the transfer will not kill the\n       * origin account.\n       * \n       * 99% of the time you want [`transfer`] instead.\n       * \n       * [`transfer`]: struct.Pallet.html#method.transfer\n       **/\n      transferKeepAlive: AugmentedSubmittable<(dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    dex: {\n      /**\n       * Add liquidity to Enabled trading pair, or add provision to Provisioning trading pair.\n       * - Add liquidity success will issue shares in current price which decided by the\n       * liquidity scale. Shares are temporarily not\n       * allowed to transfer and trade, it represents the proportion of\n       * assets in liquidity pool.\n       * - Add provision success will record the provision, issue shares to caller in the initial\n       * price when trading pair convert to Enabled.\n       * - Creates and enables TradingPair LP token if it does not exist for trading pair.\n       * - Fails to add liquidity for `NotEnabled` trading pair.\n       * \n       * - `asset_id_a`: Asset id A.\n       * - `asset_id_b`: Asset id B.\n       * - `amount_a_desired`: amount a desired to add.\n       * - `amount_b_desired`: amount b desired to add.\n       * - `amount_a_min`: amount a minimum willing to add.\n       * - `amount_b_min`: amount b minimum willing to add.\n       * - `min_share_increment`: minimum expected lp token shares to be recieved.\n       **/\n      addLiquidity: AugmentedSubmittable<(assetIdA: u32 | AnyNumber | Uint8Array, assetIdB: u32 | AnyNumber | Uint8Array, amountADesired: Compact<u128> | AnyNumber | Uint8Array, amountBDesired: Compact<u128> | AnyNumber | Uint8Array, amountAMin: Compact<u128> | AnyNumber | Uint8Array, amountBMin: Compact<u128> | AnyNumber | Uint8Array, minShareIncrement: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32, Compact<u128>, Compact<u128>, Compact<u128>, Compact<u128>, Compact<u128>]>;\n      /**\n       * Disable an `Enabled` trading pair.\n       * - Requires LP token to be created and in the `Enabled` status\n       * - Only root can disable trading pair\n       * \n       * - `asset_id_a`: Asset id A.\n       * - `asset_id_b`: Asset id B.\n       **/\n      disableTradingPair: AugmentedSubmittable<(assetIdA: u32 | AnyNumber | Uint8Array, assetIdB: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Re enable a `NotEnabled` trading pair.\n       * - Requires LP token to be created and in the `NotEnabled` status\n       * - Only root can enable a disabled trading pair\n       * \n       * - `asset_id_a`: Asset id A.\n       * - `asset_id_b`: Asset id B.\n       **/\n      reenableTradingPair: AugmentedSubmittable<(assetIdA: u32 | AnyNumber | Uint8Array, assetIdB: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Remove liquidity from specific liquidity pool in the form of burning\n       * shares, and withdrawing currencies in trading pairs from liquidity\n       * pool in proportion, and withdraw liquidity incentive interest.\n       * - note: liquidity can still be withdrawn for `NotEnabled` trading pairs.\n       * \n       * - `asset_id_a`: Asset id A.\n       * - `asset_id_b`: Asset id B.\n       * - `remove_liquidity`: liquidity amount to remove.\n       * - `min_withdrawn_a`: minimum amount of asset A to be withdrawn from LP token.\n       * - `min_withdrawn_b`: minimum amount of asset B to be withdrawn from LP token.\n       **/\n      removeLiquidity: AugmentedSubmittable<(assetIdA: u32 | AnyNumber | Uint8Array, assetIdB: u32 | AnyNumber | Uint8Array, removeLiquidity: Compact<u128> | AnyNumber | Uint8Array, minWithdrawnA: Compact<u128> | AnyNumber | Uint8Array, minWithdrawnB: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32, Compact<u128>, Compact<u128>, Compact<u128>]>;\n      /**\n       * Trading with DEX, swap with exact supply amount. Specify your input; retrieve variable\n       * output.\n       * - note: analogous to Uniswapv2 `swapExactTokensForTokens`\n       * \n       * - `path`: trading path.\n       * - `amount_in`: exact supply amount.\n       * - `amount_out_min`: acceptable minimum target amount.\n       **/\n      swapWithExactSupply: AugmentedSubmittable<(amountIn: Compact<u128> | AnyNumber | Uint8Array, amountOutMin: Compact<u128> | AnyNumber | Uint8Array, path: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Compact<u128>, Compact<u128>, Vec<u32>]>;\n      /**\n       * Trading with DEX, swap with exact target amount. Specify your output; supply variable\n       * input.\n       * - note: analogous to Uniswapv2 `swapTokensForExactTokens`\n       * \n       * - `amount_out`: exact target amount.\n       * - `amount_in_max`: acceptable maximum supply amount.\n       * - `path`: trading path.\n       **/\n      swapWithExactTarget: AugmentedSubmittable<(amountOut: Compact<u128> | AnyNumber | Uint8Array, amountInMax: Compact<u128> | AnyNumber | Uint8Array, path: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Compact<u128>, Compact<u128>, Vec<u32>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    echo: {\n      /**\n       * Ping extrinsic sends an event to the bridge containing a message\n       **/\n      ping: AugmentedSubmittable<(destination: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    electionProviderMultiPhase: {\n      /**\n       * Trigger the governance fallback.\n       * \n       * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to\n       * calling [`Call::set_emergency_election_result`].\n       **/\n      governanceFallback: AugmentedSubmittable<(maybeMaxVoters: Option<u32> | null | Uint8Array | u32 | AnyNumber, maybeMaxTargets: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [Option<u32>, Option<u32>]>;\n      /**\n       * Set a solution in the queue, to be handed out to the client of this pallet in the next\n       * call to `ElectionProvider::elect`.\n       * \n       * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.\n       * \n       * The solution is not checked for any feasibility and is assumed to be trustworthy, as any\n       * feasibility check itself can in principle cause the election process to fail (due to\n       * memory/weight constrains).\n       **/\n      setEmergencyElectionResult: AugmentedSubmittable<(supports: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, SpNposElectionsSupport]>> | ([SeedPrimitivesSignatureAccountId20 | string | Uint8Array, SpNposElectionsSupport | { total?: any; voters?: any } | string | Uint8Array])[]) => SubmittableExtrinsic<ApiType>, [Vec<ITuple<[SeedPrimitivesSignatureAccountId20, SpNposElectionsSupport]>>]>;\n      /**\n       * Set a new value for `MinimumUntrustedScore`.\n       * \n       * Dispatch origin must be aligned with `T::ForceOrigin`.\n       * \n       * This check can be turned off by setting the value to `None`.\n       **/\n      setMinimumUntrustedScore: AugmentedSubmittable<(maybeNextScore: Option<SpNposElectionsElectionScore> | null | Uint8Array | SpNposElectionsElectionScore | { minimalStake?: any; sumStake?: any; sumStakeSquared?: any } | string) => SubmittableExtrinsic<ApiType>, [Option<SpNposElectionsElectionScore>]>;\n      /**\n       * Submit a solution for the signed phase.\n       * \n       * The dispatch origin fo this call must be __signed__.\n       * \n       * The solution is potentially queued, based on the claimed score and processed at the end\n       * of the signed phase.\n       * \n       * A deposit is reserved and recorded for the solution. Based on the outcome, the solution\n       * might be rewarded, slashed, or get all or a part of the deposit back.\n       **/\n      submit: AugmentedSubmittable<(rawSolution: PalletElectionProviderMultiPhaseRawSolution | { solution?: any; score?: any; round?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletElectionProviderMultiPhaseRawSolution]>;\n      /**\n       * Submit a solution for the unsigned phase.\n       * \n       * The dispatch origin fo this call must be __none__.\n       * \n       * This submission is checked on the fly. Moreover, this unsigned solution is only\n       * validated when submitted to the pool from the **local** node. Effectively, this means\n       * that only active validators can submit this transaction when authoring a block (similar\n       * to an inherent).\n       * \n       * To prevent any incorrect solution (and thus wasted time/weight), this transaction will\n       * panic if the solution submitted by the validator is invalid in any way, effectively\n       * putting their authoring reward at risk.\n       * \n       * No deposit or reward is associated with this submission.\n       **/\n      submitUnsigned: AugmentedSubmittable<(rawSolution: PalletElectionProviderMultiPhaseRawSolution | { solution?: any; score?: any; round?: any } | string | Uint8Array, witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize | { voters?: any; targets?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletElectionProviderMultiPhaseRawSolution, PalletElectionProviderMultiPhaseSolutionOrSnapshotSize]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    erc20Peg: {\n      /**\n       * Activate/deactivate deposits (root only)\n       **/\n      activateDeposits: AugmentedSubmittable<(activate: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [bool]>;\n      /**\n       * Activate/deactivate withdrawals (root only)\n       **/\n      activateWithdrawals: AugmentedSubmittable<(activate: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [bool]>;\n      setContractAddress: AugmentedSubmittable<(ethAddress: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      setErc20Meta: AugmentedSubmittable<(details: Vec<ITuple<[H160, Bytes, u8]>> | ([H160 | string | Uint8Array, Bytes | string | Uint8Array, u8 | AnyNumber | Uint8Array])[]) => SubmittableExtrinsic<ApiType>, [Vec<ITuple<[H160, Bytes, u8]>>]>;\n      setPaymentDelay: AugmentedSubmittable<(assetId: u32 | AnyNumber | Uint8Array, minBalance: u128 | AnyNumber | Uint8Array, delay: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u128, u32]>;\n      withdraw: AugmentedSubmittable<(assetId: u32 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array, beneficiary: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u128, H160]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    ethBridge: {\n      depositRelayerBond: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      finaliseAuthoritiesChange: AugmentedSubmittable<(nextNotaryKeys: Vec<SeedPrimitivesEthyCryptoAppCryptoPublic> | (SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>]>;\n      setBridgePaused: AugmentedSubmittable<(paused: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [bool]>;\n      setChallengePeriod: AugmentedSubmittable<(blocks: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32]>;\n      setContractAddress: AugmentedSubmittable<(contractAddress: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      setDelayedEventProofsPerBlock: AugmentedSubmittable<(count: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u8]>;\n      setEventBlockConfirmations: AugmentedSubmittable<(confirmations: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      setRelayer: AugmentedSubmittable<(relayer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      setXrplDoorSigners: AugmentedSubmittable<(newSigners: Vec<SeedPrimitivesEthyCryptoAppCryptoPublic> | (SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>]>;\n      submitChallenge: AugmentedSubmittable<(eventClaimId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      submitEvent: AugmentedSubmittable<(txHash: H256 | string | Uint8Array, event: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H256, Bytes]>;\n      submitNotarization: AugmentedSubmittable<(payload: PalletEthyNotarizationPayload | { Call: any } | { Event: any } | string | Uint8Array, signature: SeedPrimitivesEthyCryptoAppCryptoSignature | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletEthyNotarizationPayload, SeedPrimitivesEthyCryptoAppCryptoSignature]>;\n      withdrawRelayerBond: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    ethereum: {\n      /**\n       * Transact an Ethereum transaction.\n       **/\n      transact: AugmentedSubmittable<(transaction: EthereumTransactionTransactionV2 | { Legacy: any } | { EIP2930: any } | { EIP1559: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumTransactionTransactionV2]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    evm: {\n      /**\n       * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.\n       **/\n      call: AugmentedSubmittable<(source: H160 | string | Uint8Array, target: H160 | string | Uint8Array, input: Bytes | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, maxFeePerGas: U256 | AnyNumber | Uint8Array, maxPriorityFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, nonce: Option<U256> | null | Uint8Array | U256 | AnyNumber, accessList: Vec<ITuple<[H160, Vec<H256>]>> | ([H160 | string | Uint8Array, Vec<H256> | (H256 | string | Uint8Array)[]])[]) => SubmittableExtrinsic<ApiType>, [H160, H160, Bytes, U256, u64, U256, Option<U256>, Option<U256>, Vec<ITuple<[H160, Vec<H256>]>>]>;\n      /**\n       * Issue an EVM create operation. This is similar to a contract creation transaction in\n       * Ethereum.\n       **/\n      create: AugmentedSubmittable<(source: H160 | string | Uint8Array, init: Bytes | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, maxFeePerGas: U256 | AnyNumber | Uint8Array, maxPriorityFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, nonce: Option<U256> | null | Uint8Array | U256 | AnyNumber, accessList: Vec<ITuple<[H160, Vec<H256>]>> | ([H160 | string | Uint8Array, Vec<H256> | (H256 | string | Uint8Array)[]])[]) => SubmittableExtrinsic<ApiType>, [H160, Bytes, U256, u64, U256, Option<U256>, Option<U256>, Vec<ITuple<[H160, Vec<H256>]>>]>;\n      /**\n       * Issue an EVM create2 operation.\n       **/\n      create2: AugmentedSubmittable<(source: H160 | string | Uint8Array, init: Bytes | string | Uint8Array, salt: H256 | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, maxFeePerGas: U256 | AnyNumber | Uint8Array, maxPriorityFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, nonce: Option<U256> | null | Uint8Array | U256 | AnyNumber, accessList: Vec<ITuple<[H160, Vec<H256>]>> | ([H160 | string | Uint8Array, Vec<H256> | (H256 | string | Uint8Array)[]])[]) => SubmittableExtrinsic<ApiType>, [H160, Bytes, H256, U256, u64, U256, Option<U256>, Option<U256>, Vec<ITuple<[H160, Vec<H256>]>>]>;\n      /**\n       * Withdraw balance from EVM into currency/balances pallet.\n       **/\n      withdraw: AugmentedSubmittable<(address: H160 | string | Uint8Array, value: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160, u128]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    evmChainId: {\n      setChainId: AugmentedSubmittable<(chainId: Compact<u64> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u64>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    feeControl: {\n      setEvmBaseFee: AugmentedSubmittable<(value: U256 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [U256]>;\n      setWeightMultiplier: AugmentedSubmittable<(value: Perbill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Perbill]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    feeProxy: {\n      /**\n       * Call an internal call with specified gas token\n       * payment_asset: The token to be used for paying gas fees. This is exchanged in\n       * OnChargeTransaction::withdraw_fee()\n       * max_payment: The limit of how many tokens will be used to perform the exchange\n       * call: The inner call to be performed after the exchange\n       **/\n      callWithFeePreferences: AugmentedSubmittable<(paymentAsset: u32 | AnyNumber | Uint8Array, maxPayment: u128 | AnyNumber | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u128, Call]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    futurepass: {\n      /**\n       * Create a futurepass account for the delegator that is able to make calls on behalf of\n       * futurepass.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `account`: The delegated account for the futurepass.\n       **/\n      create: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * This extrinsic migrates EVM-based Futurepass assets to the Substrate-based Futurepass\n       * (native).\n       * \n       * Parameters:\n       * - `owner` - The account ID of the owner of the EVM-based Futurepass.\n       * - `evm_futurepass` - The account ID of the EVM-based Futurepass.\n       * - `collection_ids` - A vector of collection IDs representing the NFTs collections to be\n       * migrated.\n       * \n       * # <weight>\n       * Weight is a function of the number of collections migrated; not the tokens migrated.\n       * # </weight>\n       **/\n      migrateEvmFuturepass: AugmentedSubmittable<(owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, evmFuturepass: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, collectionIds: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Vec<u32>]>;\n      /**\n       * Dispatch the given call through Futurepass account. Transaction fees will be paid by the\n       * Futurepass The dispatch origin for this call must be _Signed_\n       * \n       * Parameters:\n       * - `futurepass`: The Futurepass account though which the call is dispatched\n       * - `call`: The Call that needs to be dispatched through the Futurepass account\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has.\n       * # </weight>\n       **/\n      proxyExtrinsic: AugmentedSubmittable<(futurepass: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Call]>;\n      /**\n       * Register a delegator to an existing futurepass account.\n       * Note: Only futurepass owner account can add more delegates.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `futurepass`: Futurepass account to register the account as delegate.\n       * - `proxy_type`: Delegate permission level\n       * - `delegate`: The delegated account for the futurepass.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has.\n       * # </weight>\n       **/\n      registerDelegate: AugmentedSubmittable<(futurepass: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType]>;\n      /**\n       * Update futurepass native assets migrator admin account.\n       * \n       * The dispatch origin for this call must be sudo/root origin.\n       * \n       * Parameters:\n       * - `migrator`: The new account that will become the futurepass asset migrator.\n       **/\n      setFuturepassMigrator: AugmentedSubmittable<(migrator: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Transfer ownership of a futurepass to a new account.\n       * The new owner must not already own a futurepass.\n       * This removes all delegates from the futurepass.\n       * The new owner will be the only delegate; they can add more delegates.\n       * \n       * The dispatch origin for this call must be _Signed_ and must be the current owner of the\n       * futurepass.\n       * \n       * Parameters:\n       * - `new_owner`: The new account that will become the owner of the futurepass.\n       **/\n      transferFuturepass: AugmentedSubmittable<(newOwner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Unregister a delegate from a futurepass account.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `futurepass`: Futurepass account to unregister the delegate from.\n       * - `delegate`: The delegated account for the futurepass. Note: if caller is futurepass\n       * holder onwer,\n       * they can remove any delegate (including themselves); otherwise the caller must be the\n       * delegate (can only remove themself).\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has.\n       * # </weight>\n       **/\n      unregisterDelegate: AugmentedSubmittable<(futurepass: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    grandpa: {\n      /**\n       * Note that the current authority set of the GRANDPA finality gadget has stalled.\n       * \n       * This will trigger a forced authority set change at the beginning of the next session, to\n       * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume\n       * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.\n       * The block production rate (which may be slowed down because of finality lagging) should\n       * be taken into account when choosing the `delay`. The GRANDPA voters based on the new\n       * authority will start voting on top of `best_finalized_block_number` for new finalized\n       * blocks. `best_finalized_block_number` should be the highest of the latest finalized\n       * block of all validators of the new authority set.\n       * \n       * Only callable by root.\n       **/\n      noteStalled: AugmentedSubmittable<(delay: u32 | AnyNumber | Uint8Array, bestFinalizedBlockNumber: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Report voter equivocation/misbehavior. This method will verify the\n       * equivocation proof and validate the given key ownership proof\n       * against the extracted offender. If both are valid, the offence\n       * will be reported.\n       **/\n      reportEquivocation: AugmentedSubmittable<(equivocationProof: SpFinalityGrandpaEquivocationProof | { setId?: any; equivocation?: any } | string | Uint8Array, keyOwnerProof: SpCoreVoid | null) => SubmittableExtrinsic<ApiType>, [SpFinalityGrandpaEquivocationProof, SpCoreVoid]>;\n      /**\n       * Report voter equivocation/misbehavior. This method will verify the\n       * equivocation proof and validate the given key ownership proof\n       * against the extracted offender. If both are valid, the offence\n       * will be reported.\n       * \n       * This extrinsic must be called unsigned and it is expected that only\n       * block authors will call it (validated in `ValidateUnsigned`), as such\n       * if the block author is defined it will be defined as the equivocation\n       * reporter.\n       **/\n      reportEquivocationUnsigned: AugmentedSubmittable<(equivocationProof: SpFinalityGrandpaEquivocationProof | { setId?: any; equivocation?: any } | string | Uint8Array, keyOwnerProof: SpCoreVoid | null) => SubmittableExtrinsic<ApiType>, [SpFinalityGrandpaEquivocationProof, SpCoreVoid]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    imOnline: {\n      /**\n       * # <weight>\n       * - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is\n       * length of `heartbeat.network_state.external_address`\n       * - `O(K)`: decoding of length `K`\n       * - `O(E)`: decoding/encoding of length `E`\n       * - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,\n       * `ReceivedHeartbeats`\n       * - DbWrites: `ReceivedHeartbeats`\n       * # </weight>\n       **/\n      heartbeat: AugmentedSubmittable<(heartbeat: PalletImOnlineHeartbeat | { blockNumber?: any; networkState?: any; sessionIndex?: any; authorityIndex?: any; validatorsLen?: any } | string | Uint8Array, signature: PalletImOnlineSr25519AppSr25519Signature | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletImOnlineHeartbeat, PalletImOnlineSr25519AppSr25519Signature]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    marketplace: {\n      /**\n       * Accepts an offer on a token\n       * Caller must be token owner\n       **/\n      acceptOffer: AugmentedSubmittable<(offerId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Auction a bundle of tokens on the open market to the highest bidder\n       * - Tokens must be from the same collection\n       * - Tokens with individual royalties schedules cannot be sold in bundles\n       * \n       * Caller must be the token owner\n       * - `payment_asset` fungible asset Id to receive payment with\n       * - `reserve_price` winning bid must be over this threshold\n       * - `duration` length of the auction (in blocks), uses default duration if unspecified\n       **/\n      auctionNft: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], paymentAsset: u32 | AnyNumber | Uint8Array, reservePrice: u128 | AnyNumber | Uint8Array, duration: Option<u32> | null | Uint8Array | u32 | AnyNumber, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, u32, u128, Option<u32>, Option<u32>]>;\n      /**\n       * Place a bid on an open auction\n       * - `amount` to bid (in the seller's requested payment asset)\n       **/\n      bid: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, u128]>;\n      /**\n       * Buy a token listing for its specified price\n       **/\n      buy: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Cancels an offer on a token\n       * Caller must be the offer buyer\n       **/\n      cancelOffer: AugmentedSubmittable<(offerId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Close a sale or auction returning tokens\n       * Requires no successful bids have been made for an auction.\n       * Caller must be the listed seller\n       **/\n      cancelSale: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Create an offer on a token\n       * Locks funds until offer is accepted, rejected or cancelled\n       * An offer can't be made on a token currently in an auction\n       * (This follows the behaviour of Opensea and forces the buyer to bid rather than create an\n       * offer)\n       **/\n      makeSimpleOffer: AugmentedSubmittable<(tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], amount: u128 | AnyNumber | Uint8Array, assetId: u32 | AnyNumber | Uint8Array, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [ITuple<[u32, u32]>, u128, u32, Option<u32>]>;\n      /**\n       * Flag an account as a marketplace\n       * \n       * `marketplace_account` - if specified, this account will be registered\n       * `entitlement` - Permill, percentage of sales to go to the marketplace\n       * If no marketplace is specified the caller will be registered\n       **/\n      registerMarketplace: AugmentedSubmittable<(marketplaceAccount: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, entitlement: Permill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Option<SeedPrimitivesSignatureAccountId20>, Permill]>;\n      /**\n       * Sell a bundle of tokens at a fixed price\n       * - Tokens must be from the same collection\n       * - Tokens with individual royalties schedules cannot be sold with this method\n       * \n       * `buyer` optionally, the account to receive the NFT. If unspecified, then any account may\n       * purchase `asset_id` fungible asset Id to receive as payment for the NFT\n       * `fixed_price` ask price\n       * `duration` listing duration time in blocks from now\n       * Caller must be the token owner\n       **/\n      sellNft: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], buyer: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, paymentAsset: u32 | AnyNumber | Uint8Array, fixedPrice: u128 | AnyNumber | Uint8Array, duration: Option<u32> | null | Uint8Array | u32 | AnyNumber, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, Option<SeedPrimitivesSignatureAccountId20>, u32, u128, Option<u32>, Option<u32>]>;\n      /**\n       * Update fixed price for a single token sale\n       * \n       * `listing_id` id of the fixed price listing\n       * `new_price` new fixed price\n       * Caller must be the token owner\n       **/\n      updateFixedPrice: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array, newPrice: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, u128]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    nft: {\n      /**\n       * Accepts an offer on a token\n       * Caller must be token owner\n       **/\n      acceptOffer: AugmentedSubmittable<(offerId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Auction a bundle of tokens on the open market to the highest bidder\n       * - Tokens must be from the same collection\n       * - Tokens with individual royalties schedules cannot be sold in bundles\n       * \n       * Caller must be the token owner\n       * - `payment_asset` fungible asset Id to receive payment with\n       * - `reserve_price` winning bid must be over this threshold\n       * - `duration` length of the auction (in blocks), uses default duration if unspecified\n       **/\n      auction: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], paymentAsset: u32 | AnyNumber | Uint8Array, reservePrice: u128 | AnyNumber | Uint8Array, duration: Option<u32> | null | Uint8Array | u32 | AnyNumber, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, u32, u128, Option<u32>, Option<u32>]>;\n      /**\n       * Place a bid on an open auction\n       * - `amount` to bid (in the seller's requested payment asset)\n       **/\n      bid: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, u128]>;\n      /**\n       * Burn a token 🔥\n       * \n       * Caller must be the token owner\n       **/\n      burn: AugmentedSubmittable<(tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => SubmittableExtrinsic<ApiType>, [ITuple<[u32, u32]>]>;\n      /**\n       * Buy a token listing for its specified price\n       **/\n      buy: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Cancels an offer on a token\n       * Caller must be the offer buyer\n       **/\n      cancelOffer: AugmentedSubmittable<(offerId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Close a sale or auction returning tokens\n       * Requires no successful bids have been made for an auction.\n       * Caller must be the listed seller\n       **/\n      cancelSale: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Bridged collections from Ethereum will initially lack an owner. These collections will\n       * be assigned to the pallet. This allows for claiming those collections assuming they were\n       * assigned to the pallet\n       **/\n      claimUnownedCollection: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, newOwner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Create a new collection\n       * Additional tokens can be minted via `mint_additional`\n       * \n       * `name` - the name of the collection\n       * `initial_issuance` - number of tokens to mint now\n       * `max_issuance` - maximum number of tokens allowed in collection\n       * `token_owner` - the token owner, defaults to the caller\n       * `metadata_scheme` - The off-chain metadata referencing scheme for tokens in this\n       * `royalties_schedule` - defacto royalties plan for secondary sales, this will\n       * apply to all tokens in the collection by default.\n       **/\n      createCollection: AugmentedSubmittable<(name: Bytes | string | Uint8Array, initialIssuance: u32 | AnyNumber | Uint8Array, maxIssuance: Option<u32> | null | Uint8Array | u32 | AnyNumber, tokenOwner: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, metadataScheme: Bytes | string | Uint8Array, royaltiesSchedule: Option<PalletNftRoyaltiesSchedule> | null | Uint8Array | PalletNftRoyaltiesSchedule | { entitlements?: any } | string, crossChainCompatibility: PalletNftCrossChainCompatibility | { xrpl?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, u32, Option<u32>, Option<SeedPrimitivesSignatureAccountId20>, Bytes, Option<PalletNftRoyaltiesSchedule>, PalletNftCrossChainCompatibility]>;\n      /**\n       * Create an offer on a token\n       * Locks funds until offer is accepted, rejected or cancelled\n       * An offer can't be made on a token currently in an auction\n       * (This follows the behaviour of Opensea and forces the buyer to bid rather than create an\n       * offer)\n       **/\n      makeSimpleOffer: AugmentedSubmittable<(tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], amount: u128 | AnyNumber | Uint8Array, assetId: u32 | AnyNumber | Uint8Array, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [ITuple<[u32, u32]>, u128, u32, Option<u32>]>;\n      /**\n       * Mint tokens for an existing collection\n       * \n       * `collection_id` - the collection to mint tokens in\n       * `quantity` - how many tokens to mint\n       * `token_owner` - the token owner, defaults to the caller if unspecified\n       * Caller must be the collection owner\n       * -----------\n       * Weight is O(N) where N is `quantity`\n       **/\n      mint: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, quantity: u32 | AnyNumber | Uint8Array, tokenOwner: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string) => SubmittableExtrinsic<ApiType>, [u32, u32, Option<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * Flag an account as a marketplace\n       * \n       * `marketplace_account` - if specified, this account will be registered\n       * `entitlement` - Permill, percentage of sales to go to the marketplace\n       * If no marketplace is specified the caller will be registered\n       **/\n      registerMarketplace: AugmentedSubmittable<(marketplaceAccount: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, entitlement: Permill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Option<SeedPrimitivesSignatureAccountId20>, Permill]>;\n      /**\n       * Sell a bundle of tokens at a fixed price\n       * - Tokens must be from the same collection\n       * - Tokens with individual royalties schedules cannot be sold with this method\n       * \n       * `buyer` optionally, the account to receive the NFT. If unspecified, then any account may\n       * purchase `asset_id` fungible asset Id to receive as payment for the NFT\n       * `fixed_price` ask price\n       * `duration` listing duration time in blocks from now\n       * Caller must be the token owner\n       **/\n      sell: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], buyer: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, paymentAsset: u32 | AnyNumber | Uint8Array, fixedPrice: u128 | AnyNumber | Uint8Array, duration: Option<u32> | null | Uint8Array | u32 | AnyNumber, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, Option<SeedPrimitivesSignatureAccountId20>, u32, u128, Option<u32>, Option<u32>]>;\n      /**\n       * Set the base URI of a collection\n       * Caller must be the current collection owner\n       **/\n      setBaseUri: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, baseUri: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, Bytes]>;\n      /**\n       * Set the max issuance of a collection\n       * Caller must be the current collection owner\n       **/\n      setMaxIssuance: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, maxIssuance: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Set the owner of a collection\n       * Caller must be the current collection owner\n       **/\n      setOwner: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, newOwner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Transfer ownership of an NFT\n       * Caller must be the token owner\n       **/\n      transfer: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], newOwner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Update fixed price for a single token sale\n       * \n       * `listing_id` id of the fixed price listing\n       * `new_price` new fixed price\n       * Caller must be the token owner\n       **/\n      updateFixedPrice: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array, newPrice: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, u128]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    nftPeg: {\n      setContractAddress: AugmentedSubmittable<(contract: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      withdraw: AugmentedSubmittable<(collectionIds: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], serialNumbers: Vec<Vec<u32>>, destination: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<u32>, Vec<Vec<u32>>, H160]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    proxy: {\n      /**\n       * Register a proxy account for the sender that is able to make calls on its behalf.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `proxy`: The account that the `caller` would like to make a proxy.\n       * - `proxy_type`: The permissions allowed for this proxy account.\n       * - `delay`: The announcement period required of the initial proxy. Will generally be\n       * zero.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      addProxy: AugmentedSubmittable<(delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array, delay: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, u32]>;\n      /**\n       * Publish the hash of a proxy-call that will be made in the future.\n       * \n       * This must be called some number of blocks before the corresponding `proxy` is attempted\n       * if the delay associated with the proxy relationship is greater than zero.\n       * \n       * No more than `MaxPending` announcements may be made at any one time.\n       * \n       * This will take a deposit of `AnnouncementDepositFactor` as well as\n       * `AnnouncementDepositBase` if there are no other pending announcements.\n       * \n       * The dispatch origin for this call must be _Signed_ and a proxy of `real`.\n       * \n       * Parameters:\n       * - `real`: The account that the proxy will make a call on behalf of.\n       * - `call_hash`: The hash of the call to be made by the `real` account.\n       * \n       * # <weight>\n       * Weight is a function of:\n       * - A: the number of announcements made.\n       * - P: the number of proxies the user has.\n       * # </weight>\n       **/\n      announce: AugmentedSubmittable<(real: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, callHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, H256]>;\n      /**\n       * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and\n       * initialize it with a proxy of `proxy_type` for `origin` sender.\n       * \n       * Requires a `Signed` origin.\n       * \n       * - `proxy_type`: The type of the proxy that the sender will be registered as over the\n       * new account. This will almost always be the most permissive `ProxyType` possible to\n       * allow for maximum flexibility.\n       * - `index`: A disambiguation index, in case this is called multiple times in the same\n       * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just\n       * want to use `0`.\n       * - `delay`: The announcement period required of the initial proxy. Will generally be\n       * zero.\n       * \n       * Fails with `Duplicate` if this has already been called in this transaction, from the\n       * same sender, with the same parameters.\n       * \n       * Fails if there are insufficient funds to pay for deposit.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       * TODO: Might be over counting 1 read\n       **/\n      anonymous: AugmentedSubmittable<(proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array, delay: u32 | AnyNumber | Uint8Array, index: u16 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedRuntimeImplsProxyType, u32, u16]>;\n      /**\n       * Removes a previously spawned anonymous proxy.\n       * \n       * WARNING: **All access to this account will be lost.** Any funds held in it will be\n       * inaccessible.\n       * \n       * Requires a `Signed` origin, and the sender account must have been created by a call to\n       * `anonymous` with corresponding parameters.\n       * \n       * - `spawner`: The account that originally called `anonymous` to create this account.\n       * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.\n       * - `proxy_type`: The proxy type originally passed to `anonymous`.\n       * - `height`: The height of the chain when the call to `anonymous` was processed.\n       * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.\n       * \n       * Fails with `NoPermission` in case the caller is not a previously created anonymous\n       * account whose `anonymous` call has corresponding parameters.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      killAnonymous: AugmentedSubmittable<(spawner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array, index: u16 | AnyNumber | Uint8Array, height: Compact<u32> | AnyNumber | Uint8Array, extIndex: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, u16, Compact<u32>, Compact<u32>]>;\n      /**\n       * Dispatch the given `call` from an account that the sender is authorised for through\n       * `add_proxy`.\n       * \n       * Removes any corresponding announcement(s).\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `real`: The account that the proxy will make a call on behalf of.\n       * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.\n       * - `call`: The call to be made by the `real` account.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      proxy: AugmentedSubmittable<(real: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, forceProxyType: Option<SeedRuntimeImplsProxyType> | null | Uint8Array | SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Option<SeedRuntimeImplsProxyType>, Call]>;\n      /**\n       * Dispatch the given `call` from an account that the sender is authorized for through\n       * `add_proxy`.\n       * \n       * Removes any corresponding announcement(s).\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `real`: The account that the proxy will make a call on behalf of.\n       * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.\n       * - `call`: The call to be made by the `real` account.\n       * \n       * # <weight>\n       * Weight is a function of:\n       * - A: the number of announcements made.\n       * - P: the number of proxies the user has.\n       * # </weight>\n       **/\n      proxyAnnounced: AugmentedSubmittable<(delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, real: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, forceProxyType: Option<SeedRuntimeImplsProxyType> | null | Uint8Array | SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Option<SeedRuntimeImplsProxyType>, Call]>;\n      /**\n       * Remove the given announcement of a delegate.\n       * \n       * May be called by a target (proxied) account to remove a call that one of their delegates\n       * (`delegate`) has announced they want to execute. The deposit is returned.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `delegate`: The account that previously announced the call.\n       * - `call_hash`: The hash of the call to be made.\n       * \n       * # <weight>\n       * Weight is a function of:\n       * - A: the number of announcements made.\n       * - P: the number of proxies the user has.\n       * # </weight>\n       **/\n      rejectAnnouncement: AugmentedSubmittable<(delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, callHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, H256]>;\n      /**\n       * Remove a given announcement.\n       * \n       * May be called by a proxy account to remove a call they previously announced and return\n       * the deposit.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `real`: The account that the proxy will make a call on behalf of.\n       * - `call_hash`: The hash of the call to be made by the `real` account.\n       * \n       * # <weight>\n       * Weight is a function of:\n       * - A: the number of announcements made.\n       * - P: the number of proxies the user has.\n       * # </weight>\n       **/\n      removeAnnouncement: AugmentedSubmittable<(real: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, callHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, H256]>;\n      /**\n       * Unregister all proxy accounts for the sender.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * WARNING: This may be called on accounts created by `anonymous`, however if done, then\n       * the unreserved fees will be inaccessible. **All access to this account will be lost.**\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      removeProxies: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Unregister a proxy account for the sender.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `proxy`: The account that the `caller` would like to remove as a proxy.\n       * - `proxy_type`: The permissions currently enabled for the removed proxy account.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      removeProxy: AugmentedSubmittable<(delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array, delay: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, u32]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    recovery: {\n      /**\n       * Send a call through a recovered account.\n       * \n       * The dispatch origin for this call must be _Signed_ and registered to\n       * be able to make calls on behalf of the recovered account.\n       * \n       * Parameters:\n       * - `account`: The recovered account you want to make a call on-behalf-of.\n       * - `call`: The call you want to make with the recovered account.\n       **/\n      asRecovered: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Call]>;\n      /**\n       * Cancel the ability to use `as_recovered` for `account`.\n       * \n       * The dispatch origin for this call must be _Signed_ and registered to\n       * be able to make calls on behalf of the recovered account.\n       * \n       * Parameters:\n       * - `account`: The recovered account you are able to call on-behalf-of.\n       **/\n      cancelRecovered: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Allow a successful rescuer to claim their recovered account.\n       * \n       * The dispatch origin for this call must be _Signed_ and must be a \"rescuer\"\n       * who has successfully completed the account recovery process: collected\n       * `threshold` or more vouches, waited `delay_period` blocks since initiation.\n       * \n       * Parameters:\n       * - `account`: The lost account that you want to claim has been successfully recovered by\n       * you.\n       **/\n      claimRecovery: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * As the controller of a recoverable account, close an active recovery\n       * process for your account.\n       * \n       * Payment: By calling this function, the recoverable account will receive\n       * the recovery deposit `RecoveryDeposit` placed by the rescuer.\n       * \n       * The dispatch origin for this call must be _Signed_ and must be a\n       * recoverable account with an active recovery process for it.\n       * \n       * Parameters:\n       * - `rescuer`: The account trying to rescue this recoverable account.\n       **/\n      closeRecovery: AugmentedSubmittable<(rescuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Create a recovery configuration for your account. This makes your account recoverable.\n       * \n       * Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance\n       * will be reserved for storing the recovery configuration. This deposit is returned\n       * in full when the user calls `remove_recovery`.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `friends`: A list of friends you trust to vouch for recovery attempts. Should be\n       * ordered and contain no duplicate values.\n       * - `threshold`: The number of friends that must vouch for a recovery attempt before the\n       * account can be recovered. Should be less than or equal to the length of the list of\n       * friends.\n       * - `delay_period`: The number of blocks after a recovery attempt is initialized that\n       * needs to pass before the account can be recovered.\n       **/\n      createRecovery: AugmentedSubmittable<(friends: Vec<SeedPrimitivesSignatureAccountId20> | (SeedPrimitivesSignatureAccountId20 | string | Uint8Array)[], threshold: u16 | AnyNumber | Uint8Array, delayPeriod: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesSignatureAccountId20>, u16, u32]>;\n      /**\n       * Initiate the process for recovering a recoverable account.\n       * \n       * Payment: `RecoveryDeposit` balance will be reserved for initiating the\n       * recovery process. This deposit will always be repatriated to the account\n       * trying to be recovered. See `close_recovery`.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `account`: The lost account that you want to recover. This account needs to be\n       * recoverable (i.e. have a recovery configuration).\n       **/\n      initiateRecovery: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Remove the recovery process for your account. Recovered accounts are still accessible.\n       * \n       * NOTE: The user must make sure to call `close_recovery` on all active\n       * recovery attempts before calling this function else it will fail.\n       * \n       * Payment: By calling this function the recoverable account will unreserve\n       * their recovery configuration deposit.\n       * (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)\n       * \n       * The dispatch origin for this call must be _Signed_ and must be a\n       * recoverable account (i.e. has a recovery configuration).\n       **/\n      removeRecovery: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Allow ROOT to bypass the recovery process and set an a rescuer account\n       * for a lost account directly.\n       * \n       * The dispatch origin for this call must be _ROOT_.\n       * \n       * Parameters:\n       * - `lost`: The \"lost account\" to be recovered.\n       * - `rescuer`: The \"rescuer account\" which can call as the lost account.\n       **/\n      setRecovered: AugmentedSubmittable<(lost: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, rescuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Allow a \"friend\" of a recoverable account to vouch for an active recovery\n       * process for that account.\n       * \n       * The dispatch origin for this call must be _Signed_ and must be a \"friend\"\n       * for the recoverable account.\n       * \n       * Parameters:\n       * - `lost`: The lost account that you want to recover.\n       * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.\n       * \n       * The combination of these two parameters must point to an active recovery\n       * process.\n       **/\n      vouchRecovery: AugmentedSubmittable<(lost: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, rescuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    scheduler: {\n      /**\n       * Cancel an anonymously scheduled task.\n       **/\n      cancel: AugmentedSubmittable<(when: u32 | AnyNumber | Uint8Array, index: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Cancel a named scheduled task.\n       **/\n      cancelNamed: AugmentedSubmittable<(id: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Anonymously schedule a task.\n       **/\n      schedule: AugmentedSubmittable<(when: u32 | AnyNumber | Uint8Array, maybePeriodic: Option<ITuple<[u32, u32]>> | null | Uint8Array | ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], priority: u8 | AnyNumber | Uint8Array, call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]>;\n      /**\n       * Anonymously schedule a task after a delay.\n       * \n       * # <weight>\n       * Same as [`schedule`].\n       * # </weight>\n       **/\n      scheduleAfter: AugmentedSubmittable<(after: u32 | AnyNumber | Uint8Array, maybePeriodic: Option<ITuple<[u32, u32]>> | null | Uint8Array | ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], priority: u8 | AnyNumber | Uint8Array, call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]>;\n      /**\n       * Schedule a named task.\n       **/\n      scheduleNamed: AugmentedSubmittable<(id: Bytes | string | Uint8Array, when: u32 | AnyNumber | Uint8Array, maybePeriodic: Option<ITuple<[u32, u32]>> | null | Uint8Array | ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], priority: u8 | AnyNumber | Uint8Array, call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]>;\n      /**\n       * Schedule a named task after a delay.\n       * \n       * # <weight>\n       * Same as [`schedule_named`](Self::schedule_named).\n       * # </weight>\n       **/\n      scheduleNamedAfter: AugmentedSubmittable<(id: Bytes | string | Uint8Array, after: u32 | AnyNumber | Uint8Array, maybePeriodic: Option<ITuple<[u32, u32]>> | null | Uint8Array | ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], priority: u8 | AnyNumber | Uint8Array, call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    session: {\n      /**\n       * Removes any session key(s) of the function caller.\n       * \n       * This doesn't take effect until the next session.\n       * \n       * The dispatch origin of this function must be Signed and the account must be either be\n       * convertible to a validator ID using the chain's typical addressing system (this usually\n       * means being a controller account) or directly convertible into a validator ID (which\n       * usually means being a stash account).\n       * \n       * # <weight>\n       * - Complexity: `O(1)` in number of key types. Actual cost depends on the number of length\n       * of `T::Keys::key_ids()` which is fixed.\n       * - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`\n       * - DbWrites: `NextKeys`, `origin account`\n       * - DbWrites per key id: `KeyOwner`\n       * # </weight>\n       **/\n      purgeKeys: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Sets the session key(s) of the function caller to `keys`.\n       * Allows an account to set its session key prior to becoming a validator.\n       * This doesn't take effect until the next session.\n       * \n       * The dispatch origin of this function must be signed.\n       * \n       * # <weight>\n       * - Complexity: `O(1)`. Actual cost depends on the number of length of\n       * `T::Keys::key_ids()` which is fixed.\n       * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`\n       * - DbWrites: `origin account`, `NextKeys`\n       * - DbReads per key id: `KeyOwner`\n       * - DbWrites per key id: `KeyOwner`\n       * # </weight>\n       **/\n      setKeys: AugmentedSubmittable<(keys: SeedRuntimeSessionKeys | { babe?: any; imOnline?: any; grandpa?: any; ethy?: any } | string | Uint8Array, proof: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedRuntimeSessionKeys, Bytes]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    staking: {\n      /**\n       * Take the origin account as a stash and lock up `value` of its balance. `controller` will\n       * be the account that controls it.\n       * \n       * `value` must be more than the `minimum_balance` specified by `T::Currency`.\n       * \n       * The dispatch origin for this call must be _Signed_ by the stash account.\n       * \n       * Emits `Bonded`.\n       * # <weight>\n       * - Independent of the arguments. Moderate complexity.\n       * - O(1).\n       * - Three extra DB entries.\n       * \n       * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned\n       * unless the `origin` falls below _existential deposit_ and gets removed as dust.\n       * ------------------\n       * # </weight>\n       **/\n      bond: AugmentedSubmittable<(controller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, value: Compact<u128> | AnyNumber | Uint8Array, payee: PalletStakingRewardDestination | { Staked: any } | { Stash: any } | { Controller: any } | { Account: any } | { None: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Compact<u128>, PalletStakingRewardDestination]>;\n      /**\n       * Add some extra amount that have appeared in the stash `free_balance` into the balance up\n       * for staking.\n       * \n       * The dispatch origin for this call must be _Signed_ by the stash, not the controller.\n       * \n       * Use this if there are additional funds in your stash account that you wish to bond.\n       * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose\n       * any limitation on the amount that can be added.\n       * \n       * Emits `Bonded`.\n       * \n       * # <weight>\n       * - Independent of the arguments. Insignificant complexity.\n       * - O(1).\n       * # </weight>\n       **/\n      bondExtra: AugmentedSubmittable<(maxAdditional: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u128>]>;\n      /**\n       * Cancel enactment of a deferred slash.\n       * \n       * Can be called by the `T::SlashCancelOrigin`.\n       * \n       * Parameters: era and indices of the slashes for that era to kill.\n       **/\n      cancelDeferredSlash: AugmentedSubmittable<(era: u32 | AnyNumber | Uint8Array, slashIndices: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>]>;\n      /**\n       * Declare no desire to either validate or nominate.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * # <weight>\n       * - Independent of the arguments. Insignificant complexity.\n       * - Contains one read.\n       * - Writes are limited to the `origin` account key.\n       * # </weight>\n       **/\n      chill: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Declare a `controller` to stop participating as either a validator or nominator.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_, but can be called by anyone.\n       * \n       * If the caller is the same as the controller being targeted, then no further checks are\n       * enforced, and this function behaves just like `chill`.\n       * \n       * If the caller is different than the controller being targeted, the following conditions\n       * must be met:\n       * \n       * * `controller` must belong to a nominator who has become non-decodable,\n       * \n       * Or:\n       * \n       * * A `ChillThreshold` must be set and checked which defines how close to the max\n       * nominators or validators we must reach before users can start chilling one-another.\n       * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine\n       * how close we are to the threshold.\n       * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines\n       * if this is a person that should be chilled because they have not met the threshold\n       * bond required.\n       * \n       * This can be helpful if bond requirements are updated, and we need to remove old users\n       * who do not satisfy these requirements.\n       **/\n      chillOther: AugmentedSubmittable<(controller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Force a validator to have at least the minimum commission. This will not affect a\n       * validator who already has a commission greater than or equal to the minimum. Any account\n       * can call this.\n       **/\n      forceApplyMinCommission: AugmentedSubmittable<(validatorStash: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Force there to be a new era at the end of the next session. After this, it will be\n       * reset to normal (non-forced) behaviour.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # Warning\n       * \n       * The election process starts multiple blocks before the end of the era.\n       * If this is called just before a new era is triggered, the election process may not\n       * have enough blocks to get a result.\n       * \n       * # <weight>\n       * - No arguments.\n       * - Weight: O(1)\n       * - Write ForceEra\n       * # </weight>\n       **/\n      forceNewEra: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Force there to be a new era at the end of sessions indefinitely.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # Warning\n       * \n       * The election process starts multiple blocks before the end of the era.\n       * If this is called just before a new era is triggered, the election process may not\n       * have enough blocks to get a result.\n       **/\n      forceNewEraAlways: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Force there to be no new eras indefinitely.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # Warning\n       * \n       * The election process starts multiple blocks before the end of the era.\n       * Thus the election process may be ongoing when this is called. In this case the\n       * election will continue until the next era is triggered.\n       * \n       * # <weight>\n       * - No arguments.\n       * - Weight: O(1)\n       * - Write: ForceEra\n       * # </weight>\n       **/\n      forceNoEras: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Force a current staker to become completely unstaked, immediately.\n       * \n       * The dispatch origin must be Root.\n       **/\n      forceUnstake: AugmentedSubmittable<(stash: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, u32]>;\n      /**\n       * Increments the ideal number of validators.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # <weight>\n       * Same as [`Self::set_validator_count`].\n       * # </weight>\n       **/\n      increaseValidatorCount: AugmentedSubmittable<(additional: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Remove the given nominations from the calling validator.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * - `who`: A list of nominator stash accounts who are nominating this validator which\n       * should no longer be nominating this validator.\n       * \n       * Note: Making this call only makes sense if you first set the validator preferences to\n       * block any further nominations.\n       **/\n      kick: AugmentedSubmittable<(who: Vec<SeedPrimitivesSignatureAccountId20> | (SeedPrimitivesSignatureAccountId20 | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * Declare the desire to nominate `targets` for the origin controller.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * # <weight>\n       * - The transaction's complexity is proportional to the size of `targets` (N)\n       * which is capped at CompactAssignments::LIMIT (T::MaxNominations).\n       * - Both the reads and writes follow a similar pattern.\n       * # </weight>\n       **/\n      nominate: AugmentedSubmittable<(targets: Vec<SeedPrimitivesSignatureAccountId20> | (SeedPrimitivesSignatureAccountId20 | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * Pay out all the stakers behind a single validator for a single era.\n       * \n       * - `validator_stash` is the stash account of the validator. Their nominators, up to\n       * `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.\n       * - `era` may be any era between `[current_era - history_depth; current_era]`.\n       * \n       * The origin of this call must be _Signed_. Any account can call this function, even if\n       * it is not one of the stakers.\n       * \n       * # <weight>\n       * - Time complexity: at most O(MaxNominatorRewardedPerValidator).\n       * - Contains a limited number of reads and writes.\n       * -----------\n       * N is the Number of payouts for the validator (including the validator)\n       * Weight:\n       * - Reward Destination Staked: O(N)\n       * - Reward Destination Controller (Creating): O(N)\n       * \n       * NOTE: weights are assuming that payouts are made to alive stash account (Staked).\n       * Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.\n       * # </weight>\n       **/\n      payoutStakers: AugmentedSubmittable<(validatorStash: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, era: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, u32]>;\n      /**\n       * Remove all data structures concerning a staker/stash once it is at a state where it can\n       * be considered `dust` in the staking system. The requirements are:\n       * \n       * 1. the `total_balance` of the stash is below existential deposit.\n       * 2. or, the `ledger.total` of the stash is below existential deposit.\n       * \n       * The former can happen in cases like a slash; the latter when a fully unbonded account\n       * is still receiving staking rewards in `RewardDestination::Staked`.\n       * \n       * It can be called by anyone, as long as `stash` meets the above requirements.\n       * \n       * Refunds the transaction fees upon successful execution.\n       **/\n      reapStash: AugmentedSubmittable<(stash: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, u32]>;\n      /**\n       * Rebond a portion of the stash scheduled to be unlocked.\n       * \n       * The dispatch origin must be signed by the controller.\n       * \n       * # <weight>\n       * - Time complexity: O(L), where L is unlocking chunks\n       * - Bounded by `MaxUnlockingChunks`.\n       * - Storage changes: Can't increase storage, only decrease it.\n       * # </weight>\n       **/\n      rebond: AugmentedSubmittable<(value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u128>]>;\n      /**\n       * Scale up the ideal number of validators by a factor.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # <weight>\n       * Same as [`Self::set_validator_count`].\n       * # </weight>\n       **/\n      scaleValidatorCount: AugmentedSubmittable<(factor: Percent | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Percent]>;\n      /**\n       * (Re-)set the controller of a stash.\n       * \n       * Effects will be felt instantly (as soon as this function is completed successfully).\n       * \n       * The dispatch origin for this call must be _Signed_ by the stash, not the controller.\n       * \n       * # <weight>\n       * - Independent of the arguments. Insignificant complexity.\n       * - Contains a limited number of reads.\n       * - Writes are limited to the `origin` account key.\n       * ----------\n       * Weight: O(1)\n       * DB Weight:\n       * - Read: Bonded, Ledger New Controller, Ledger Old Controller\n       * - Write: Bonded, Ledger New Controller, Ledger Old Controller\n       * # </weight>\n       **/\n      setController: AugmentedSubmittable<(controller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Set `HistoryDepth` value. This function will delete any history information\n       * when `HistoryDepth` is reduced.\n       * \n       * Parameters:\n       * - `new_history_depth`: The new history depth you would like to set.\n       * - `era_items_deleted`: The number of items that will be deleted by this dispatch. This\n       * should report all the storage items that will be deleted by clearing old era history.\n       * Needed to report an accurate weight for the dispatch. Trusted by `Root` to report an\n       * accurate number.\n       * \n       * Origin must be root.\n       * \n       * # <weight>\n       * - E: Number of history depths removed, i.e. 10 -> 7 = 3\n       * - Weight: O(E)\n       * - DB Weight:\n       * - Reads: Current Era, History Depth\n       * - Writes: History Depth\n       * - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs\n       * - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake,\n       * ErasStartSessionIndex\n       * # </weight>\n       **/\n      setHistoryDepth: AugmentedSubmittable<(newHistoryDepth: Compact<u32> | AnyNumber | Uint8Array, eraItemsDeleted: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, Compact<u32>]>;\n      /**\n       * Set the validators who cannot be slashed (if any).\n       * \n       * The dispatch origin must be Root.\n       **/\n      setInvulnerables: AugmentedSubmittable<(invulnerables: Vec<SeedPrimitivesSignatureAccountId20> | (SeedPrimitivesSignatureAccountId20 | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * (Re-)set the payment target for a controller.\n       * \n       * Effects will be felt instantly (as soon as this function is completed successfully).\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * # <weight>\n       * - Independent of the arguments. Insignificant complexity.\n       * - Contains a limited number of reads.\n       * - Writes are limited to the `origin` account key.\n       * ---------\n       * - Weight: O(1)\n       * - DB Weight:\n       * - Read: Ledger\n       * - Write: Payee\n       * # </weight>\n       **/\n      setPayee: AugmentedSubmittable<(payee: PalletStakingRewardDestination | { Staked: any } | { Stash: any } | { Controller: any } | { Account: any } | { None: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletStakingRewardDestination]>;\n      /**\n       * Update the various staking configurations .\n       * \n       * * `min_nominator_bond`: The minimum active bond needed to be a nominator.\n       * * `min_validator_bond`: The minimum active bond needed to be a validator.\n       * * `max_nominator_count`: The max number of users who can be a nominator at once. When\n       * set to `None`, no limit is enforced.\n       * * `max_validator_count`: The max number of users who can be a validator at once. When\n       * set to `None`, no limit is enforced.\n       * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which\n       * should be filled in order for the `chill_other` transaction to work.\n       * * `min_commission`: The minimum amount of commission that each validators must maintain.\n       * This is checked only upon calling `validate`. Existing validators are not affected.\n       * \n       * Origin must be Root to call this function.\n       * \n       * NOTE: Existing nominators and validators will not be affected by this update.\n       * to kick people under the new limits, `chill_other` should be called.\n       **/\n      setStakingConfigs: AugmentedSubmittable<(minNominatorBond: PalletStakingPalletConfigOpU128 | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, minValidatorBond: PalletStakingPalletConfigOpU128 | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, maxNominatorCount: PalletStakingPalletConfigOpU32 | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, maxValidatorCount: PalletStakingPalletConfigOpU32 | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, chillThreshold: PalletStakingPalletConfigOpPercent | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, minCommission: PalletStakingPalletConfigOpPerbill | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletStakingPalletConfigOpU128, PalletStakingPalletConfigOpU128, PalletStakingPalletConfigOpU32, PalletStakingPalletConfigOpU32, PalletStakingPalletConfigOpPercent, PalletStakingPalletConfigOpPerbill]>;\n      /**\n       * Sets the ideal number of validators.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # <weight>\n       * Weight: O(1)\n       * Write: Validator Count\n       * # </weight>\n       **/\n      setValidatorCount: AugmentedSubmittable<(updated: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Schedule a portion of the stash to be unlocked ready for transfer out after the bond\n       * period ends. If this leaves an amount actively bonded less than\n       * T::Currency::minimum_balance(), then it is increased to the full amount.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * Once the unlock period is done, you can call `withdraw_unbonded` to actually move\n       * the funds out of management ready for transfer.\n       * \n       * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)\n       * can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need\n       * to be called first to remove some of the chunks (if possible).\n       * \n       * If a user encounters the `InsufficientBond` error when calling this extrinsic,\n       * they should call `chill` first in order to free up their bonded funds.\n       * \n       * Emits `Unbonded`.\n       * \n       * See also [`Call::withdraw_unbonded`].\n       **/\n      unbond: AugmentedSubmittable<(value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u128>]>;\n      /**\n       * Declare the desire to validate for the origin controller.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       **/\n      validate: AugmentedSubmittable<(prefs: PalletStakingValidatorPrefs | { commission?: any; blocked?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletStakingValidatorPrefs]>;\n      /**\n       * Remove any unlocked chunks from the `unlocking` queue from our management.\n       * \n       * This essentially frees up that balance to be used by the stash account to do\n       * whatever it wants.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller.\n       * \n       * Emits `Withdrawn`.\n       * \n       * See also [`Call::unbond`].\n       * \n       * # <weight>\n       * Complexity O(S) where S is the number of slashing spans to remove\n       * NOTE: Weight annotation is the kill scenario, we refund otherwise.\n       * # </weight>\n       **/\n      withdrawUnbonded: AugmentedSubmittable<(numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    sudo: {\n      /**\n       * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo\n       * key.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * # <weight>\n       * - O(1).\n       * - Limited storage reads.\n       * - One DB change.\n       * # </weight>\n       **/\n      setKey: AugmentedSubmittable<(updated: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Authenticates the sudo key and dispatches a function call with `Root` origin.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * # <weight>\n       * - O(1).\n       * - Limited storage reads.\n       * - One DB write (event).\n       * - Weight of derivative `call` execution + 10,000.\n       * # </weight>\n       **/\n      sudo: AugmentedSubmittable<(call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Call]>;\n      /**\n       * Authenticates the sudo key and dispatches a function call with `Signed` origin from\n       * a given account.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * # <weight>\n       * - O(1).\n       * - Limited storage reads.\n       * - One DB write (event).\n       * - Weight of derivative `call` execution + 10,000.\n       * # </weight>\n       **/\n      sudoAs: AugmentedSubmittable<(who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Call]>;\n      /**\n       * Authenticates the sudo key and dispatches a function call with `Root` origin.\n       * This function does not check the weight of the call, and instead allows the\n       * Sudo user to specify the weight of the call.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * # <weight>\n       * - O(1).\n       * - The weight of this call is defined by the caller.\n       * # </weight>\n       **/\n      sudoUncheckedWeight: AugmentedSubmittable<(call: Call | IMethod | string | Uint8Array, weight: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Call, u64]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    system: {\n      /**\n       * A dispatch that will fill the block weight up to the given ratio.\n       **/\n      fillBlock: AugmentedSubmittable<(ratio: Perbill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Perbill]>;\n      /**\n       * Kill all storage items with a key that starts with the given prefix.\n       * \n       * **NOTE:** We rely on the Root origin to provide us the number of subkeys under\n       * the prefix we are removing to accurately calculate the weight of this function.\n       **/\n      killPrefix: AugmentedSubmittable<(prefix: Bytes | string | Uint8Array, subkeys: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, u32]>;\n      /**\n       * Kill some items from storage.\n       **/\n      killStorage: AugmentedSubmittable<(keys: Vec<Bytes> | (Bytes | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Bytes>]>;\n      /**\n       * Make some on-chain remark.\n       * \n       * # <weight>\n       * - `O(1)`\n       * # </weight>\n       **/\n      remark: AugmentedSubmittable<(remark: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Make some on-chain remark and emit event.\n       **/\n      remarkWithEvent: AugmentedSubmittable<(remark: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Set the new runtime code.\n       * \n       * # <weight>\n       * - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`\n       * - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is\n       * expensive).\n       * - 1 storage write (codec `O(C)`).\n       * - 1 digest item.\n       * - 1 event.\n       * The weight of this function is dependent on the runtime, but generally this is very\n       * expensive. We will treat this as a full block.\n       * # </weight>\n       **/\n      setCode: AugmentedSubmittable<(code: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Set the new runtime code without doing any checks of the given `code`.\n       * \n       * # <weight>\n       * - `O(C)` where `C` length of `code`\n       * - 1 storage write (codec `O(C)`).\n       * - 1 digest item.\n       * - 1 event.\n       * The weight of this function is dependent on the runtime. We will treat this as a full\n       * block. # </weight>\n       **/\n      setCodeWithoutChecks: AugmentedSubmittable<(code: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Set the number of pages in the WebAssembly environment's heap.\n       **/\n      setHeapPages: AugmentedSubmittable<(pages: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Set some items of storage.\n       **/\n      setStorage: AugmentedSubmittable<(items: Vec<ITuple<[Bytes, Bytes]>> | ([Bytes | string | Uint8Array, Bytes | string | Uint8Array])[]) => SubmittableExtrinsic<ApiType>, [Vec<ITuple<[Bytes, Bytes]>>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    timestamp: {\n      /**\n       * Set the current time.\n       * \n       * This call should be invoked exactly once per block. It will panic at the finalization\n       * phase, if this call hasn't been invoked by that time.\n       * \n       * The timestamp should be greater than the previous one by the amount specified by\n       * `MinimumPeriod`.\n       * \n       * The dispatch origin for this call must be `Inherent`.\n       * \n       * # <weight>\n       * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)\n       * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in\n       * `on_finalize`)\n       * - 1 event handler `on_timestamp_set`. Must be `O(1)`.\n       * # </weight>\n       **/\n      set: AugmentedSubmittable<(now: Compact<u64> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u64>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    tokenApprovals: {\n      /**\n       * Set approval for an account to transfer an amount of tokens on behalf of the caller\n       * Mapping from caller to spender and amount\n       * mapping(address => mapping(address => uint256)) private _allowances;\n       **/\n      erc20Approval: AugmentedSubmittable<(caller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, spender: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, assetId: u32 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, u32, u128]>;\n      /**\n       * Removes an approval over an account and asset_id\n       * mapping(address => mapping(address => uint256)) private _allowances;\n       **/\n      erc20UpdateApproval: AugmentedSubmittable<(caller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, spender: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, assetId: u32 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, u32, u128]>;\n      /**\n       * Set approval for a single NFT\n       * Mapping from token_id to operator\n       * clears approval on transfer\n       * mapping(uint256 => address) private _tokenApprovals;\n       **/\n      erc721Approval: AugmentedSubmittable<(caller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, operatorAccount: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, ITuple<[u32, u32]>]>;\n      /**\n       * Set approval for an account (or contract) to transfer any tokens from a collection\n       * mapping(address => mapping(address => bool)) private _operatorApprovals;\n       **/\n      erc721ApprovalForAll: AugmentedSubmittable<(caller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, operatorAccount: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, collectionUuid: u32 | AnyNumber | Uint8Array, approved: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, u32, bool]>;\n      /**\n       * Public method which allows users to remove approvals on a token they own\n       **/\n      erc721RemoveApproval: AugmentedSubmittable<(tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => SubmittableExtrinsic<ApiType>, [ITuple<[u32, u32]>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    utility: {\n      /**\n       * Send a call through an indexed pseudonym of the sender.\n       * \n       * Filter from origin are passed along. The call will be dispatched with an origin which\n       * use the same filter as the origin of this call.\n       * \n       * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.\n       * because you expect `proxy` to have been used prior in the call stack and you do not want\n       * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`\n       * in the Multisig pallet instead.\n       * \n       * NOTE: Prior to version *12, this was called `as_limited_sub`.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       **/\n      asDerivative: AugmentedSubmittable<(index: u16 | AnyNumber | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u16, Call]>;\n      /**\n       * Send a batch of dispatch calls.\n       * \n       * May be called from any origin.\n       * \n       * - `calls`: The calls to be dispatched from the same origin. The number of call must not\n       * exceed the constant: `batched_calls_limit` (available in constant metadata).\n       * \n       * If origin is root then call are dispatch without checking origin filter. (This includes\n       * bypassing `frame_system::Config::BaseCallFilter`).\n       * \n       * # <weight>\n       * - Complexity: O(C) where C is the number of calls to be batched.\n       * # </weight>\n       * \n       * This will return `Ok` in all circumstances. To determine the success of the batch, an\n       * event is deposited. If a call failed and the batch was interrupted, then the\n       * `BatchInterrupted` event is deposited, along with the number of successful calls made\n       * and the error of the failed call. If all were successful, then the `BatchCompleted`\n       * event is deposited.\n       **/\n      batch: AugmentedSubmittable<(calls: Vec<Call> | (Call | IMethod | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Call>]>;\n      /**\n       * Send a batch of dispatch calls and atomically execute them.\n       * The whole transaction will rollback and fail if any of the calls failed.\n       * \n       * May be called from any origin.\n       * \n       * - `calls`: The calls to be dispatched from the same origin. The number of call must not\n       * exceed the constant: `batched_calls_limit` (available in constant metadata).\n       * \n       * If origin is root then call are dispatch without checking origin filter. (This includes\n       * bypassing `frame_system::Config::BaseCallFilter`).\n       * \n       * # <weight>\n       * - Complexity: O(C) where C is the number of calls to be batched.\n       * # </weight>\n       **/\n      batchAll: AugmentedSubmittable<(calls: Vec<Call> | (Call | IMethod | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Call>]>;\n      /**\n       * Dispatches a function call with a provided origin.\n       * \n       * The dispatch origin for this call must be _Root_.\n       * \n       * # <weight>\n       * - O(1).\n       * - Limited storage reads.\n       * - One DB write (event).\n       * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().\n       * # </weight>\n       **/\n      dispatchAs: AugmentedSubmittable<(asOrigin: SeedRuntimeOriginCaller | { system: any } | { Void: any } | { Ethereum: any } | string | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedRuntimeOriginCaller, Call]>;\n      /**\n       * Send a batch of dispatch calls.\n       * Unlike `batch`, it allows errors and won't interrupt.\n       * \n       * May be called from any origin.\n       * \n       * - `calls`: The calls to be dispatched from the same origin. The number of call must not\n       * exceed the constant: `batched_calls_limit` (available in constant metadata).\n       * \n       * If origin is root then call are dispatch without checking origin filter. (This includes\n       * bypassing `frame_system::Config::BaseCallFilter`).\n       * \n       * # <weight>\n       * - Complexity: O(C) where C is the number of calls to be batched.\n       * # </weight>\n       **/\n      forceBatch: AugmentedSubmittable<(calls: Vec<Call> | (Call | IMethod | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Call>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    voterList: {\n      /**\n       * Move the caller's Id directly in front of `lighter`.\n       * \n       * The dispatch origin for this call must be _Signed_ and can only be called by the Id of\n       * the account going in front of `lighter`.\n       * \n       * Only works if\n       * - both nodes are within the same bag,\n       * - and `origin` has a greater `Score` than `lighter`.\n       **/\n      putInFrontOf: AugmentedSubmittable<(lighter: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Declare that some `dislocated` account has, through rewards or penalties, sufficiently\n       * changed its score that it should properly fall into a different bag than its current\n       * one.\n       * \n       * Anyone can call this function about any potentially dislocated account.\n       * \n       * Will always update the stored score of `dislocated` to the correct score, based on\n       * `ScoreProvider`.\n       * \n       * If `dislocated` does not exists, it returns an error.\n       **/\n      rebag: AugmentedSubmittable<(dislocated: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    xls20: {\n      /**\n       * Enables XLS-20 compatibility on a collection\n       * - Collection must not have any tokens minted\n       * - Caller must be collection owner\n       **/\n      enableXls20Compatibility: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32]>;\n      /**\n       * Submit XLS-20 token ids to The Root Network\n       * Only callable by the trusted relayer account\n       * Can apply multiple mappings from the same collection in one transaction\n       **/\n      fulfillXls20Mint: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, tokenMappings: Vec<ITuple<[u32, U8aFixed]>> | ([u32 | AnyNumber | Uint8Array, U8aFixed | string | Uint8Array])[]) => SubmittableExtrinsic<ApiType>, [u32, Vec<ITuple<[u32, U8aFixed]>>]>;\n      reRequestXls20Mint: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>]>;\n      /**\n       * Set the relayer address\n       **/\n      setRelayer: AugmentedSubmittable<(relayer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Set the xls20 mint fee which is paid per token by the collection owner\n       * This covers the additional costs incurred by the relayer for the following:\n       * - Minting the token on XRPL\n       * - Calling fulfill_xls20_mint on The Root Network\n       **/\n      setXls20Fee: AugmentedSubmittable<(newFee: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    xrplBridge: {\n      /**\n       * add a relayer\n       **/\n      addRelayer: AugmentedSubmittable<(relayer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * remove a relayer\n       **/\n      removeRelayer: AugmentedSubmittable<(relayer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Set XRPL door address managed by this pallet\n       **/\n      setDoorAddress: AugmentedSubmittable<(doorAddress: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      /**\n       * Set the door tx fee amount\n       **/\n      setDoorTxFee: AugmentedSubmittable<(fee: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Set the door account current ticket sequence params for current allocation - force set\n       **/\n      setTicketSequenceCurrentAllocation: AugmentedSubmittable<(ticketSequence: u32 | AnyNumber | Uint8Array, startTicketSequence: u32 | AnyNumber | Uint8Array, ticketBucketSize: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32, u32]>;\n      /**\n       * Set the door account ticket sequence params for the next allocation\n       **/\n      setTicketSequenceNextAllocation: AugmentedSubmittable<(startTicketSequence: u32 | AnyNumber | Uint8Array, ticketBucketSize: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Submit xrp transaction challenge\n       **/\n      submitChallenge: AugmentedSubmittable<(transactionHash: H512 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H512]>;\n      /**\n       * Submit xrp transaction\n       **/\n      submitTransaction: AugmentedSubmittable<(ledgerIndex: u64 | AnyNumber | Uint8Array, transactionHash: H512 | string | Uint8Array, transaction: PalletXrplBridgeHelpersXrplTxData | { Payment: any } | { CurrencyPayment: any } | { Xls20: any } | string | Uint8Array, timestamp: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64, H512, PalletXrplBridgeHelpersXrplTxData, u64]>;\n      /**\n       * Withdraw xrp transaction\n       **/\n      withdrawXrp: AugmentedSubmittable<(amount: u128 | AnyNumber | Uint8Array, destination: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, H160]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n  } // AugmentedSubmittables\n} // declare module\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/types.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-rpc.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/rpc-core/types/jsonrpc';\n\nimport type { AugmentedRpc } from '@polkadot/rpc-core/types';\nimport type { Metadata, StorageKey } from '@polkadot/types';\nimport type { Bytes, HashMap, Json, Null, Option, Text, U256, U64, Vec, bool, f64, u128, u16, u32, u64 } from '@polkadot/types-codec';\nimport type { AnyNumber, Codec } from '@polkadot/types-codec/types';\nimport type { ExtrinsicOrHash, ExtrinsicStatus } from '@polkadot/types/interfaces/author';\nimport type { EpochAuthorship } from '@polkadot/types/interfaces/babe';\nimport type { BeefySignedCommitment } from '@polkadot/types/interfaces/beefy';\nimport type { BlockHash } from '@polkadot/types/interfaces/chain';\nimport type { PrefixedStorageKey } from '@polkadot/types/interfaces/childstate';\nimport type { AuthorityId } from '@polkadot/types/interfaces/consensus';\nimport type { CodeUploadRequest, CodeUploadResult, ContractCallRequest, ContractExecResult, ContractInstantiateResult, InstantiateRequestV1 } from '@polkadot/types/interfaces/contracts';\nimport type { BlockStats } from '@polkadot/types/interfaces/dev';\nimport type { CreatedBlock } from '@polkadot/types/interfaces/engine';\nimport type { EthAccount, EthCallRequest, EthFeeHistory, EthFilter, EthFilterChanges, EthLog, EthReceipt, EthRichBlock, EthSubKind, EthSubParams, EthSyncStatus, EthTransaction, EthTransactionRequest, EthWork } from '@polkadot/types/interfaces/eth';\nimport type { Extrinsic } from '@polkadot/types/interfaces/extrinsics';\nimport type { EncodedFinalityProofs, JustificationNotification, ReportedRoundStates } from '@polkadot/types/interfaces/grandpa';\nimport type { MmrHash, MmrLeafBatchProof } from '@polkadot/types/interfaces/mmr';\nimport type { StorageKind } from '@polkadot/types/interfaces/offchain';\nimport type { FeeDetails, RuntimeDispatchInfoV1 } from '@polkadot/types/interfaces/payment';\nimport type { RpcMethods } from '@polkadot/types/interfaces/rpc';\nimport type { MigrationStatusResult, ReadProof, RuntimeVersion, TraceBlockResponse } from '@polkadot/types/interfaces/state';\nimport type { ApplyExtrinsicResult, ChainProperties, ChainType, Health, NetworkState, NodeRole, PeerInfo, SyncState } from '@polkadot/types/interfaces/system';\nimport type { IExtrinsic, Observable } from '@polkadot/types/types';\nimport type { EthEventProofResponse, EventProofId } from '@therootnetwork/types/interfaces/ethy';\nimport type { CollectionUuid, SerialNumber, TokenId } from '@therootnetwork/types/interfaces/nft';\nimport type { AccountId, AssetId, Balance, BlockNumber, H160, H256, H64, Hash, Header, Index, Justification, KeyValue, SignedBlock, StorageData } from '@therootnetwork/types/interfaces/runtime';\nimport type { XrplEventProofResponse } from '@therootnetwork/types/interfaces/xrplBridge';\n\nexport type __AugmentedRpc = AugmentedRpc<() => unknown>;\n\ndeclare module '@polkadot/rpc-core/types/jsonrpc' {\n  interface RpcInterface {\n    author: {\n      /**\n       * Returns true if the keystore has private keys for the given public key and key type.\n       **/\n      hasKey: AugmentedRpc<(publicKey: Bytes | string | Uint8Array, keyType: Text | string) => Observable<bool>>;\n      /**\n       * Returns true if the keystore has private keys for the given session public keys.\n       **/\n      hasSessionKeys: AugmentedRpc<(sessionKeys: Bytes | string | Uint8Array) => Observable<bool>>;\n      /**\n       * Insert a key into the keystore.\n       **/\n      insertKey: AugmentedRpc<(keyType: Text | string, suri: Text | string, publicKey: Bytes | string | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Returns all pending extrinsics, potentially grouped by sender\n       **/\n      pendingExtrinsics: AugmentedRpc<() => Observable<Vec<Extrinsic>>>;\n      /**\n       * Remove given extrinsic from the pool and temporarily ban it to prevent reimporting\n       **/\n      removeExtrinsic: AugmentedRpc<(bytesOrHash: Vec<ExtrinsicOrHash> | (ExtrinsicOrHash | { Hash: any } | { Extrinsic: any } | string | Uint8Array)[]) => Observable<Vec<Hash>>>;\n      /**\n       * Generate new session keys and returns the corresponding public keys\n       **/\n      rotateKeys: AugmentedRpc<() => Observable<Bytes>>;\n      /**\n       * Submit and subscribe to watch an extrinsic until unsubscribed\n       **/\n      submitAndWatchExtrinsic: AugmentedRpc<(extrinsic: Extrinsic | IExtrinsic | string | Uint8Array) => Observable<ExtrinsicStatus>>;\n      /**\n       * Submit a fully formatted extrinsic for block inclusion\n       **/\n      submitExtrinsic: AugmentedRpc<(extrinsic: Extrinsic | IExtrinsic | string | Uint8Array) => Observable<Hash>>;\n    };\n    babe: {\n      /**\n       * Returns data about which slots (primary or secondary) can be claimed in the current epoch with the keys in the keystore\n       **/\n      epochAuthorship: AugmentedRpc<() => Observable<HashMap<AuthorityId, EpochAuthorship>>>;\n    };\n    beefy: {\n      /**\n       * Returns hash of the latest BEEFY finalized block as seen by this client.\n       **/\n      getFinalizedHead: AugmentedRpc<() => Observable<H256>>;\n      /**\n       * Returns the block most recently finalized by BEEFY, alongside side its justification.\n       **/\n      subscribeJustifications: AugmentedRpc<() => Observable<BeefySignedCommitment>>;\n    };\n    chain: {\n      /**\n       * Get header and body of a relay chain block\n       **/\n      getBlock: AugmentedRpc<(hash?: BlockHash | string | Uint8Array) => Observable<SignedBlock>>;\n      /**\n       * Get the block hash for a specific block\n       **/\n      getBlockHash: AugmentedRpc<(blockNumber?: BlockNumber | AnyNumber | Uint8Array) => Observable<BlockHash>>;\n      /**\n       * Get hash of the last finalized block in the canon chain\n       **/\n      getFinalizedHead: AugmentedRpc<() => Observable<BlockHash>>;\n      /**\n       * Retrieves the header for a specific block\n       **/\n      getHeader: AugmentedRpc<(hash?: BlockHash | string | Uint8Array) => Observable<Header>>;\n      /**\n       * Retrieves the newest header via subscription\n       **/\n      subscribeAllHeads: AugmentedRpc<() => Observable<Header>>;\n      /**\n       * Retrieves the best finalized header via subscription\n       **/\n      subscribeFinalizedHeads: AugmentedRpc<() => Observable<Header>>;\n      /**\n       * Retrieves the best header via subscription\n       **/\n      subscribeNewHeads: AugmentedRpc<() => Observable<Header>>;\n    };\n    childstate: {\n      /**\n       * Returns the keys with prefix from a child storage, leave empty to get all the keys\n       **/\n      getKeys: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, prefix: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns the keys with prefix from a child storage with pagination support\n       **/\n      getKeysPaged: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, prefix: StorageKey | string | Uint8Array | any, count: u32 | AnyNumber | Uint8Array, startKey?: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns a child storage entry at a specific block state\n       **/\n      getStorage: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Option<StorageData>>>;\n      /**\n       * Returns child storage entries for multiple keys at a specific block state\n       **/\n      getStorageEntries: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], at?: Hash | string | Uint8Array) => Observable<Vec<Option<StorageData>>>>;\n      /**\n       * Returns the hash of a child storage entry at a block state\n       **/\n      getStorageHash: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Option<Hash>>>;\n      /**\n       * Returns the size of a child storage entry at a block state\n       **/\n      getStorageSize: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Option<u64>>>;\n    };\n    contracts: {\n      /**\n       * @deprecated Use the runtime interface `api.call.contractsApi.call` instead\n       * Executes a call to a contract\n       **/\n      call: AugmentedRpc<(callRequest: ContractCallRequest | { origin?: any; dest?: any; value?: any; gasLimit?: any; storageDepositLimit?: any; inputData?: any } | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<ContractExecResult>>;\n      /**\n       * @deprecated Use the runtime interface `api.call.contractsApi.getStorage` instead\n       * Returns the value under a specified storage key in a contract\n       **/\n      getStorage: AugmentedRpc<(address: AccountId | string | Uint8Array, key: H256 | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<Option<Bytes>>>;\n      /**\n       * @deprecated Use the runtime interface `api.call.contractsApi.instantiate` instead\n       * Instantiate a new contract\n       **/\n      instantiate: AugmentedRpc<(request: InstantiateRequestV1 | { origin?: any; value?: any; gasLimit?: any; code?: any; data?: any; salt?: any } | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<ContractInstantiateResult>>;\n      /**\n       * @deprecated Not available in newer versions of the contracts interfaces\n       * Returns the projected time a given contract will be able to sustain paying its rent\n       **/\n      rentProjection: AugmentedRpc<(address: AccountId | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<Option<BlockNumber>>>;\n      /**\n       * @deprecated Use the runtime interface `api.call.contractsApi.uploadCode` instead\n       * Upload new code without instantiating a contract from it\n       **/\n      uploadCode: AugmentedRpc<(uploadRequest: CodeUploadRequest | { origin?: any; code?: any; storageDepositLimit?: any } | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<CodeUploadResult>>;\n    };\n    dev: {\n      /**\n       * Reexecute the specified `block_hash` and gather statistics while doing so\n       **/\n      getBlockStats: AugmentedRpc<(at: Hash | string | Uint8Array) => Observable<Option<BlockStats>>>;\n    };\n    dex: {\n      /**\n       * Given an array of AssetIds, return amounts in for an amount out\n       **/\n      getAmountsIn: AugmentedRpc<(amountOut: Balance | AnyNumber | Uint8Array, path: Vec<AssetId> | (AssetId | AnyNumber | Uint8Array)[]) => Observable<Json>>;\n      /**\n       * Given an array of AssetIds, return amounts out for an amount in\n       **/\n      getAmountsOut: AugmentedRpc<(amountIn: Balance | AnyNumber | Uint8Array, path: Vec<AssetId> | (AssetId | AnyNumber | Uint8Array)[]) => Observable<Json>>;\n      /**\n       * Given two AssetIds, return liquidity token created for the pair\n       **/\n      getLPTokenID: AugmentedRpc<(assetA: AssetId | AnyNumber | Uint8Array, assetB: AssetId | AnyNumber | Uint8Array) => Observable<Json>>;\n      /**\n       * Given two AssetIds, return liquidity\n       **/\n      getLiquidity: AugmentedRpc<(assetA: AssetId | AnyNumber | Uint8Array, assetB: AssetId | AnyNumber | Uint8Array) => Observable<Json>>;\n      /**\n       * Given two AssetIds, return whether trading pair is enabled or disabled\n       **/\n      getTradingPairStatus: AugmentedRpc<(assetA: AssetId | AnyNumber | Uint8Array, assetB: AssetId | AnyNumber | Uint8Array) => Observable<Json>>;\n      /**\n       * Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n       **/\n      quote: AugmentedRpc<(amountA: u128 | AnyNumber | Uint8Array, reserveA: u128 | AnyNumber | Uint8Array, reserveB: u128 | AnyNumber | Uint8Array) => Observable<Json>>;\n    };\n    engine: {\n      /**\n       * Instructs the manual-seal authorship task to create a new block\n       **/\n      createBlock: AugmentedRpc<(createEmpty: bool | boolean | Uint8Array, finalize: bool | boolean | Uint8Array, parentHash?: BlockHash | string | Uint8Array) => Observable<CreatedBlock>>;\n      /**\n       * Instructs the manual-seal authorship task to finalize a block\n       **/\n      finalizeBlock: AugmentedRpc<(hash: BlockHash | string | Uint8Array, justification?: Justification) => Observable<bool>>;\n    };\n    eth: {\n      /**\n       * Returns accounts list.\n       **/\n      accounts: AugmentedRpc<() => Observable<Vec<H160>>>;\n      /**\n       * Returns the blockNumber\n       **/\n      blockNumber: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Call contract, returning the output data.\n       **/\n      call: AugmentedRpc<(request: EthCallRequest | { from?: any; to?: any; gasPrice?: any; gas?: any; value?: any; data?: any; nonce?: any } | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Returns the chain ID used for transaction signing at the current best block. None is returned if not available.\n       **/\n      chainId: AugmentedRpc<() => Observable<U64>>;\n      /**\n       * Returns block author.\n       **/\n      coinbase: AugmentedRpc<() => Observable<H160>>;\n      /**\n       * Estimate gas needed for execution of given contract.\n       **/\n      estimateGas: AugmentedRpc<(request: EthCallRequest | { from?: any; to?: any; gasPrice?: any; gas?: any; value?: any; data?: any; nonce?: any } | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns fee history for given block count & reward percentiles\n       **/\n      feeHistory: AugmentedRpc<(blockCount: U256 | AnyNumber | Uint8Array, newestBlock: BlockNumber | AnyNumber | Uint8Array, rewardPercentiles: Option<Vec<f64>> | null | Uint8Array | Vec<f64> | (f64)[]) => Observable<EthFeeHistory>>;\n      /**\n       * Returns current gas price.\n       **/\n      gasPrice: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns balance of the given account.\n       **/\n      getBalance: AugmentedRpc<(address: H160 | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns block with given hash.\n       **/\n      getBlockByHash: AugmentedRpc<(hash: H256 | string | Uint8Array, full: bool | boolean | Uint8Array) => Observable<Option<EthRichBlock>>>;\n      /**\n       * Returns block with given number.\n       **/\n      getBlockByNumber: AugmentedRpc<(block: BlockNumber | AnyNumber | Uint8Array, full: bool | boolean | Uint8Array) => Observable<Option<EthRichBlock>>>;\n      /**\n       * Returns the number of transactions in a block with given hash.\n       **/\n      getBlockTransactionCountByHash: AugmentedRpc<(hash: H256 | string | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns the number of transactions in a block with given block number.\n       **/\n      getBlockTransactionCountByNumber: AugmentedRpc<(block: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns the code at given address at given time (block number).\n       **/\n      getCode: AugmentedRpc<(address: H160 | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Returns filter changes since last poll.\n       **/\n      getFilterChanges: AugmentedRpc<(index: U256 | AnyNumber | Uint8Array) => Observable<EthFilterChanges>>;\n      /**\n       * Returns all logs matching given filter (in a range 'from' - 'to').\n       **/\n      getFilterLogs: AugmentedRpc<(index: U256 | AnyNumber | Uint8Array) => Observable<Vec<EthLog>>>;\n      /**\n       * Returns logs matching given filter object.\n       **/\n      getLogs: AugmentedRpc<(filter: EthFilter | { fromBlock?: any; toBlock?: any; blockHash?: any; address?: any; topics?: any } | string | Uint8Array) => Observable<Vec<EthLog>>>;\n      /**\n       * Returns proof for account and storage.\n       **/\n      getProof: AugmentedRpc<(address: H160 | string | Uint8Array, storageKeys: Vec<H256> | (H256 | string | Uint8Array)[], number: BlockNumber | AnyNumber | Uint8Array) => Observable<EthAccount>>;\n      /**\n       * Returns content of the storage at given address.\n       **/\n      getStorageAt: AugmentedRpc<(address: H160 | string | Uint8Array, index: U256 | AnyNumber | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<H256>>;\n      /**\n       * Returns transaction at given block hash and index.\n       **/\n      getTransactionByBlockHashAndIndex: AugmentedRpc<(hash: H256 | string | Uint8Array, index: U256 | AnyNumber | Uint8Array) => Observable<EthTransaction>>;\n      /**\n       * Returns transaction by given block number and index.\n       **/\n      getTransactionByBlockNumberAndIndex: AugmentedRpc<(number: BlockNumber | AnyNumber | Uint8Array, index: U256 | AnyNumber | Uint8Array) => Observable<EthTransaction>>;\n      /**\n       * Get transaction by its hash.\n       **/\n      getTransactionByHash: AugmentedRpc<(hash: H256 | string | Uint8Array) => Observable<EthTransaction>>;\n      /**\n       * Returns the number of transactions sent from given address at given time (block number).\n       **/\n      getTransactionCount: AugmentedRpc<(address: H160 | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns transaction receipt by transaction hash.\n       **/\n      getTransactionReceipt: AugmentedRpc<(hash: H256 | string | Uint8Array) => Observable<EthReceipt>>;\n      /**\n       * Returns an uncles at given block and index.\n       **/\n      getUncleByBlockHashAndIndex: AugmentedRpc<(hash: H256 | string | Uint8Array, index: U256 | AnyNumber | Uint8Array) => Observable<EthRichBlock>>;\n      /**\n       * Returns an uncles at given block and index.\n       **/\n      getUncleByBlockNumberAndIndex: AugmentedRpc<(number: BlockNumber | AnyNumber | Uint8Array, index: U256 | AnyNumber | Uint8Array) => Observable<EthRichBlock>>;\n      /**\n       * Returns the number of uncles in a block with given hash.\n       **/\n      getUncleCountByBlockHash: AugmentedRpc<(hash: H256 | string | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns the number of uncles in a block with given block number.\n       **/\n      getUncleCountByBlockNumber: AugmentedRpc<(number: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns the hash of the current block, the seedHash, and the boundary condition to be met.\n       **/\n      getWork: AugmentedRpc<() => Observable<EthWork>>;\n      /**\n       * Returns the number of hashes per second that the node is mining with.\n       **/\n      hashrate: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns max priority fee per gas\n       **/\n      maxPriorityFeePerGas: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns true if client is actively mining new blocks.\n       **/\n      mining: AugmentedRpc<() => Observable<bool>>;\n      /**\n       * Returns id of new block filter.\n       **/\n      newBlockFilter: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns id of new filter.\n       **/\n      newFilter: AugmentedRpc<(filter: EthFilter | { fromBlock?: any; toBlock?: any; blockHash?: any; address?: any; topics?: any } | string | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns id of new block filter.\n       **/\n      newPendingTransactionFilter: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns protocol version encoded as a string (quotes are necessary).\n       **/\n      protocolVersion: AugmentedRpc<() => Observable<u64>>;\n      /**\n       * Sends signed transaction, returning its hash.\n       **/\n      sendRawTransaction: AugmentedRpc<(bytes: Bytes | string | Uint8Array) => Observable<H256>>;\n      /**\n       * Sends transaction; will block waiting for signer to return the transaction hash\n       **/\n      sendTransaction: AugmentedRpc<(tx: EthTransactionRequest | { from?: any; to?: any; gasPrice?: any; gas?: any; value?: any; data?: any; nonce?: any } | string | Uint8Array) => Observable<H256>>;\n      /**\n       * Used for submitting mining hashrate.\n       **/\n      submitHashrate: AugmentedRpc<(index: U256 | AnyNumber | Uint8Array, hash: H256 | string | Uint8Array) => Observable<bool>>;\n      /**\n       * Used for submitting a proof-of-work solution.\n       **/\n      submitWork: AugmentedRpc<(nonce: H64 | string | Uint8Array, headerHash: H256 | string | Uint8Array, mixDigest: H256 | string | Uint8Array) => Observable<bool>>;\n      /**\n       * Subscribe to Eth subscription.\n       **/\n      subscribe: AugmentedRpc<(kind: EthSubKind | 'newHeads' | 'logs' | 'newPendingTransactions' | 'syncing' | number | Uint8Array, params?: EthSubParams | { None: any } | { Logs: any } | string | Uint8Array) => Observable<Null>>;\n      /**\n       * Returns an object with data about the sync status or false.\n       **/\n      syncing: AugmentedRpc<() => Observable<EthSyncStatus>>;\n      /**\n       * Uninstalls filter.\n       **/\n      uninstallFilter: AugmentedRpc<(index: U256 | AnyNumber | Uint8Array) => Observable<bool>>;\n    };\n    ethy: {\n      /**\n       * Get ETH event proof for event Id\n       **/\n      getEventProof: AugmentedRpc<(eventId: EventProofId | AnyNumber | Uint8Array) => Observable<Option<EthEventProofResponse>>>;\n      /**\n       * Get XRPL event proof for event Id\n       **/\n      getXrplTxProof: AugmentedRpc<(eventId: EventProofId | AnyNumber | Uint8Array) => Observable<Option<XrplEventProofResponse>>>;\n      /**\n       * Subscribe to Eth event proof.\n       **/\n      subscribeEventProofs: AugmentedRpc<() => Observable<Null>>;\n    };\n    grandpa: {\n      /**\n       * Prove finality for the given block number, returning the Justification for the last block in the set.\n       **/\n      proveFinality: AugmentedRpc<(blockNumber: BlockNumber | AnyNumber | Uint8Array) => Observable<Option<EncodedFinalityProofs>>>;\n      /**\n       * Returns the state of the current best round state as well as the ongoing background rounds\n       **/\n      roundState: AugmentedRpc<() => Observable<ReportedRoundStates>>;\n      /**\n       * Subscribes to grandpa justifications\n       **/\n      subscribeJustifications: AugmentedRpc<() => Observable<JustificationNotification>>;\n    };\n    mmr: {\n      /**\n       * Generate MMR proof for the given block numbers.\n       **/\n      generateProof: AugmentedRpc<(blockNumbers: Vec<u64> | (u64 | AnyNumber | Uint8Array)[], bestKnownBlockNumber?: u64 | AnyNumber | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<MmrLeafBatchProof>>;\n      /**\n       * Get the MMR root hash for the current best block.\n       **/\n      root: AugmentedRpc<(at?: BlockHash | string | Uint8Array) => Observable<MmrHash>>;\n      /**\n       * Verify an MMR proof\n       **/\n      verifyProof: AugmentedRpc<(proof: MmrLeafBatchProof | { blockHash?: any; leaves?: any; proof?: any } | string | Uint8Array) => Observable<bool>>;\n      /**\n       * Verify an MMR proof statelessly given an mmr_root\n       **/\n      verifyProofStateless: AugmentedRpc<(root: MmrHash | string | Uint8Array, proof: MmrLeafBatchProof | { blockHash?: any; leaves?: any; proof?: any } | string | Uint8Array) => Observable<bool>>;\n    };\n    net: {\n      /**\n       * Returns true if client is actively listening for network connections. Otherwise false.\n       **/\n      listening: AugmentedRpc<() => Observable<bool>>;\n      /**\n       * Returns number of peers connected to node.\n       **/\n      peerCount: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Returns protocol version.\n       **/\n      version: AugmentedRpc<() => Observable<Text>>;\n    };\n    nft: {\n      /**\n       * Get all NFTs owned by an account\n       **/\n      ownedTokens: AugmentedRpc<(collectionId: CollectionUuid | AnyNumber | Uint8Array, who: AccountId | string | Uint8Array, cursor: SerialNumber | AnyNumber | Uint8Array, limit: u16 | AnyNumber | Uint8Array) => Observable<Json>>;\n      /**\n       * Get the URI of a token\n       **/\n      tokenUri: AugmentedRpc<(tokenId: TokenId) => Observable<Json>>;\n    };\n    offchain: {\n      /**\n       * Get offchain local storage under given key and prefix\n       **/\n      localStorageGet: AugmentedRpc<(kind: StorageKind | 'PERSISTENT' | 'LOCAL' | number | Uint8Array, key: Bytes | string | Uint8Array) => Observable<Option<Bytes>>>;\n      /**\n       * Set offchain local storage under given key and prefix\n       **/\n      localStorageSet: AugmentedRpc<(kind: StorageKind | 'PERSISTENT' | 'LOCAL' | number | Uint8Array, key: Bytes | string | Uint8Array, value: Bytes | string | Uint8Array) => Observable<Null>>;\n    };\n    payment: {\n      /**\n       * @deprecated Use `api.call.transactionPaymentApi.queryFeeDetails` instead\n       * Query the detailed fee of a given encoded extrinsic\n       **/\n      queryFeeDetails: AugmentedRpc<(extrinsic: Bytes | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<FeeDetails>>;\n      /**\n       * @deprecated Use `api.call.transactionPaymentApi.queryInfo` instead\n       * Retrieves the fee information for an encoded extrinsic\n       **/\n      queryInfo: AugmentedRpc<(extrinsic: Bytes | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<RuntimeDispatchInfoV1>>;\n    };\n    rpc: {\n      /**\n       * Retrieves the list of RPC methods that are exposed by the node\n       **/\n      methods: AugmentedRpc<() => Observable<RpcMethods>>;\n    };\n    state: {\n      /**\n       * Perform a call to a builtin on the chain\n       **/\n      call: AugmentedRpc<(method: Text | string, data: Bytes | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Retrieves the keys with prefix of a specific child storage\n       **/\n      getChildKeys: AugmentedRpc<(childStorageKey: StorageKey | string | Uint8Array | any, childDefinition: StorageKey | string | Uint8Array | any, childType: u32 | AnyNumber | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns proof of storage for child key entries at a specific block state.\n       **/\n      getChildReadProof: AugmentedRpc<(childStorageKey: PrefixedStorageKey | string | Uint8Array, keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], at?: BlockHash | string | Uint8Array) => Observable<ReadProof>>;\n      /**\n       * Retrieves the child storage for a key\n       **/\n      getChildStorage: AugmentedRpc<(childStorageKey: StorageKey | string | Uint8Array | any, childDefinition: StorageKey | string | Uint8Array | any, childType: u32 | AnyNumber | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<StorageData>>;\n      /**\n       * Retrieves the child storage hash\n       **/\n      getChildStorageHash: AugmentedRpc<(childStorageKey: StorageKey | string | Uint8Array | any, childDefinition: StorageKey | string | Uint8Array | any, childType: u32 | AnyNumber | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Hash>>;\n      /**\n       * Retrieves the child storage size\n       **/\n      getChildStorageSize: AugmentedRpc<(childStorageKey: StorageKey | string | Uint8Array | any, childDefinition: StorageKey | string | Uint8Array | any, childType: u32 | AnyNumber | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<u64>>;\n      /**\n       * @deprecated Use `api.rpc.state.getKeysPaged` to retrieve keys\n       * Retrieves the keys with a certain prefix\n       **/\n      getKeys: AugmentedRpc<(key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns the keys with prefix with pagination support.\n       **/\n      getKeysPaged: AugmentedRpc<(key: StorageKey | string | Uint8Array | any, count: u32 | AnyNumber | Uint8Array, startKey?: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns the runtime metadata\n       **/\n      getMetadata: AugmentedRpc<(at?: BlockHash | string | Uint8Array) => Observable<Metadata>>;\n      /**\n       * @deprecated Use `api.rpc.state.getKeysPaged` to retrieve keys\n       * Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)\n       **/\n      getPairs: AugmentedRpc<(prefix: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Vec<KeyValue>>>;\n      /**\n       * Returns proof of storage entries at a specific block state\n       **/\n      getReadProof: AugmentedRpc<(keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], at?: BlockHash | string | Uint8Array) => Observable<ReadProof>>;\n      /**\n       * Get the runtime version\n       **/\n      getRuntimeVersion: AugmentedRpc<(at?: BlockHash | string | Uint8Array) => Observable<RuntimeVersion>>;\n      /**\n       * Retrieves the storage for a key\n       **/\n      getStorage: AugmentedRpc<<T = Codec>(key: StorageKey | string | Uint8Array | any, block?: Hash | Uint8Array | string) => Observable<T>>;\n      /**\n       * Retrieves the storage hash\n       **/\n      getStorageHash: AugmentedRpc<(key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Hash>>;\n      /**\n       * Retrieves the storage size\n       **/\n      getStorageSize: AugmentedRpc<(key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<u64>>;\n      /**\n       * Query historical storage entries (by key) starting from a start block\n       **/\n      queryStorage: AugmentedRpc<<T = Codec[]>(keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], fromBlock?: Hash | Uint8Array | string, toBlock?: Hash | Uint8Array | string) => Observable<[Hash, T][]>>;\n      /**\n       * Query storage entries (by key) starting at block hash given as the second parameter\n       **/\n      queryStorageAt: AugmentedRpc<<T = Codec[]>(keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], at?: Hash | Uint8Array | string) => Observable<T>>;\n      /**\n       * Retrieves the runtime version via subscription\n       **/\n      subscribeRuntimeVersion: AugmentedRpc<() => Observable<RuntimeVersion>>;\n      /**\n       * Subscribes to storage changes for the provided keys\n       **/\n      subscribeStorage: AugmentedRpc<<T = Codec[]>(keys?: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[]) => Observable<T>>;\n      /**\n       * Provides a way to trace the re-execution of a single block\n       **/\n      traceBlock: AugmentedRpc<(block: Hash | string | Uint8Array, targets: Option<Text> | null | Uint8Array | Text | string, storageKeys: Option<Text> | null | Uint8Array | Text | string, methods: Option<Text> | null | Uint8Array | Text | string) => Observable<TraceBlockResponse>>;\n      /**\n       * Check current migration state\n       **/\n      trieMigrationStatus: AugmentedRpc<(at?: BlockHash | string | Uint8Array) => Observable<MigrationStatusResult>>;\n    };\n    syncstate: {\n      /**\n       * Returns the json-serialized chainspec running the node, with a sync state.\n       **/\n      genSyncSpec: AugmentedRpc<(raw: bool | boolean | Uint8Array) => Observable<Json>>;\n    };\n    system: {\n      /**\n       * Retrieves the next accountIndex as available on the node\n       **/\n      accountNextIndex: AugmentedRpc<(accountId: AccountId | string | Uint8Array) => Observable<Index>>;\n      /**\n       * Adds the supplied directives to the current log filter\n       **/\n      addLogFilter: AugmentedRpc<(directives: Text | string) => Observable<Null>>;\n      /**\n       * Adds a reserved peer\n       **/\n      addReservedPeer: AugmentedRpc<(peer: Text | string) => Observable<Text>>;\n      /**\n       * Retrieves the chain\n       **/\n      chain: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Retrieves the chain type\n       **/\n      chainType: AugmentedRpc<() => Observable<ChainType>>;\n      /**\n       * Dry run an extrinsic at a given block\n       **/\n      dryRun: AugmentedRpc<(extrinsic: Bytes | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<ApplyExtrinsicResult>>;\n      /**\n       * Return health status of the node\n       **/\n      health: AugmentedRpc<() => Observable<Health>>;\n      /**\n       * The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example\n       **/\n      localListenAddresses: AugmentedRpc<() => Observable<Vec<Text>>>;\n      /**\n       * Returns the base58-encoded PeerId of the node\n       **/\n      localPeerId: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Retrieves the node name\n       **/\n      name: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Returns current state of the network\n       **/\n      networkState: AugmentedRpc<() => Observable<NetworkState>>;\n      /**\n       * Returns the roles the node is running as\n       **/\n      nodeRoles: AugmentedRpc<() => Observable<Vec<NodeRole>>>;\n      /**\n       * Returns the currently connected peers\n       **/\n      peers: AugmentedRpc<() => Observable<Vec<PeerInfo>>>;\n      /**\n       * Get a custom set of properties as a JSON object, defined in the chain spec\n       **/\n      properties: AugmentedRpc<() => Observable<ChainProperties>>;\n      /**\n       * Remove a reserved peer\n       **/\n      removeReservedPeer: AugmentedRpc<(peerId: Text | string) => Observable<Text>>;\n      /**\n       * Returns the list of reserved peers\n       **/\n      reservedPeers: AugmentedRpc<() => Observable<Vec<Text>>>;\n      /**\n       * Resets the log filter to Substrate defaults\n       **/\n      resetLogFilter: AugmentedRpc<() => Observable<Null>>;\n      /**\n       * Returns the state of the syncing of the node\n       **/\n      syncState: AugmentedRpc<() => Observable<SyncState>>;\n      /**\n       * Retrieves the version of the node\n       **/\n      version: AugmentedRpc<() => Observable<Text>>;\n    };\n    web3: {\n      /**\n       * Returns current client version.\n       **/\n      clientVersion: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Returns sha3 of the given data\n       **/\n      sha3: AugmentedRpc<(data: Bytes | string | Uint8Array) => Observable<H256>>;\n    };\n  } // RpcInterface\n} // declare module\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/ethy/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/nft/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/xrplBridge/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/ethy/types.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/nft/types.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/types.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/xrplBridge/types.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-runtime.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/api-base/types/calls';\n\nimport type { ApiTypes, AugmentedCall, DecoratedCallBase } from '@polkadot/api-base/types';\nimport type { Bytes, Null, Option, Result, U256, Vec, bool, u256, u32, u64 } from '@polkadot/types-codec';\nimport type { AnyNumber, ITuple } from '@polkadot/types-codec/types';\nimport type { BabeEquivocationProof, BabeGenesisConfiguration, Epoch, OpaqueKeyOwnershipProof } from '@polkadot/types/interfaces/babe';\nimport type { CheckInherentsResult, InherentData } from '@polkadot/types/interfaces/blockbuilder';\nimport type { BlockHash } from '@polkadot/types/interfaces/chain';\nimport type { AuthorityId } from '@polkadot/types/interfaces/consensus';\nimport type { BlockV2, EthReceiptV3, EthTransactionStatus, TransactionV2 } from '@polkadot/types/interfaces/eth';\nimport type { EvmAccount, EvmCallInfo, EvmCreateInfo } from '@polkadot/types/interfaces/evm';\nimport type { Extrinsic } from '@polkadot/types/interfaces/extrinsics';\nimport type { AuthorityList, GrandpaEquivocationProof, SetId } from '@polkadot/types/interfaces/grandpa';\nimport type { OpaqueMetadata } from '@polkadot/types/interfaces/metadata';\nimport type { FeeDetails, RuntimeDispatchInfo } from '@polkadot/types/interfaces/payment';\nimport type { ApplyExtrinsicResult, DispatchError } from '@polkadot/types/interfaces/system';\nimport type { TransactionSource, TransactionValidity } from '@polkadot/types/interfaces/txqueue';\nimport type { IExtrinsic, Observable } from '@polkadot/types/types';\nimport type { AccountId, Block, H160, H256, Header, Index, KeyTypeId, Permill, Slot } from '@therootnetwork/types/interfaces/runtime';\n\nexport type __AugmentedCall<ApiType extends ApiTypes> = AugmentedCall<ApiType>;\nexport type __DecoratedCallBase<ApiType extends ApiTypes> = DecoratedCallBase<ApiType>;\n\ndeclare module '@polkadot/api-base/types/calls' {\n  interface AugmentedCalls<ApiType extends ApiTypes> {\n    /** 0xbc9d89904f5b923f/1 */\n    accountNonceApi: {\n      /**\n       * The API to query account nonce (aka transaction index)\n       **/\n      accountNonce: AugmentedCall<ApiType, (accountId: AccountId | string | Uint8Array) => Observable<Index>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0xcbca25e39f142387/2 */\n    babeApi: {\n      /**\n       * Return the genesis configuration for BABE. The configuration is only read on genesis.\n       **/\n      configuration: AugmentedCall<ApiType, () => Observable<BabeGenesisConfiguration>>;\n      /**\n       * Returns information regarding the current epoch.\n       **/\n      currentEpoch: AugmentedCall<ApiType, () => Observable<Epoch>>;\n      /**\n       * Returns the slot that started the current epoch.\n       **/\n      currentEpochStart: AugmentedCall<ApiType, () => Observable<Slot>>;\n      /**\n       * Generates a proof of key ownership for the given authority in the current epoch.\n       **/\n      generateKeyOwnershipProof: AugmentedCall<ApiType, (slot: Slot | AnyNumber | Uint8Array, authorityId: AuthorityId | string | Uint8Array) => Observable<Option<OpaqueKeyOwnershipProof>>>;\n      /**\n       * Returns information regarding the next epoch (which was already previously announced).\n       **/\n      nextEpoch: AugmentedCall<ApiType, () => Observable<Epoch>>;\n      /**\n       * Submits an unsigned extrinsic to report an equivocation.\n       **/\n      submitReportEquivocationUnsignedExtrinsic: AugmentedCall<ApiType, (equivocationProof: BabeEquivocationProof | { offender?: any; slotNumber?: any; firstHeader?: any; secondHeader?: any } | string | Uint8Array, keyOwnerProof: OpaqueKeyOwnershipProof | string | Uint8Array) => Observable<Option<Null>>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0x40fe3ad401f8959a/6 */\n    blockBuilder: {\n      /**\n       * Apply the given extrinsic.\n       **/\n      applyExtrinsic: AugmentedCall<ApiType, (extrinsic: Extrinsic | IExtrinsic | string | Uint8Array) => Observable<ApplyExtrinsicResult>>;\n      /**\n       * Check that the inherents are valid.\n       **/\n      checkInherents: AugmentedCall<ApiType, (block: Block | { header?: any; extrinsics?: any } | string | Uint8Array, data: InherentData | { data?: any } | string | Uint8Array) => Observable<CheckInherentsResult>>;\n      /**\n       * Finish the current block.\n       **/\n      finalizeBlock: AugmentedCall<ApiType, () => Observable<Header>>;\n      /**\n       * Generate inherent extrinsics.\n       **/\n      inherentExtrinsics: AugmentedCall<ApiType, (inherent: InherentData | { data?: any } | string | Uint8Array) => Observable<Vec<Extrinsic>>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0xe65b00e46cedd0aa/2 */\n    convertTransactionRuntimeApi: {\n      /**\n       * Converts an Ethereum-style transaction to Extrinsic\n       **/\n      convertTransaction: AugmentedCall<ApiType, (transaction: TransactionV2 | { Legacy: any } | { EIP2930: any } | { EIP1559: any } | string | Uint8Array) => Observable<Extrinsic>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0x582211f65bb14b89/4 */\n    ethereumRuntimeRPCApi: {\n      /**\n       * Returns pallet_evm::Accounts by address.\n       **/\n      accountBasic: AugmentedCall<ApiType, (address: H160 | string | Uint8Array) => Observable<EvmAccount>>;\n      /**\n       * For a given account address, returns pallet_evm::AccountCodes.\n       **/\n      accountCodeAt: AugmentedCall<ApiType, (address: H160 | string | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Returns the converted FindAuthor::find_author authority id.\n       **/\n      author: AugmentedCall<ApiType, () => Observable<H160>>;\n      /**\n       * Returns a frame_ethereum::call response. If `estimate` is true,\n       **/\n      call: AugmentedCall<ApiType, (from: H160 | string | Uint8Array, to: H160 | string | Uint8Array, data: Bytes | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: U256 | AnyNumber | Uint8Array, maxFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, maxPriorityFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, nonce: Option<U256> | null | Uint8Array | U256 | AnyNumber, estimate: bool | boolean | Uint8Array, accessList: Option<Vec<ITuple<[H160, Vec<H256>]>>> | null | Uint8Array | Vec<ITuple<[H160, Vec<H256>]>> | ([H160 | string | Uint8Array, Vec<H256> | (H256 | string | Uint8Array)[]])[]) => Observable<Result<EvmCallInfo, DispatchError>>>;\n      /**\n       * Returns runtime defined pallet_evm::ChainId.\n       **/\n      chainId: AugmentedCall<ApiType, () => Observable<u64>>;\n      /**\n       * Returns a frame_ethereum::call response. If `estimate` is true,\n       **/\n      create: AugmentedCall<ApiType, (from: H160 | string | Uint8Array, data: Bytes | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: U256 | AnyNumber | Uint8Array, maxFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, maxPriorityFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, nonce: Option<U256> | null | Uint8Array | U256 | AnyNumber, estimate: bool | boolean | Uint8Array, accessList: Option<Vec<ITuple<[H160, Vec<H256>]>>> | null | Uint8Array | Vec<ITuple<[H160, Vec<H256>]>> | ([H160 | string | Uint8Array, Vec<H256> | (H256 | string | Uint8Array)[]])[]) => Observable<Result<EvmCreateInfo, DispatchError>>>;\n      /**\n       * Return all the current data for a block in a single runtime call.\n       **/\n      currentAll: AugmentedCall<ApiType, () => Observable<ITuple<[Option<BlockV2>, Option<Vec<EthReceiptV3>>, Option<Vec<EthTransactionStatus>>]>>>;\n      /**\n       * Return the current block.\n       **/\n      currentBlock: AugmentedCall<ApiType, () => Observable<BlockV2>>;\n      /**\n       * Return the current receipt.\n       **/\n      currentReceipts: AugmentedCall<ApiType, () => Observable<Option<Vec<EthReceiptV3>>>>;\n      /**\n       * Return the current transaction status.\n       **/\n      currentTransactionStatuses: AugmentedCall<ApiType, () => Observable<Option<Vec<EthTransactionStatus>>>>;\n      /**\n       * Return the elasticity multiplier.\n       **/\n      elasticity: AugmentedCall<ApiType, () => Observable<Option<Permill>>>;\n      /**\n       * Receives a `Vec<OpaqueExtrinsic>` and filters all the ethereum transactions.\n       **/\n      extrinsicFilter: AugmentedCall<ApiType, (xts: Vec<Extrinsic> | (Extrinsic | IExtrinsic | string | Uint8Array)[]) => Observable<Vec<TransactionV2>>>;\n      /**\n       * Returns FixedGasPrice::min_gas_price\n       **/\n      gasPrice: AugmentedCall<ApiType, () => Observable<u256>>;\n      /**\n       * For a given account address and index, returns pallet_evm::AccountStorages.\n       **/\n      storageAt: AugmentedCall<ApiType, (address: H160 | string | Uint8Array, index: u256 | AnyNumber | Uint8Array) => Observable<H256>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0xed99c5acb25eedf5/3 */\n    grandpaApi: {\n      /**\n       * Get current GRANDPA authority set id.\n       **/\n      currentSetId: AugmentedCall<ApiType, () => Observable<SetId>>;\n      /**\n       * Generates a proof of key ownership for the given authority in the given set.\n       **/\n      generateKeyOwnershipProof: AugmentedCall<ApiType, (setId: SetId | AnyNumber | Uint8Array, authorityId: AuthorityId | string | Uint8Array) => Observable<Option<OpaqueKeyOwnershipProof>>>;\n      /**\n       * Get the current GRANDPA authorities and weights. This should not change except for when changes are scheduled and the corresponding delay has passed.\n       **/\n      grandpaAuthorities: AugmentedCall<ApiType, () => Observable<AuthorityList>>;\n      /**\n       * Submits an unsigned extrinsic to report an equivocation.\n       **/\n      submitReportEquivocationUnsignedExtrinsic: AugmentedCall<ApiType, (equivocationProof: GrandpaEquivocationProof | { setId?: any; equivocation?: any } | string | Uint8Array, keyOwnerProof: OpaqueKeyOwnershipProof | string | Uint8Array) => Observable<Option<Null>>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0x37e397fc7c91f5e4/1 */\n    metadata: {\n      /**\n       * Returns the metadata of a runtime\n       **/\n      metadata: AugmentedCall<ApiType, () => Observable<OpaqueMetadata>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0xf78b278be53f454c/2 */\n    offchainWorkerApi: {\n      /**\n       * Starts the off-chain task for given block header.\n       **/\n      offchainWorker: AugmentedCall<ApiType, (header: Header | { parentHash?: any; number?: any; stateRoot?: any; extrinsicsRoot?: any; digest?: any } | string | Uint8Array) => Observable<Null>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0xab3c0572291feb8b/1 */\n    sessionKeys: {\n      /**\n       * Decode the given public session keys.\n       **/\n      decodeSessionKeys: AugmentedCall<ApiType, (encoded: Bytes | string | Uint8Array) => Observable<Option<Vec<ITuple<[Bytes, KeyTypeId]>>>>>;\n      /**\n       * Generate a set of session keys with optionally using the given seed.\n       **/\n      generateSessionKeys: AugmentedCall<ApiType, (seed: Option<Bytes> | null | Uint8Array | Bytes | string) => Observable<Bytes>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0xd2bc9897eed08f15/3 */\n    taggedTransactionQueue: {\n      /**\n       * Validate the transaction.\n       **/\n      validateTransaction: AugmentedCall<ApiType, (source: TransactionSource | 'InBlock' | 'Local' | 'External' | number | Uint8Array, tx: Extrinsic | IExtrinsic | string | Uint8Array, blockHash: BlockHash | string | Uint8Array) => Observable<TransactionValidity>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n    /** 0x37c8bb1350a9a2a8/1 */\n    transactionPaymentApi: {\n      /**\n       * The transaction fee details\n       **/\n      queryFeeDetails: AugmentedCall<ApiType, (uxt: Extrinsic | IExtrinsic | string | Uint8Array, len: u32 | AnyNumber | Uint8Array) => Observable<FeeDetails>>;\n      /**\n       * The transaction info\n       **/\n      queryInfo: AugmentedCall<ApiType, (uxt: Extrinsic | IExtrinsic | string | Uint8Array, len: u32 | AnyNumber | Uint8Array) => Observable<RuntimeDispatchInfo>>;\n      /**\n       * Generic call\n       **/\n      [key: string]: DecoratedCallBase<ApiType>;\n    };\n  } // AugmentedCalls\n} // declare module\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/interfaces/runtime/types.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/lookup/rootnet.ts",{"fileContent":"// Auto-generated via `yarn polkadot-types-from-defs`, do not edit\n/* eslint-disable */\n\n/* eslint-disable sort-keys */\n\nexport default {\n  /**\n   * Lookup0: seed_primitives::signature::AccountId20\n   **/\n  SeedPrimitivesSignatureAccountId20: '[u8;20]',\n  /**\n   * Lookup3: frame_system::AccountInfo<Index, pallet_balances::AccountData<Balance>>\n   **/\n  FrameSystemAccountInfo: {\n    nonce: 'u32',\n    consumers: 'u32',\n    providers: 'u32',\n    sufficients: 'u32',\n    data: 'PalletBalancesAccountData'\n  },\n  /**\n   * Lookup5: pallet_balances::AccountData<Balance>\n   **/\n  PalletBalancesAccountData: {\n    free: 'u128',\n    reserved: 'u128',\n    miscFrozen: 'u128',\n    feeFrozen: 'u128'\n  },\n  /**\n   * Lookup7: frame_support::weights::PerDispatchClass<T>\n   **/\n  FrameSupportWeightsPerDispatchClassU64: {\n    normal: 'u64',\n    operational: 'u64',\n    mandatory: 'u64'\n  },\n  /**\n   * Lookup12: sp_runtime::generic::digest::Digest\n   **/\n  SpRuntimeDigest: {\n    logs: 'Vec<SpRuntimeDigestDigestItem>'\n  },\n  /**\n   * Lookup14: sp_runtime::generic::digest::DigestItem\n   **/\n  SpRuntimeDigestDigestItem: {\n    _enum: {\n      Other: 'Bytes',\n      __Unused1: 'Null',\n      __Unused2: 'Null',\n      __Unused3: 'Null',\n      Consensus: '([u8;4],Bytes)',\n      Seal: '([u8;4],Bytes)',\n      PreRuntime: '([u8;4],Bytes)',\n      __Unused7: 'Null',\n      RuntimeEnvironmentUpdated: 'Null'\n    }\n  },\n  /**\n   * Lookup17: frame_system::EventRecord<seed_runtime::Event, primitive_types::H256>\n   **/\n  FrameSystemEventRecord: {\n    phase: 'FrameSystemPhase',\n    event: 'Event',\n    topics: 'Vec<H256>'\n  },\n  /**\n   * Lookup19: frame_system::pallet::Event<T>\n   **/\n  FrameSystemEvent: {\n    _enum: {\n      ExtrinsicSuccess: {\n        dispatchInfo: 'FrameSupportWeightsDispatchInfo',\n      },\n      ExtrinsicFailed: {\n        dispatchError: 'SpRuntimeDispatchError',\n        dispatchInfo: 'FrameSupportWeightsDispatchInfo',\n      },\n      CodeUpdated: 'Null',\n      NewAccount: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n      },\n      KilledAccount: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n      },\n      Remarked: {\n        _alias: {\n          hash_: 'hash',\n        },\n        sender: 'SeedPrimitivesSignatureAccountId20',\n        hash_: 'H256'\n      }\n    }\n  },\n  /**\n   * Lookup20: frame_support::weights::DispatchInfo\n   **/\n  FrameSupportWeightsDispatchInfo: {\n    weight: 'u64',\n    class: 'FrameSupportWeightsDispatchClass',\n    paysFee: 'FrameSupportWeightsPays'\n  },\n  /**\n   * Lookup21: frame_support::weights::DispatchClass\n   **/\n  FrameSupportWeightsDispatchClass: {\n    _enum: ['Normal', 'Operational', 'Mandatory']\n  },\n  /**\n   * Lookup22: frame_support::weights::Pays\n   **/\n  FrameSupportWeightsPays: {\n    _enum: ['Yes', 'No']\n  },\n  /**\n   * Lookup23: sp_runtime::DispatchError\n   **/\n  SpRuntimeDispatchError: {\n    _enum: {\n      Other: 'Null',\n      CannotLookup: 'Null',\n      BadOrigin: 'Null',\n      Module: 'SpRuntimeModuleError',\n      ConsumerRemaining: 'Null',\n      NoProviders: 'Null',\n      TooManyConsumers: 'Null',\n      Token: 'SpRuntimeTokenError',\n      Arithmetic: 'SpRuntimeArithmeticError',\n      Transactional: 'SpRuntimeTransactionalError'\n    }\n  },\n  /**\n   * Lookup24: sp_runtime::ModuleError\n   **/\n  SpRuntimeModuleError: {\n    index: 'u8',\n    error: '[u8;4]'\n  },\n  /**\n   * Lookup25: sp_runtime::TokenError\n   **/\n  SpRuntimeTokenError: {\n    _enum: ['NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen', 'Unsupported']\n  },\n  /**\n   * Lookup26: sp_runtime::ArithmeticError\n   **/\n  SpRuntimeArithmeticError: {\n    _enum: ['Underflow', 'Overflow', 'DivisionByZero']\n  },\n  /**\n   * Lookup27: sp_runtime::TransactionalError\n   **/\n  SpRuntimeTransactionalError: {\n    _enum: ['LimitReached', 'NoLayer']\n  },\n  /**\n   * Lookup28: pallet_scheduler::pallet::Event<T>\n   **/\n  PalletSchedulerEvent: {\n    _enum: {\n      Scheduled: {\n        when: 'u32',\n        index: 'u32',\n      },\n      Canceled: {\n        when: 'u32',\n        index: 'u32',\n      },\n      Dispatched: {\n        task: '(u32,u32)',\n        id: 'Option<Bytes>',\n        result: 'Result<Null, SpRuntimeDispatchError>',\n      },\n      CallLookupFailed: {\n        task: '(u32,u32)',\n        id: 'Option<Bytes>',\n        error: 'FrameSupportScheduleLookupError'\n      }\n    }\n  },\n  /**\n   * Lookup33: frame_support::traits::schedule::LookupError\n   **/\n  FrameSupportScheduleLookupError: {\n    _enum: ['Unknown', 'BadFormat']\n  },\n  /**\n   * Lookup34: pallet_utility::pallet::Event\n   **/\n  PalletUtilityEvent: {\n    _enum: {\n      BatchInterrupted: {\n        index: 'u32',\n        error: 'SpRuntimeDispatchError',\n      },\n      BatchCompleted: 'Null',\n      BatchCompletedWithErrors: 'Null',\n      ItemCompleted: 'Null',\n      ItemFailed: {\n        error: 'SpRuntimeDispatchError',\n      },\n      DispatchedAs: {\n        result: 'Result<Null, SpRuntimeDispatchError>'\n      }\n    }\n  },\n  /**\n   * Lookup35: pallet_recovery::pallet::Event<T>\n   **/\n  PalletRecoveryEvent: {\n    _enum: {\n      RecoveryCreated: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n      },\n      RecoveryInitiated: {\n        lostAccount: 'SeedPrimitivesSignatureAccountId20',\n        rescuerAccount: 'SeedPrimitivesSignatureAccountId20',\n      },\n      RecoveryVouched: {\n        lostAccount: 'SeedPrimitivesSignatureAccountId20',\n        rescuerAccount: 'SeedPrimitivesSignatureAccountId20',\n        sender: 'SeedPrimitivesSignatureAccountId20',\n      },\n      RecoveryClosed: {\n        lostAccount: 'SeedPrimitivesSignatureAccountId20',\n        rescuerAccount: 'SeedPrimitivesSignatureAccountId20',\n      },\n      AccountRecovered: {\n        lostAccount: 'SeedPrimitivesSignatureAccountId20',\n        rescuerAccount: 'SeedPrimitivesSignatureAccountId20',\n      },\n      RecoveryRemoved: {\n        lostAccount: 'SeedPrimitivesSignatureAccountId20'\n      }\n    }\n  },\n  /**\n   * Lookup36: pallet_balances::pallet::Event<T, I>\n   **/\n  PalletBalancesEvent: {\n    _enum: {\n      Endowed: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n        freeBalance: 'u128',\n      },\n      DustLost: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      Transfer: {\n        from: 'SeedPrimitivesSignatureAccountId20',\n        to: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      BalanceSet: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        free: 'u128',\n        reserved: 'u128',\n      },\n      Reserved: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      Unreserved: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      ReserveRepatriated: {\n        from: 'SeedPrimitivesSignatureAccountId20',\n        to: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n        destinationStatus: 'FrameSupportTokensMiscBalanceStatus',\n      },\n      Deposit: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      Withdraw: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      Slashed: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128'\n      }\n    }\n  },\n  /**\n   * Lookup37: frame_support::traits::tokens::misc::BalanceStatus\n   **/\n  FrameSupportTokensMiscBalanceStatus: {\n    _enum: ['Free', 'Reserved']\n  },\n  /**\n   * Lookup38: pallet_assets::pallet::Event<T, I>\n   **/\n  PalletAssetsEvent: {\n    _enum: {\n      Created: {\n        assetId: 'u32',\n        creator: 'SeedPrimitivesSignatureAccountId20',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      Issued: {\n        assetId: 'u32',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        totalSupply: 'u128',\n      },\n      Transferred: {\n        assetId: 'u32',\n        from: 'SeedPrimitivesSignatureAccountId20',\n        to: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      Burned: {\n        assetId: 'u32',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        balance: 'u128',\n      },\n      TeamChanged: {\n        assetId: 'u32',\n        issuer: 'SeedPrimitivesSignatureAccountId20',\n        admin: 'SeedPrimitivesSignatureAccountId20',\n        freezer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      OwnerChanged: {\n        assetId: 'u32',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      Frozen: {\n        assetId: 'u32',\n        who: 'SeedPrimitivesSignatureAccountId20',\n      },\n      Thawed: {\n        assetId: 'u32',\n        who: 'SeedPrimitivesSignatureAccountId20',\n      },\n      AssetFrozen: {\n        assetId: 'u32',\n      },\n      AssetThawed: {\n        assetId: 'u32',\n      },\n      Destroyed: {\n        assetId: 'u32',\n      },\n      ForceCreated: {\n        assetId: 'u32',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      MetadataSet: {\n        assetId: 'u32',\n        name: 'Bytes',\n        symbol: 'Bytes',\n        decimals: 'u8',\n        isFrozen: 'bool',\n      },\n      MetadataCleared: {\n        assetId: 'u32',\n      },\n      ApprovedTransfer: {\n        assetId: 'u32',\n        source: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      ApprovalCancelled: {\n        assetId: 'u32',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n      },\n      TransferredApproved: {\n        assetId: 'u32',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        destination: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      AssetStatusChanged: {\n        assetId: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup40: pallet_assets_ext::pallet::Event<T>\n   **/\n  PalletAssetsExtEvent: {\n    _enum: {\n      PlaceHold: {\n        assetId: 'u32',\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n        palletId: '[u8;8]',\n      },\n      ReleaseHold: {\n        assetId: 'u32',\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n        palletId: '[u8;8]',\n      },\n      SpendHold: {\n        assetId: 'u32',\n        who: 'SeedPrimitivesSignatureAccountId20',\n        spends: 'Vec<(SeedPrimitivesSignatureAccountId20,u128)>',\n        palletId: '[u8;8]',\n      },\n      SplitTransfer: {\n        assetId: 'u32',\n        who: 'SeedPrimitivesSignatureAccountId20',\n        transfers: 'Vec<(SeedPrimitivesSignatureAccountId20,u128)>',\n      },\n      CreateAsset: {\n        assetId: 'u32',\n        creator: 'SeedPrimitivesSignatureAccountId20',\n        initialBalance: 'u128',\n      },\n      InternalWithdraw: {\n        assetId: 'u32',\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n      },\n      InternalDeposit: {\n        assetId: 'u32',\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128'\n      }\n    }\n  },\n  /**\n   * Lookup44: pallet_staking::pallet::pallet::Event<T>\n   **/\n  PalletStakingPalletEvent: {\n    _enum: {\n      EraPaid: '(u32,u128,u128)',\n      Rewarded: '(SeedPrimitivesSignatureAccountId20,u128)',\n      Slashed: '(SeedPrimitivesSignatureAccountId20,u128)',\n      OldSlashingReportDiscarded: 'u32',\n      StakersElected: 'Null',\n      Bonded: '(SeedPrimitivesSignatureAccountId20,u128)',\n      Unbonded: '(SeedPrimitivesSignatureAccountId20,u128)',\n      Withdrawn: '(SeedPrimitivesSignatureAccountId20,u128)',\n      Kicked: '(SeedPrimitivesSignatureAccountId20,SeedPrimitivesSignatureAccountId20)',\n      StakingElectionFailed: 'Null',\n      Chilled: 'SeedPrimitivesSignatureAccountId20',\n      PayoutStarted: '(u32,SeedPrimitivesSignatureAccountId20)',\n      ValidatorPrefsSet: '(SeedPrimitivesSignatureAccountId20,PalletStakingValidatorPrefs)'\n    }\n  },\n  /**\n   * Lookup45: pallet_staking::ValidatorPrefs\n   **/\n  PalletStakingValidatorPrefs: {\n    commission: 'Compact<Perbill>',\n    blocked: 'bool'\n  },\n  /**\n   * Lookup48: pallet_offences::pallet::Event\n   **/\n  PalletOffencesEvent: {\n    _enum: {\n      Offence: {\n        kind: '[u8;16]',\n        timeslot: 'Bytes'\n      }\n    }\n  },\n  /**\n   * Lookup50: pallet_session::pallet::Event\n   **/\n  PalletSessionEvent: {\n    _enum: {\n      NewSession: {\n        sessionIndex: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup51: pallet_grandpa::pallet::Event\n   **/\n  PalletGrandpaEvent: {\n    _enum: {\n      NewAuthorities: {\n        authoritySet: 'Vec<(SpFinalityGrandpaAppPublic,u64)>',\n      },\n      Paused: 'Null',\n      Resumed: 'Null'\n    }\n  },\n  /**\n   * Lookup54: sp_finality_grandpa::app::Public\n   **/\n  SpFinalityGrandpaAppPublic: 'SpCoreEd25519Public',\n  /**\n   * Lookup55: sp_core::ed25519::Public\n   **/\n  SpCoreEd25519Public: '[u8;32]',\n  /**\n   * Lookup56: pallet_im_online::pallet::Event<T>\n   **/\n  PalletImOnlineEvent: {\n    _enum: {\n      HeartbeatReceived: {\n        authorityId: 'PalletImOnlineSr25519AppSr25519Public',\n      },\n      AllGood: 'Null',\n      SomeOffline: {\n        offline: 'Vec<(SeedPrimitivesSignatureAccountId20,PalletStakingExposure)>'\n      }\n    }\n  },\n  /**\n   * Lookup57: pallet_im_online::sr25519::app_sr25519::Public\n   **/\n  PalletImOnlineSr25519AppSr25519Public: 'SpCoreSr25519Public',\n  /**\n   * Lookup58: sp_core::sr25519::Public\n   **/\n  SpCoreSr25519Public: '[u8;32]',\n  /**\n   * Lookup61: pallet_staking::Exposure<seed_primitives::signature::AccountId20, Balance>\n   **/\n  PalletStakingExposure: {\n    total: 'Compact<u128>',\n    own: 'Compact<u128>',\n    others: 'Vec<PalletStakingIndividualExposure>'\n  },\n  /**\n   * Lookup64: pallet_staking::IndividualExposure<seed_primitives::signature::AccountId20, Balance>\n   **/\n  PalletStakingIndividualExposure: {\n    who: 'SeedPrimitivesSignatureAccountId20',\n    value: 'Compact<u128>'\n  },\n  /**\n   * Lookup65: pallet_sudo::pallet::Event<T>\n   **/\n  PalletSudoEvent: {\n    _enum: {\n      Sudid: {\n        sudoResult: 'Result<Null, SpRuntimeDispatchError>',\n      },\n      KeyChanged: {\n        oldSudoer: 'Option<SeedPrimitivesSignatureAccountId20>',\n      },\n      SudoAsDone: {\n        sudoResult: 'Result<Null, SpRuntimeDispatchError>'\n      }\n    }\n  },\n  /**\n   * Lookup67: pallet_transaction_payment::pallet::Event<T>\n   **/\n  PalletTransactionPaymentEvent: {\n    _enum: {\n      TransactionFeePaid: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        actualFee: 'u128',\n        tip: 'u128'\n      }\n    }\n  },\n  /**\n   * Lookup68: pallet_dex::pallet::Event<T>\n   **/\n  PalletDexEvent: {\n    _enum: {\n      AddProvision: '(SeedPrimitivesSignatureAccountId20,u32,u128,u32,u128)',\n      AddLiquidity: '(SeedPrimitivesSignatureAccountId20,u32,u128,u32,u128,u128)',\n      RemoveLiquidity: '(SeedPrimitivesSignatureAccountId20,u32,u128,u32,u128,u128)',\n      Swap: '(SeedPrimitivesSignatureAccountId20,Vec<u32>,u128,u128)',\n      EnableTradingPair: 'PalletDexTradingPair',\n      DisableTradingPair: 'PalletDexTradingPair',\n      ProvisioningToEnabled: '(PalletDexTradingPair,u128,u128,u128)'\n    }\n  },\n  /**\n   * Lookup70: pallet_dex::types::TradingPair\n   **/\n  PalletDexTradingPair: '(u32,u32)',\n  /**\n   * Lookup71: pallet_nft::pallet::Event<T>\n   **/\n  PalletNftEvent: {\n    _enum: {\n      CollectionCreate: {\n        collectionUuid: 'u32',\n        initialIssuance: 'u32',\n        maxIssuance: 'Option<u32>',\n        collectionOwner: 'SeedPrimitivesSignatureAccountId20',\n        metadataScheme: 'Bytes',\n        name: 'Bytes',\n        royaltiesSchedule: 'Option<PalletNftRoyaltiesSchedule>',\n        originChain: 'PalletNftOriginChain',\n        compatibility: 'PalletNftCrossChainCompatibility',\n      },\n      Mint: {\n        collectionId: 'u32',\n        start: 'u32',\n        end: 'u32',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      BridgedMint: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      OwnerSet: {\n        collectionId: 'u32',\n        newOwner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      MaxIssuanceSet: {\n        collectionId: 'u32',\n        maxIssuance: 'u32',\n      },\n      BaseUriSet: {\n        collectionId: 'u32',\n        baseUri: 'Bytes',\n      },\n      Transfer: {\n        previousOwner: 'SeedPrimitivesSignatureAccountId20',\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        newOwner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      Burn: {\n        collectionId: 'u32',\n        serialNumber: 'u32',\n      },\n      FixedPriceSaleList: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        listingId: 'u128',\n        marketplaceId: 'Option<u32>',\n        price: 'u128',\n        paymentAsset: 'u32',\n        seller: 'SeedPrimitivesSignatureAccountId20',\n      },\n      FixedPriceSaleComplete: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        listingId: 'u128',\n        price: 'u128',\n        paymentAsset: 'u32',\n        buyer: 'SeedPrimitivesSignatureAccountId20',\n        seller: 'SeedPrimitivesSignatureAccountId20',\n      },\n      FixedPriceSaleClose: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        listingId: 'u128',\n        reason: 'PalletNftFixedPriceClosureReason',\n      },\n      FixedPriceSalePriceUpdate: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        listingId: 'u128',\n        newPrice: 'u128',\n      },\n      AuctionOpen: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        paymentAsset: 'u32',\n        reservePrice: 'u128',\n        listingId: 'u128',\n        marketplaceId: 'Option<u32>',\n        seller: 'SeedPrimitivesSignatureAccountId20',\n      },\n      AuctionSold: {\n        collectionId: 'u32',\n        listingId: 'u128',\n        paymentAsset: 'u32',\n        hammerPrice: 'u128',\n        winner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      AuctionClose: {\n        collectionId: 'u32',\n        listingId: 'u128',\n        reason: 'PalletNftAuctionClosureReason',\n      },\n      Bid: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        listingId: 'u128',\n        amount: 'u128',\n        bidder: 'SeedPrimitivesSignatureAccountId20',\n      },\n      MarketplaceRegister: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n        entitlement: 'Permill',\n        marketplaceId: 'u32',\n      },\n      Offer: {\n        offerId: 'u64',\n        amount: 'u128',\n        assetId: 'u32',\n        marketplaceId: 'Option<u32>',\n        buyer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      OfferCancel: {\n        offerId: 'u64',\n        tokenId: '(u32,u32)',\n      },\n      OfferAccept: {\n        offerId: 'u64',\n        tokenId: '(u32,u32)',\n        amount: 'u128',\n        assetId: 'u32',\n      },\n      CollectionClaimed: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n        collectionId: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup76: pallet_nft::types::RoyaltiesSchedule<seed_primitives::signature::AccountId20>\n   **/\n  PalletNftRoyaltiesSchedule: {\n    entitlements: 'Vec<(SeedPrimitivesSignatureAccountId20,Permill)>'\n  },\n  /**\n   * Lookup80: pallet_nft::types::OriginChain\n   **/\n  PalletNftOriginChain: {\n    _enum: ['Ethereum', 'Root']\n  },\n  /**\n   * Lookup81: pallet_nft::types::CrossChainCompatibility\n   **/\n  PalletNftCrossChainCompatibility: {\n    xrpl: 'bool'\n  },\n  /**\n   * Lookup83: pallet_nft::types::FixedPriceClosureReason\n   **/\n  PalletNftFixedPriceClosureReason: {\n    _enum: ['VendorCancelled', 'Expired']\n  },\n  /**\n   * Lookup84: pallet_nft::types::AuctionClosureReason\n   **/\n  PalletNftAuctionClosureReason: {\n    _enum: ['ExpiredNoBids', 'SettlementFailed', 'VendorCancelled']\n  },\n  /**\n   * Lookup85: pallet_xrpl_bridge::pallet::Event<T>\n   **/\n  PalletXrplBridgeEvent: {\n    _enum: {\n      TransactionAdded: '(u64,H512)',\n      TransactionChallenge: '(u64,H512)',\n      ProcessingOk: '(u64,H512)',\n      ProcessingFailed: '(u64,H512,SpRuntimeDispatchError)',\n      NotSupportedTransaction: 'Null',\n      WithdrawRequest: {\n        proofId: 'u64',\n        sender: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128',\n        destination: 'H160',\n      },\n      RelayerAdded: 'SeedPrimitivesSignatureAccountId20',\n      RelayerRemoved: 'SeedPrimitivesSignatureAccountId20',\n      DoorAddressSet: 'H160',\n      DoorNextTicketSequenceParamSet: {\n        ticketSequenceStartNext: 'u32',\n        ticketBucketSizeNext: 'u32',\n      },\n      DoorTicketSequenceParamSet: {\n        ticketSequence: 'u32',\n        ticketSequenceStart: 'u32',\n        ticketBucketSize: 'u32',\n      },\n      TicketSequenceThresholdReached: 'u32'\n    }\n  },\n  /**\n   * Lookup89: pallet_echo::pallet::Event\n   **/\n  PalletEchoEvent: {\n    _enum: {\n      PingSent: {\n        sessionId: 'u64',\n        source: 'H160',\n        destination: 'H160',\n        eventProofId: 'u64',\n      },\n      PongReceived: {\n        sessionId: 'u64',\n        source: 'H160',\n        data: 'Bytes',\n      },\n      PingReceived: {\n        sessionId: 'u64',\n        source: 'H160',\n        data: 'Bytes',\n      },\n      PongSent: {\n        sessionId: 'u64',\n        source: 'H160',\n        destination: 'H160',\n        eventProofId: 'u64'\n      }\n    }\n  },\n  /**\n   * Lookup90: pallet_election_provider_multi_phase::pallet::Event<T>\n   **/\n  PalletElectionProviderMultiPhaseEvent: {\n    _enum: {\n      SolutionStored: {\n        electionCompute: 'PalletElectionProviderMultiPhaseElectionCompute',\n        prevEjected: 'bool',\n      },\n      ElectionFinalized: {\n        electionCompute: 'Option<PalletElectionProviderMultiPhaseElectionCompute>',\n      },\n      Rewarded: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n        value: 'u128',\n      },\n      Slashed: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n        value: 'u128',\n      },\n      SignedPhaseStarted: {\n        round: 'u32',\n      },\n      UnsignedPhaseStarted: {\n        round: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup91: pallet_election_provider_multi_phase::ElectionCompute\n   **/\n  PalletElectionProviderMultiPhaseElectionCompute: {\n    _enum: ['OnChain', 'Signed', 'Unsigned', 'Fallback', 'Emergency']\n  },\n  /**\n   * Lookup93: pallet_bags_list::pallet::Event<T, I>\n   **/\n  PalletBagsListEvent: {\n    _enum: {\n      Rebagged: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        from: 'u64',\n        to: 'u64',\n      },\n      ScoreUpdated: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        newScore: 'u64'\n      }\n    }\n  },\n  /**\n   * Lookup94: pallet_ethy::RawEvent<seed_primitives::signature::AccountId20, BlockNumber>\n   **/\n  PalletEthyRawEvent: {\n    _enum: {\n      Verified: 'u64',\n      Invalid: 'u64',\n      AuthoritySetChange: '(u64,u64)',\n      XrplAuthoritySetChange: '(u64,u64)',\n      ProofDelayed: 'u64',\n      ProcessingOk: 'u64',\n      ProcessingFailed: '(u64,SeedPalletCommonEventRouterError)',\n      Challenged: '(u64,SeedPrimitivesSignatureAccountId20)',\n      ProcessAtExtended: '(u64,u32)',\n      EventSend: {\n        eventProofId: 'u64',\n        signingRequest: 'PalletEthyEthySigningRequest',\n      },\n      EventSubmit: '(u64,PalletEthyEventClaim,u32)',\n      RelayerBondDeposit: '(SeedPrimitivesSignatureAccountId20,u128)',\n      RelayerBondWithdraw: '(SeedPrimitivesSignatureAccountId20,u128)',\n      RelayerSet: 'Option<SeedPrimitivesSignatureAccountId20>',\n      XrplDoorSignersSet: 'Null',\n      FinaliseScheduleFail: 'u32',\n      SetContractAddress: 'H160',\n      XrplAuthoritySetChangeRequestFailed: 'Null'\n    }\n  },\n  /**\n   * Lookup95: seed_pallet_common::EventRouterError\n   **/\n  SeedPalletCommonEventRouterError: {\n    _enum: {\n      FailedProcessing: 'SpRuntimeDispatchError',\n      NoReceiver: 'Null'\n    }\n  },\n  /**\n   * Lookup96: pallet_ethy::types::EthySigningRequest\n   **/\n  PalletEthyEthySigningRequest: {\n    _enum: {\n      Ethereum: 'PalletEthyEthereumEventInfo',\n      XrplTx: 'Bytes'\n    }\n  },\n  /**\n   * Lookup97: pallet_ethy::types::EthereumEventInfo\n   **/\n  PalletEthyEthereumEventInfo: {\n    source: 'H160',\n    destination: 'H160',\n    message: 'Bytes',\n    validatorSetId: 'u64',\n    eventProofId: 'u64'\n  },\n  /**\n   * Lookup98: pallet_ethy::types::EventClaim\n   **/\n  PalletEthyEventClaim: {\n    txHash: 'H256',\n    source: 'H160',\n    destination: 'H160',\n    data: 'Bytes'\n  },\n  /**\n   * Lookup99: pallet_ethereum::pallet::Event\n   **/\n  PalletEthereumEvent: {\n    _enum: {\n      Executed: {\n        from: 'H160',\n        to: 'H160',\n        transactionHash: 'H256',\n        exitReason: 'EvmCoreErrorExitReason'\n      }\n    }\n  },\n  /**\n   * Lookup100: evm_core::error::ExitReason\n   **/\n  EvmCoreErrorExitReason: {\n    _enum: {\n      Succeed: 'EvmCoreErrorExitSucceed',\n      Error: 'EvmCoreErrorExitError',\n      Revert: 'EvmCoreErrorExitRevert',\n      Fatal: 'EvmCoreErrorExitFatal'\n    }\n  },\n  /**\n   * Lookup101: evm_core::error::ExitSucceed\n   **/\n  EvmCoreErrorExitSucceed: {\n    _enum: ['Stopped', 'Returned', 'Suicided']\n  },\n  /**\n   * Lookup102: evm_core::error::ExitError\n   **/\n  EvmCoreErrorExitError: {\n    _enum: {\n      StackUnderflow: 'Null',\n      StackOverflow: 'Null',\n      InvalidJump: 'Null',\n      InvalidRange: 'Null',\n      DesignatedInvalid: 'Null',\n      CallTooDeep: 'Null',\n      CreateCollision: 'Null',\n      CreateContractLimit: 'Null',\n      OutOfOffset: 'Null',\n      OutOfGas: 'Null',\n      OutOfFund: 'Null',\n      PCUnderflow: 'Null',\n      CreateEmpty: 'Null',\n      Other: 'Text',\n      InvalidCode: 'Null'\n    }\n  },\n  /**\n   * Lookup105: evm_core::error::ExitRevert\n   **/\n  EvmCoreErrorExitRevert: {\n    _enum: ['Reverted']\n  },\n  /**\n   * Lookup106: evm_core::error::ExitFatal\n   **/\n  EvmCoreErrorExitFatal: {\n    _enum: {\n      NotSupported: 'Null',\n      UnhandledInterrupt: 'Null',\n      CallErrorAsFatal: 'EvmCoreErrorExitError',\n      Other: 'Text'\n    }\n  },\n  /**\n   * Lookup107: pallet_evm::pallet::Event<T>\n   **/\n  PalletEvmEvent: {\n    _enum: {\n      Log: {\n        log: 'EthereumLog',\n      },\n      Created: {\n        address: 'H160',\n      },\n      CreatedFailed: {\n        address: 'H160',\n      },\n      Executed: {\n        address: 'H160',\n      },\n      ExecutedFailed: {\n        address: 'H160'\n      }\n    }\n  },\n  /**\n   * Lookup108: ethereum::log::Log\n   **/\n  EthereumLog: {\n    address: 'H160',\n    topics: 'Vec<H256>',\n    data: 'Bytes'\n  },\n  /**\n   * Lookup110: pallet_evm_chain_id::pallet::Event<T>\n   **/\n  PalletEvmChainIdEvent: {\n    _enum: {\n      ChainIdSet: 'u64'\n    }\n  },\n  /**\n   * Lookup111: pallet_erc20_peg::RawEvent<seed_primitives::signature::AccountId20, BlockNumber>\n   **/\n  PalletErc20PegRawEvent: {\n    _enum: {\n      Erc20DepositDelayed: '(u64,u32,u128,SeedPrimitivesSignatureAccountId20)',\n      Erc20WithdrawalDelayed: '(u64,u32,u128,H160)',\n      DelayedErc20DepositFailed: '(u64,SeedPrimitivesSignatureAccountId20)',\n      DelayedErc20WithdrawalFailed: '(u32,H160)',\n      Erc20Deposit: '(u32,u128,SeedPrimitivesSignatureAccountId20)',\n      Erc20Withdraw: '(u32,u128,H160)',\n      Erc20DepositFail: '(H160,Bytes)',\n      SetContractAddress: 'H160',\n      PaymentDelaySet: '(u32,u128,u32)',\n      NoAvailableDelayedPaymentIds: 'Null'\n    }\n  },\n  /**\n   * Lookup112: pallet_nft_peg::pallet::Event<T>\n   **/\n  PalletNftPegEvent: {\n    _enum: {\n      Erc721Deposit: {\n        destination: 'SeedPrimitivesSignatureAccountId20',\n      },\n      Erc721Mint: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      Erc721Withdraw: {\n        origin: 'SeedPrimitivesSignatureAccountId20',\n        collectionIds: 'Vec<u32>',\n        serialNumbers: 'Vec<Vec<u32>>',\n        destination: 'H160',\n      },\n      ContractAddressSet: {\n        contract: 'H160'\n      }\n    }\n  },\n  /**\n   * Lookup118: pallet_fee_proxy::pallet::Event<T>\n   **/\n  PalletFeeProxyEvent: {\n    _enum: {\n      CallWithFeePreferences: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        paymentAsset: 'u32',\n        maxPayment: 'u128'\n      }\n    }\n  },\n  /**\n   * Lookup119: pallet_fee_control::pallet::Event<T>\n   **/\n  PalletFeeControlEvent: 'Null',\n  /**\n   * Lookup120: pallet_xls20::pallet::Event<T>\n   **/\n  PalletXls20Event: {\n    _enum: {\n      Xls20MintRequest: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        tokenUris: 'Vec<Bytes>',\n      },\n      RelayerSet: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n      },\n      Xls20MintFeeSet: {\n        newFee: 'u128',\n      },\n      Xls20MappingSet: {\n        collectionId: 'u32',\n        mappings: 'Vec<(u32,[u8;64])>',\n      },\n      Xls20CompatibilityEnabled: {\n        collectionId: 'u32',\n      },\n      Xls20MintFeePaid: {\n        collectionOwner: 'SeedPrimitivesSignatureAccountId20',\n        totalFee: 'u128'\n      }\n    }\n  },\n  /**\n   * Lookup124: pallet_proxy::pallet::Event<T>\n   **/\n  PalletProxyEvent: {\n    _enum: {\n      ProxyExecuted: {\n        result: 'Result<Null, SpRuntimeDispatchError>',\n      },\n      AnonymousCreated: {\n        anonymous: 'SeedPrimitivesSignatureAccountId20',\n        who: 'SeedPrimitivesSignatureAccountId20',\n        proxyType: 'SeedRuntimeImplsProxyType',\n        disambiguationIndex: 'u16',\n      },\n      Announced: {\n        real: 'SeedPrimitivesSignatureAccountId20',\n        proxy: 'SeedPrimitivesSignatureAccountId20',\n        callHash: 'H256',\n      },\n      ProxyAdded: {\n        delegator: 'SeedPrimitivesSignatureAccountId20',\n        delegatee: 'SeedPrimitivesSignatureAccountId20',\n        proxyType: 'SeedRuntimeImplsProxyType',\n        delay: 'u32',\n      },\n      ProxyRemoved: {\n        delegator: 'SeedPrimitivesSignatureAccountId20',\n        delegatee: 'SeedPrimitivesSignatureAccountId20',\n        proxyType: 'SeedRuntimeImplsProxyType',\n        delay: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup125: seed_runtime::impls::ProxyType\n   **/\n  SeedRuntimeImplsProxyType: {\n    _enum: ['NoPermission', 'Any', 'NonTransfer', 'Governance', 'Staking']\n  },\n  /**\n   * Lookup127: pallet_futurepass::pallet::Event<T>\n   **/\n  PalletFuturepassEvent: {\n    _enum: {\n      FuturepassCreated: {\n        futurepass: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n      },\n      DelegateRegistered: {\n        futurepass: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        proxyType: 'SeedRuntimeImplsProxyType',\n      },\n      DelegateUnregistered: {\n        futurepass: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n      },\n      FuturepassTransferred: {\n        oldOwner: 'SeedPrimitivesSignatureAccountId20',\n        newOwner: 'SeedPrimitivesSignatureAccountId20',\n        futurepass: 'SeedPrimitivesSignatureAccountId20',\n      },\n      DefaultFuturepassSet: {\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        futurepass: 'Option<SeedPrimitivesSignatureAccountId20>',\n      },\n      ProxyExecuted: {\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        result: 'Result<Null, SpRuntimeDispatchError>',\n      },\n      FuturepassAssetsMigrated: {\n        evmFuturepass: 'SeedPrimitivesSignatureAccountId20',\n        futurepass: 'SeedPrimitivesSignatureAccountId20',\n        collectionId: 'u32',\n      },\n      FuturepassMigratorSet: {\n        migrator: 'SeedPrimitivesSignatureAccountId20'\n      }\n    }\n  },\n  /**\n   * Lookup128: frame_system::Phase\n   **/\n  FrameSystemPhase: {\n    _enum: {\n      ApplyExtrinsic: 'u32',\n      Finalization: 'Null',\n      Initialization: 'Null'\n    }\n  },\n  /**\n   * Lookup130: frame_system::LastRuntimeUpgradeInfo\n   **/\n  FrameSystemLastRuntimeUpgradeInfo: {\n    specVersion: 'Compact<u32>',\n    specName: 'Text'\n  },\n  /**\n   * Lookup132: frame_system::pallet::Call<T>\n   **/\n  FrameSystemCall: {\n    _enum: {\n      fill_block: {\n        ratio: 'Perbill',\n      },\n      remark: {\n        remark: 'Bytes',\n      },\n      set_heap_pages: {\n        pages: 'u64',\n      },\n      set_code: {\n        code: 'Bytes',\n      },\n      set_code_without_checks: {\n        code: 'Bytes',\n      },\n      set_storage: {\n        items: 'Vec<(Bytes,Bytes)>',\n      },\n      kill_storage: {\n        _alias: {\n          keys_: 'keys',\n        },\n        keys_: 'Vec<Bytes>',\n      },\n      kill_prefix: {\n        prefix: 'Bytes',\n        subkeys: 'u32',\n      },\n      remark_with_event: {\n        remark: 'Bytes'\n      }\n    }\n  },\n  /**\n   * Lookup135: frame_system::limits::BlockWeights\n   **/\n  FrameSystemLimitsBlockWeights: {\n    baseBlock: 'u64',\n    maxBlock: 'u64',\n    perClass: 'FrameSupportWeightsPerDispatchClassWeightsPerClass'\n  },\n  /**\n   * Lookup136: frame_support::weights::PerDispatchClass<frame_system::limits::WeightsPerClass>\n   **/\n  FrameSupportWeightsPerDispatchClassWeightsPerClass: {\n    normal: 'FrameSystemLimitsWeightsPerClass',\n    operational: 'FrameSystemLimitsWeightsPerClass',\n    mandatory: 'FrameSystemLimitsWeightsPerClass'\n  },\n  /**\n   * Lookup137: frame_system::limits::WeightsPerClass\n   **/\n  FrameSystemLimitsWeightsPerClass: {\n    baseExtrinsic: 'u64',\n    maxExtrinsic: 'Option<u64>',\n    maxTotal: 'Option<u64>',\n    reserved: 'Option<u64>'\n  },\n  /**\n   * Lookup139: frame_system::limits::BlockLength\n   **/\n  FrameSystemLimitsBlockLength: {\n    max: 'FrameSupportWeightsPerDispatchClassU32'\n  },\n  /**\n   * Lookup140: frame_support::weights::PerDispatchClass<T>\n   **/\n  FrameSupportWeightsPerDispatchClassU32: {\n    normal: 'u32',\n    operational: 'u32',\n    mandatory: 'u32'\n  },\n  /**\n   * Lookup141: frame_support::weights::RuntimeDbWeight\n   **/\n  FrameSupportWeightsRuntimeDbWeight: {\n    read: 'u64',\n    write: 'u64'\n  },\n  /**\n   * Lookup142: sp_version::RuntimeVersion\n   **/\n  SpVersionRuntimeVersion: {\n    specName: 'Text',\n    implName: 'Text',\n    authoringVersion: 'u32',\n    specVersion: 'u32',\n    implVersion: 'u32',\n    apis: 'Vec<([u8;8],u32)>',\n    transactionVersion: 'u32',\n    stateVersion: 'u8'\n  },\n  /**\n   * Lookup146: frame_system::pallet::Error<T>\n   **/\n  FrameSystemError: {\n    _enum: ['InvalidSpecName', 'SpecVersionNeedsToIncrease', 'FailedToExtractRuntimeVersion', 'NonDefaultComposite', 'NonZeroRefCount', 'CallFiltered']\n  },\n  /**\n   * Lookup149: sp_consensus_babe::app::Public\n   **/\n  SpConsensusBabeAppPublic: 'SpCoreSr25519Public',\n  /**\n   * Lookup152: sp_consensus_babe::digests::NextConfigDescriptor\n   **/\n  SpConsensusBabeDigestsNextConfigDescriptor: {\n    _enum: {\n      __Unused0: 'Null',\n      V1: {\n        c: '(u64,u64)',\n        allowedSlots: 'SpConsensusBabeAllowedSlots'\n      }\n    }\n  },\n  /**\n   * Lookup154: sp_consensus_babe::AllowedSlots\n   **/\n  SpConsensusBabeAllowedSlots: {\n    _enum: ['PrimarySlots', 'PrimaryAndSecondaryPlainSlots', 'PrimaryAndSecondaryVRFSlots']\n  },\n  /**\n   * Lookup158: sp_consensus_babe::digests::PreDigest\n   **/\n  SpConsensusBabeDigestsPreDigest: {\n    _enum: {\n      __Unused0: 'Null',\n      Primary: 'SpConsensusBabeDigestsPrimaryPreDigest',\n      SecondaryPlain: 'SpConsensusBabeDigestsSecondaryPlainPreDigest',\n      SecondaryVRF: 'SpConsensusBabeDigestsSecondaryVRFPreDigest'\n    }\n  },\n  /**\n   * Lookup159: sp_consensus_babe::digests::PrimaryPreDigest\n   **/\n  SpConsensusBabeDigestsPrimaryPreDigest: {\n    authorityIndex: 'u32',\n    slot: 'u64',\n    vrfOutput: '[u8;32]',\n    vrfProof: '[u8;64]'\n  },\n  /**\n   * Lookup160: sp_consensus_babe::digests::SecondaryPlainPreDigest\n   **/\n  SpConsensusBabeDigestsSecondaryPlainPreDigest: {\n    authorityIndex: 'u32',\n    slot: 'u64'\n  },\n  /**\n   * Lookup161: sp_consensus_babe::digests::SecondaryVRFPreDigest\n   **/\n  SpConsensusBabeDigestsSecondaryVRFPreDigest: {\n    authorityIndex: 'u32',\n    slot: 'u64',\n    vrfOutput: '[u8;32]',\n    vrfProof: '[u8;64]'\n  },\n  /**\n   * Lookup163: sp_consensus_babe::BabeEpochConfiguration\n   **/\n  SpConsensusBabeBabeEpochConfiguration: {\n    c: '(u64,u64)',\n    allowedSlots: 'SpConsensusBabeAllowedSlots'\n  },\n  /**\n   * Lookup164: pallet_babe::pallet::Call<T>\n   **/\n  PalletBabeCall: {\n    _enum: {\n      report_equivocation: {\n        equivocationProof: 'SpConsensusSlotsEquivocationProof',\n        keyOwnerProof: 'SpSessionMembershipProof',\n      },\n      report_equivocation_unsigned: {\n        equivocationProof: 'SpConsensusSlotsEquivocationProof',\n        keyOwnerProof: 'SpSessionMembershipProof',\n      },\n      plan_config_change: {\n        config: 'SpConsensusBabeDigestsNextConfigDescriptor'\n      }\n    }\n  },\n  /**\n   * Lookup165: sp_consensus_slots::EquivocationProof<sp_runtime::generic::header::Header<Number, sp_runtime::traits::BlakeTwo256>, sp_consensus_babe::app::Public>\n   **/\n  SpConsensusSlotsEquivocationProof: {\n    offender: 'SpConsensusBabeAppPublic',\n    slot: 'u64',\n    firstHeader: 'SpRuntimeHeader',\n    secondHeader: 'SpRuntimeHeader'\n  },\n  /**\n   * Lookup166: sp_runtime::generic::header::Header<Number, sp_runtime::traits::BlakeTwo256>\n   **/\n  SpRuntimeHeader: {\n    parentHash: 'H256',\n    number: 'Compact<u32>',\n    stateRoot: 'H256',\n    extrinsicsRoot: 'H256',\n    digest: 'SpRuntimeDigest'\n  },\n  /**\n   * Lookup167: sp_runtime::traits::BlakeTwo256\n   **/\n  SpRuntimeBlakeTwo256: 'Null',\n  /**\n   * Lookup168: sp_session::MembershipProof\n   **/\n  SpSessionMembershipProof: {\n    session: 'u32',\n    trieNodes: 'Vec<Bytes>',\n    validatorCount: 'u32'\n  },\n  /**\n   * Lookup169: pallet_babe::pallet::Error<T>\n   **/\n  PalletBabeError: {\n    _enum: ['InvalidEquivocationProof', 'InvalidKeyOwnershipProof', 'DuplicateOffenceReport', 'InvalidConfiguration']\n  },\n  /**\n   * Lookup170: pallet_timestamp::pallet::Call<T>\n   **/\n  PalletTimestampCall: {\n    _enum: {\n      set: {\n        now: 'Compact<u64>'\n      }\n    }\n  },\n  /**\n   * Lookup174: pallet_scheduler::ScheduledV3<frame_support::traits::schedule::MaybeHashed<seed_runtime::Call, primitive_types::H256>, BlockNumber, seed_runtime::OriginCaller, seed_primitives::signature::AccountId20>\n   **/\n  PalletSchedulerScheduledV3: {\n    maybeId: 'Option<Bytes>',\n    priority: 'u8',\n    call: 'FrameSupportScheduleMaybeHashed',\n    maybePeriodic: 'Option<(u32,u32)>',\n    origin: 'SeedRuntimeOriginCaller'\n  },\n  /**\n   * Lookup175: frame_support::traits::schedule::MaybeHashed<seed_runtime::Call, primitive_types::H256>\n   **/\n  FrameSupportScheduleMaybeHashed: {\n    _enum: {\n      Value: 'Call',\n      Hash: 'H256'\n    }\n  },\n  /**\n   * Lookup177: pallet_scheduler::pallet::Call<T>\n   **/\n  PalletSchedulerCall: {\n    _enum: {\n      schedule: {\n        when: 'u32',\n        maybePeriodic: 'Option<(u32,u32)>',\n        priority: 'u8',\n        call: 'FrameSupportScheduleMaybeHashed',\n      },\n      cancel: {\n        when: 'u32',\n        index: 'u32',\n      },\n      schedule_named: {\n        id: 'Bytes',\n        when: 'u32',\n        maybePeriodic: 'Option<(u32,u32)>',\n        priority: 'u8',\n        call: 'FrameSupportScheduleMaybeHashed',\n      },\n      cancel_named: {\n        id: 'Bytes',\n      },\n      schedule_after: {\n        after: 'u32',\n        maybePeriodic: 'Option<(u32,u32)>',\n        priority: 'u8',\n        call: 'FrameSupportScheduleMaybeHashed',\n      },\n      schedule_named_after: {\n        id: 'Bytes',\n        after: 'u32',\n        maybePeriodic: 'Option<(u32,u32)>',\n        priority: 'u8',\n        call: 'FrameSupportScheduleMaybeHashed'\n      }\n    }\n  },\n  /**\n   * Lookup179: pallet_utility::pallet::Call<T>\n   **/\n  PalletUtilityCall: {\n    _enum: {\n      batch: {\n        calls: 'Vec<Call>',\n      },\n      as_derivative: {\n        index: 'u16',\n        call: 'Call',\n      },\n      batch_all: {\n        calls: 'Vec<Call>',\n      },\n      dispatch_as: {\n        asOrigin: 'SeedRuntimeOriginCaller',\n        call: 'Call',\n      },\n      force_batch: {\n        calls: 'Vec<Call>'\n      }\n    }\n  },\n  /**\n   * Lookup181: seed_runtime::OriginCaller\n   **/\n  SeedRuntimeOriginCaller: {\n    _enum: {\n      system: 'FrameSupportDispatchRawOrigin',\n      __Unused1: 'Null',\n      Void: 'SpCoreVoid',\n      __Unused3: 'Null',\n      __Unused4: 'Null',\n      __Unused5: 'Null',\n      __Unused6: 'Null',\n      __Unused7: 'Null',\n      __Unused8: 'Null',\n      __Unused9: 'Null',\n      __Unused10: 'Null',\n      __Unused11: 'Null',\n      __Unused12: 'Null',\n      __Unused13: 'Null',\n      __Unused14: 'Null',\n      __Unused15: 'Null',\n      __Unused16: 'Null',\n      __Unused17: 'Null',\n      __Unused18: 'Null',\n      __Unused19: 'Null',\n      __Unused20: 'Null',\n      __Unused21: 'Null',\n      __Unused22: 'Null',\n      __Unused23: 'Null',\n      __Unused24: 'Null',\n      __Unused25: 'Null',\n      Ethereum: 'PalletEthereumRawOrigin'\n    }\n  },\n  /**\n   * Lookup182: frame_support::dispatch::RawOrigin<seed_primitives::signature::AccountId20>\n   **/\n  FrameSupportDispatchRawOrigin: {\n    _enum: {\n      Root: 'Null',\n      Signed: 'SeedPrimitivesSignatureAccountId20',\n      None: 'Null'\n    }\n  },\n  /**\n   * Lookup183: pallet_ethereum::RawOrigin\n   **/\n  PalletEthereumRawOrigin: {\n    _enum: {\n      EthereumTransaction: 'H160'\n    }\n  },\n  /**\n   * Lookup184: sp_core::Void\n   **/\n  SpCoreVoid: 'Null',\n  /**\n   * Lookup185: pallet_recovery::pallet::Call<T>\n   **/\n  PalletRecoveryCall: {\n    _enum: {\n      as_recovered: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n        call: 'Call',\n      },\n      set_recovered: {\n        lost: 'SeedPrimitivesSignatureAccountId20',\n        rescuer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      create_recovery: {\n        friends: 'Vec<SeedPrimitivesSignatureAccountId20>',\n        threshold: 'u16',\n        delayPeriod: 'u32',\n      },\n      initiate_recovery: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n      },\n      vouch_recovery: {\n        lost: 'SeedPrimitivesSignatureAccountId20',\n        rescuer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      claim_recovery: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n      },\n      close_recovery: {\n        rescuer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      remove_recovery: 'Null',\n      cancel_recovered: {\n        account: 'SeedPrimitivesSignatureAccountId20'\n      }\n    }\n  },\n  /**\n   * Lookup187: pallet_balances::pallet::Call<T, I>\n   **/\n  PalletBalancesCall: {\n    _enum: {\n      transfer: {\n        dest: 'SeedPrimitivesSignatureAccountId20',\n        value: 'Compact<u128>',\n      },\n      set_balance: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        newFree: 'Compact<u128>',\n        newReserved: 'Compact<u128>',\n      },\n      force_transfer: {\n        source: 'SeedPrimitivesSignatureAccountId20',\n        dest: 'SeedPrimitivesSignatureAccountId20',\n        value: 'Compact<u128>',\n      },\n      transfer_keep_alive: {\n        dest: 'SeedPrimitivesSignatureAccountId20',\n        value: 'Compact<u128>',\n      },\n      transfer_all: {\n        dest: 'SeedPrimitivesSignatureAccountId20',\n        keepAlive: 'bool',\n      },\n      force_unreserve: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'u128'\n      }\n    }\n  },\n  /**\n   * Lookup188: pallet_assets::pallet::Call<T, I>\n   **/\n  PalletAssetsCall: {\n    _enum: {\n      create: {\n        id: 'Compact<u32>',\n        admin: 'SeedPrimitivesSignatureAccountId20',\n        minBalance: 'u128',\n      },\n      force_create: {\n        id: 'Compact<u32>',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        isSufficient: 'bool',\n        minBalance: 'Compact<u128>',\n      },\n      destroy: {\n        id: 'Compact<u32>',\n        witness: 'PalletAssetsDestroyWitness',\n      },\n      mint: {\n        id: 'Compact<u32>',\n        beneficiary: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'Compact<u128>',\n      },\n      burn: {\n        id: 'Compact<u32>',\n        who: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'Compact<u128>',\n      },\n      transfer: {\n        id: 'Compact<u32>',\n        target: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'Compact<u128>',\n      },\n      transfer_keep_alive: {\n        id: 'Compact<u32>',\n        target: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'Compact<u128>',\n      },\n      force_transfer: {\n        id: 'Compact<u32>',\n        source: 'SeedPrimitivesSignatureAccountId20',\n        dest: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'Compact<u128>',\n      },\n      freeze: {\n        id: 'Compact<u32>',\n        who: 'SeedPrimitivesSignatureAccountId20',\n      },\n      thaw: {\n        id: 'Compact<u32>',\n        who: 'SeedPrimitivesSignatureAccountId20',\n      },\n      freeze_asset: {\n        id: 'Compact<u32>',\n      },\n      thaw_asset: {\n        id: 'Compact<u32>',\n      },\n      transfer_ownership: {\n        id: 'Compact<u32>',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      set_team: {\n        id: 'Compact<u32>',\n        issuer: 'SeedPrimitivesSignatureAccountId20',\n        admin: 'SeedPrimitivesSignatureAccountId20',\n        freezer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      set_metadata: {\n        id: 'Compact<u32>',\n        name: 'Bytes',\n        symbol: 'Bytes',\n        decimals: 'u8',\n      },\n      clear_metadata: {\n        id: 'Compact<u32>',\n      },\n      force_set_metadata: {\n        id: 'Compact<u32>',\n        name: 'Bytes',\n        symbol: 'Bytes',\n        decimals: 'u8',\n        isFrozen: 'bool',\n      },\n      force_clear_metadata: {\n        id: 'Compact<u32>',\n      },\n      force_asset_status: {\n        id: 'Compact<u32>',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        issuer: 'SeedPrimitivesSignatureAccountId20',\n        admin: 'SeedPrimitivesSignatureAccountId20',\n        freezer: 'SeedPrimitivesSignatureAccountId20',\n        minBalance: 'Compact<u128>',\n        isSufficient: 'bool',\n        isFrozen: 'bool',\n      },\n      approve_transfer: {\n        id: 'Compact<u32>',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'Compact<u128>',\n      },\n      cancel_approval: {\n        id: 'Compact<u32>',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n      },\n      force_cancel_approval: {\n        id: 'Compact<u32>',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n      },\n      transfer_approved: {\n        id: 'Compact<u32>',\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        destination: 'SeedPrimitivesSignatureAccountId20',\n        amount: 'Compact<u128>',\n      },\n      touch: {\n        id: 'Compact<u32>',\n      },\n      refund: {\n        id: 'Compact<u32>',\n        allowBurn: 'bool'\n      }\n    }\n  },\n  /**\n   * Lookup189: pallet_assets::types::DestroyWitness\n   **/\n  PalletAssetsDestroyWitness: {\n    accounts: 'Compact<u32>',\n    sufficients: 'Compact<u32>',\n    approvals: 'Compact<u32>'\n  },\n  /**\n   * Lookup190: pallet_assets_ext::pallet::Call<T>\n   **/\n  PalletAssetsExtCall: {\n    _enum: {\n      create_asset: {\n        name: 'Bytes',\n        symbol: 'Bytes',\n        decimals: 'u8',\n        minBalance: 'Option<u128>',\n        owner: 'Option<SeedPrimitivesSignatureAccountId20>'\n      }\n    }\n  },\n  /**\n   * Lookup192: pallet_authorship::pallet::Call<T>\n   **/\n  PalletAuthorshipCall: {\n    _enum: {\n      set_uncles: {\n        newUncles: 'Vec<SpRuntimeHeader>'\n      }\n    }\n  },\n  /**\n   * Lookup194: pallet_staking::pallet::pallet::Call<T>\n   **/\n  PalletStakingPalletCall: {\n    _enum: {\n      bond: {\n        controller: 'SeedPrimitivesSignatureAccountId20',\n        value: 'Compact<u128>',\n        payee: 'PalletStakingRewardDestination',\n      },\n      bond_extra: {\n        maxAdditional: 'Compact<u128>',\n      },\n      unbond: {\n        value: 'Compact<u128>',\n      },\n      withdraw_unbonded: {\n        numSlashingSpans: 'u32',\n      },\n      validate: {\n        prefs: 'PalletStakingValidatorPrefs',\n      },\n      nominate: {\n        targets: 'Vec<SeedPrimitivesSignatureAccountId20>',\n      },\n      chill: 'Null',\n      set_payee: {\n        payee: 'PalletStakingRewardDestination',\n      },\n      set_controller: {\n        controller: 'SeedPrimitivesSignatureAccountId20',\n      },\n      set_validator_count: {\n        _alias: {\n          new_: 'new',\n        },\n        new_: 'Compact<u32>',\n      },\n      increase_validator_count: {\n        additional: 'Compact<u32>',\n      },\n      scale_validator_count: {\n        factor: 'Percent',\n      },\n      force_no_eras: 'Null',\n      force_new_era: 'Null',\n      set_invulnerables: {\n        invulnerables: 'Vec<SeedPrimitivesSignatureAccountId20>',\n      },\n      force_unstake: {\n        stash: 'SeedPrimitivesSignatureAccountId20',\n        numSlashingSpans: 'u32',\n      },\n      force_new_era_always: 'Null',\n      cancel_deferred_slash: {\n        era: 'u32',\n        slashIndices: 'Vec<u32>',\n      },\n      payout_stakers: {\n        validatorStash: 'SeedPrimitivesSignatureAccountId20',\n        era: 'u32',\n      },\n      rebond: {\n        value: 'Compact<u128>',\n      },\n      set_history_depth: {\n        newHistoryDepth: 'Compact<u32>',\n        eraItemsDeleted: 'Compact<u32>',\n      },\n      reap_stash: {\n        stash: 'SeedPrimitivesSignatureAccountId20',\n        numSlashingSpans: 'u32',\n      },\n      kick: {\n        who: 'Vec<SeedPrimitivesSignatureAccountId20>',\n      },\n      set_staking_configs: {\n        minNominatorBond: 'PalletStakingPalletConfigOpU128',\n        minValidatorBond: 'PalletStakingPalletConfigOpU128',\n        maxNominatorCount: 'PalletStakingPalletConfigOpU32',\n        maxValidatorCount: 'PalletStakingPalletConfigOpU32',\n        chillThreshold: 'PalletStakingPalletConfigOpPercent',\n        minCommission: 'PalletStakingPalletConfigOpPerbill',\n      },\n      chill_other: {\n        controller: 'SeedPrimitivesSignatureAccountId20',\n      },\n      force_apply_min_commission: {\n        validatorStash: 'SeedPrimitivesSignatureAccountId20'\n      }\n    }\n  },\n  /**\n   * Lookup195: pallet_staking::RewardDestination<seed_primitives::signature::AccountId20>\n   **/\n  PalletStakingRewardDestination: {\n    _enum: {\n      Staked: 'Null',\n      Stash: 'Null',\n      Controller: 'Null',\n      Account: 'SeedPrimitivesSignatureAccountId20',\n      None: 'Null'\n    }\n  },\n  /**\n   * Lookup197: pallet_staking::pallet::pallet::ConfigOp<T>\n   **/\n  PalletStakingPalletConfigOpU128: {\n    _enum: {\n      Noop: 'Null',\n      Set: 'u128',\n      Remove: 'Null'\n    }\n  },\n  /**\n   * Lookup198: pallet_staking::pallet::pallet::ConfigOp<T>\n   **/\n  PalletStakingPalletConfigOpU32: {\n    _enum: {\n      Noop: 'Null',\n      Set: 'u32',\n      Remove: 'Null'\n    }\n  },\n  /**\n   * Lookup199: pallet_staking::pallet::pallet::ConfigOp<sp_arithmetic::per_things::Percent>\n   **/\n  PalletStakingPalletConfigOpPercent: {\n    _enum: {\n      Noop: 'Null',\n      Set: 'Percent',\n      Remove: 'Null'\n    }\n  },\n  /**\n   * Lookup200: pallet_staking::pallet::pallet::ConfigOp<sp_arithmetic::per_things::Perbill>\n   **/\n  PalletStakingPalletConfigOpPerbill: {\n    _enum: {\n      Noop: 'Null',\n      Set: 'Perbill',\n      Remove: 'Null'\n    }\n  },\n  /**\n   * Lookup201: pallet_session::pallet::Call<T>\n   **/\n  PalletSessionCall: {\n    _enum: {\n      set_keys: {\n        _alias: {\n          keys_: 'keys',\n        },\n        keys_: 'SeedRuntimeSessionKeys',\n        proof: 'Bytes',\n      },\n      purge_keys: 'Null'\n    }\n  },\n  /**\n   * Lookup202: seed_runtime::SessionKeys\n   **/\n  SeedRuntimeSessionKeys: {\n    babe: 'SpConsensusBabeAppPublic',\n    imOnline: 'PalletImOnlineSr25519AppSr25519Public',\n    grandpa: 'SpFinalityGrandpaAppPublic',\n    ethy: 'SeedPrimitivesEthyCryptoAppCryptoPublic'\n  },\n  /**\n   * Lookup203: seed_primitives::ethy::crypto::app_crypto::Public\n   **/\n  SeedPrimitivesEthyCryptoAppCryptoPublic: 'SpCoreEcdsaPublic',\n  /**\n   * Lookup204: sp_core::ecdsa::Public\n   **/\n  SpCoreEcdsaPublic: '[u8;33]',\n  /**\n   * Lookup206: pallet_grandpa::pallet::Call<T>\n   **/\n  PalletGrandpaCall: {\n    _enum: {\n      report_equivocation: {\n        equivocationProof: 'SpFinalityGrandpaEquivocationProof',\n        keyOwnerProof: 'SpCoreVoid',\n      },\n      report_equivocation_unsigned: {\n        equivocationProof: 'SpFinalityGrandpaEquivocationProof',\n        keyOwnerProof: 'SpCoreVoid',\n      },\n      note_stalled: {\n        delay: 'u32',\n        bestFinalizedBlockNumber: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup207: sp_finality_grandpa::EquivocationProof<primitive_types::H256, N>\n   **/\n  SpFinalityGrandpaEquivocationProof: {\n    setId: 'u64',\n    equivocation: 'SpFinalityGrandpaEquivocation'\n  },\n  /**\n   * Lookup208: sp_finality_grandpa::Equivocation<primitive_types::H256, N>\n   **/\n  SpFinalityGrandpaEquivocation: {\n    _enum: {\n      Prevote: 'FinalityGrandpaEquivocationPrevote',\n      Precommit: 'FinalityGrandpaEquivocationPrecommit'\n    }\n  },\n  /**\n   * Lookup209: finality_grandpa::Equivocation<sp_finality_grandpa::app::Public, finality_grandpa::Prevote<primitive_types::H256, N>, sp_finality_grandpa::app::Signature>\n   **/\n  FinalityGrandpaEquivocationPrevote: {\n    roundNumber: 'u64',\n    identity: 'SpFinalityGrandpaAppPublic',\n    first: '(FinalityGrandpaPrevote,SpFinalityGrandpaAppSignature)',\n    second: '(FinalityGrandpaPrevote,SpFinalityGrandpaAppSignature)'\n  },\n  /**\n   * Lookup210: finality_grandpa::Prevote<primitive_types::H256, N>\n   **/\n  FinalityGrandpaPrevote: {\n    targetHash: 'H256',\n    targetNumber: 'u32'\n  },\n  /**\n   * Lookup211: sp_finality_grandpa::app::Signature\n   **/\n  SpFinalityGrandpaAppSignature: 'SpCoreEd25519Signature',\n  /**\n   * Lookup212: sp_core::ed25519::Signature\n   **/\n  SpCoreEd25519Signature: '[u8;64]',\n  /**\n   * Lookup214: finality_grandpa::Equivocation<sp_finality_grandpa::app::Public, finality_grandpa::Precommit<primitive_types::H256, N>, sp_finality_grandpa::app::Signature>\n   **/\n  FinalityGrandpaEquivocationPrecommit: {\n    roundNumber: 'u64',\n    identity: 'SpFinalityGrandpaAppPublic',\n    first: '(FinalityGrandpaPrecommit,SpFinalityGrandpaAppSignature)',\n    second: '(FinalityGrandpaPrecommit,SpFinalityGrandpaAppSignature)'\n  },\n  /**\n   * Lookup215: finality_grandpa::Precommit<primitive_types::H256, N>\n   **/\n  FinalityGrandpaPrecommit: {\n    targetHash: 'H256',\n    targetNumber: 'u32'\n  },\n  /**\n   * Lookup217: pallet_im_online::pallet::Call<T>\n   **/\n  PalletImOnlineCall: {\n    _enum: {\n      heartbeat: {\n        heartbeat: 'PalletImOnlineHeartbeat',\n        signature: 'PalletImOnlineSr25519AppSr25519Signature'\n      }\n    }\n  },\n  /**\n   * Lookup218: pallet_im_online::Heartbeat<BlockNumber>\n   **/\n  PalletImOnlineHeartbeat: {\n    blockNumber: 'u32',\n    networkState: 'SpCoreOffchainOpaqueNetworkState',\n    sessionIndex: 'u32',\n    authorityIndex: 'u32',\n    validatorsLen: 'u32'\n  },\n  /**\n   * Lookup219: sp_core::offchain::OpaqueNetworkState\n   **/\n  SpCoreOffchainOpaqueNetworkState: {\n    peerId: 'OpaquePeerId',\n    externalAddresses: 'Vec<OpaqueMultiaddr>'\n  },\n  /**\n   * Lookup223: pallet_im_online::sr25519::app_sr25519::Signature\n   **/\n  PalletImOnlineSr25519AppSr25519Signature: 'SpCoreSr25519Signature',\n  /**\n   * Lookup224: sp_core::sr25519::Signature\n   **/\n  SpCoreSr25519Signature: '[u8;64]',\n  /**\n   * Lookup225: pallet_sudo::pallet::Call<T>\n   **/\n  PalletSudoCall: {\n    _enum: {\n      sudo: {\n        call: 'Call',\n      },\n      sudo_unchecked_weight: {\n        call: 'Call',\n        weight: 'u64',\n      },\n      set_key: {\n        _alias: {\n          new_: 'new',\n        },\n        new_: 'SeedPrimitivesSignatureAccountId20',\n      },\n      sudo_as: {\n        who: 'SeedPrimitivesSignatureAccountId20',\n        call: 'Call'\n      }\n    }\n  },\n  /**\n   * Lookup226: pallet_dex::pallet::Call<T>\n   **/\n  PalletDexCall: {\n    _enum: {\n      swap_with_exact_supply: {\n        amountIn: 'Compact<u128>',\n        amountOutMin: 'Compact<u128>',\n        path: 'Vec<u32>',\n      },\n      swap_with_exact_target: {\n        amountOut: 'Compact<u128>',\n        amountInMax: 'Compact<u128>',\n        path: 'Vec<u32>',\n      },\n      add_liquidity: {\n        assetIdA: 'u32',\n        assetIdB: 'u32',\n        amountADesired: 'Compact<u128>',\n        amountBDesired: 'Compact<u128>',\n        amountAMin: 'Compact<u128>',\n        amountBMin: 'Compact<u128>',\n        minShareIncrement: 'Compact<u128>',\n      },\n      remove_liquidity: {\n        assetIdA: 'u32',\n        assetIdB: 'u32',\n        removeLiquidity: 'Compact<u128>',\n        minWithdrawnA: 'Compact<u128>',\n        minWithdrawnB: 'Compact<u128>',\n      },\n      reenable_trading_pair: {\n        assetIdA: 'u32',\n        assetIdB: 'u32',\n      },\n      disable_trading_pair: {\n        assetIdA: 'u32',\n        assetIdB: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup227: pallet_nft::pallet::Call<T>\n   **/\n  PalletNftCall: {\n    _enum: {\n      claim_unowned_collection: {\n        collectionId: 'u32',\n        newOwner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      set_owner: {\n        collectionId: 'u32',\n        newOwner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      set_max_issuance: {\n        collectionId: 'u32',\n        maxIssuance: 'u32',\n      },\n      set_base_uri: {\n        collectionId: 'u32',\n        baseUri: 'Bytes',\n      },\n      register_marketplace: {\n        marketplaceAccount: 'Option<SeedPrimitivesSignatureAccountId20>',\n        entitlement: 'Permill',\n      },\n      create_collection: {\n        name: 'Bytes',\n        initialIssuance: 'u32',\n        maxIssuance: 'Option<u32>',\n        tokenOwner: 'Option<SeedPrimitivesSignatureAccountId20>',\n        metadataScheme: 'Bytes',\n        royaltiesSchedule: 'Option<PalletNftRoyaltiesSchedule>',\n        crossChainCompatibility: 'PalletNftCrossChainCompatibility',\n      },\n      mint: {\n        collectionId: 'u32',\n        quantity: 'u32',\n        tokenOwner: 'Option<SeedPrimitivesSignatureAccountId20>',\n      },\n      transfer: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        newOwner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      burn: {\n        tokenId: '(u32,u32)',\n      },\n      sell: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        buyer: 'Option<SeedPrimitivesSignatureAccountId20>',\n        paymentAsset: 'u32',\n        fixedPrice: 'u128',\n        duration: 'Option<u32>',\n        marketplaceId: 'Option<u32>',\n      },\n      buy: {\n        listingId: 'u128',\n      },\n      auction: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        paymentAsset: 'u32',\n        reservePrice: 'u128',\n        duration: 'Option<u32>',\n        marketplaceId: 'Option<u32>',\n      },\n      bid: {\n        listingId: 'u128',\n        amount: 'u128',\n      },\n      cancel_sale: {\n        listingId: 'u128',\n      },\n      update_fixed_price: {\n        listingId: 'u128',\n        newPrice: 'u128',\n      },\n      make_simple_offer: {\n        tokenId: '(u32,u32)',\n        amount: 'u128',\n        assetId: 'u32',\n        marketplaceId: 'Option<u32>',\n      },\n      cancel_offer: {\n        offerId: 'u64',\n      },\n      accept_offer: {\n        offerId: 'u64'\n      }\n    }\n  },\n  /**\n   * Lookup228: pallet_xrpl_bridge::pallet::Call<T>\n   **/\n  PalletXrplBridgeCall: {\n    _enum: {\n      submit_transaction: {\n        ledgerIndex: 'u64',\n        transactionHash: 'H512',\n        transaction: 'PalletXrplBridgeHelpersXrplTxData',\n        timestamp: 'u64',\n      },\n      submit_challenge: {\n        transactionHash: 'H512',\n      },\n      withdraw_xrp: {\n        amount: 'u128',\n        destination: 'H160',\n      },\n      add_relayer: {\n        relayer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      remove_relayer: {\n        relayer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      set_door_tx_fee: {\n        fee: 'u64',\n      },\n      set_door_address: {\n        doorAddress: 'H160',\n      },\n      set_ticket_sequence_next_allocation: {\n        startTicketSequence: 'u32',\n        ticketBucketSize: 'u32',\n      },\n      set_ticket_sequence_current_allocation: {\n        ticketSequence: 'u32',\n        startTicketSequence: 'u32',\n        ticketBucketSize: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup229: pallet_xrpl_bridge::helpers::XrplTxData\n   **/\n  PalletXrplBridgeHelpersXrplTxData: {\n    _enum: {\n      Payment: {\n        amount: 'u128',\n        address: 'H160',\n      },\n      CurrencyPayment: {\n        amount: 'u128',\n        address: 'H160',\n        currencyId: 'H256',\n      },\n      Xls20: 'Null'\n    }\n  },\n  /**\n   * Lookup230: pallet_token_approvals::pallet::Call<T>\n   **/\n  PalletTokenApprovalsCall: {\n    _enum: {\n      erc721_approval: {\n        caller: 'SeedPrimitivesSignatureAccountId20',\n        operatorAccount: 'SeedPrimitivesSignatureAccountId20',\n        tokenId: '(u32,u32)',\n      },\n      erc721_remove_approval: {\n        tokenId: '(u32,u32)',\n      },\n      erc20_approval: {\n        caller: 'SeedPrimitivesSignatureAccountId20',\n        spender: 'SeedPrimitivesSignatureAccountId20',\n        assetId: 'u32',\n        amount: 'u128',\n      },\n      erc20_update_approval: {\n        caller: 'SeedPrimitivesSignatureAccountId20',\n        spender: 'SeedPrimitivesSignatureAccountId20',\n        assetId: 'u32',\n        amount: 'u128',\n      },\n      erc721_approval_for_all: {\n        caller: 'SeedPrimitivesSignatureAccountId20',\n        operatorAccount: 'SeedPrimitivesSignatureAccountId20',\n        collectionUuid: 'u32',\n        approved: 'bool'\n      }\n    }\n  },\n  /**\n   * Lookup231: pallet_echo::pallet::Call<T>\n   **/\n  PalletEchoCall: {\n    _enum: {\n      ping: {\n        destination: 'H160'\n      }\n    }\n  },\n  /**\n   * Lookup232: pallet_marketplace::pallet::Call<T>\n   **/\n  PalletMarketplaceCall: {\n    _enum: {\n      register_marketplace: {\n        marketplaceAccount: 'Option<SeedPrimitivesSignatureAccountId20>',\n        entitlement: 'Permill',\n      },\n      sell_nft: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        buyer: 'Option<SeedPrimitivesSignatureAccountId20>',\n        paymentAsset: 'u32',\n        fixedPrice: 'u128',\n        duration: 'Option<u32>',\n        marketplaceId: 'Option<u32>',\n      },\n      update_fixed_price: {\n        listingId: 'u128',\n        newPrice: 'u128',\n      },\n      buy: {\n        listingId: 'u128',\n      },\n      auction_nft: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n        paymentAsset: 'u32',\n        reservePrice: 'u128',\n        duration: 'Option<u32>',\n        marketplaceId: 'Option<u32>',\n      },\n      bid: {\n        listingId: 'u128',\n        amount: 'u128',\n      },\n      cancel_sale: {\n        listingId: 'u128',\n      },\n      make_simple_offer: {\n        tokenId: '(u32,u32)',\n        amount: 'u128',\n        assetId: 'u32',\n        marketplaceId: 'Option<u32>',\n      },\n      cancel_offer: {\n        offerId: 'u64',\n      },\n      accept_offer: {\n        offerId: 'u64'\n      }\n    }\n  },\n  /**\n   * Lookup233: pallet_election_provider_multi_phase::pallet::Call<T>\n   **/\n  PalletElectionProviderMultiPhaseCall: {\n    _enum: {\n      submit_unsigned: {\n        rawSolution: 'PalletElectionProviderMultiPhaseRawSolution',\n        witness: 'PalletElectionProviderMultiPhaseSolutionOrSnapshotSize',\n      },\n      set_minimum_untrusted_score: {\n        maybeNextScore: 'Option<SpNposElectionsElectionScore>',\n      },\n      set_emergency_election_result: {\n        supports: 'Vec<(SeedPrimitivesSignatureAccountId20,SpNposElectionsSupport)>',\n      },\n      submit: {\n        rawSolution: 'PalletElectionProviderMultiPhaseRawSolution',\n      },\n      governance_fallback: {\n        maybeMaxVoters: 'Option<u32>',\n        maybeMaxTargets: 'Option<u32>'\n      }\n    }\n  },\n  /**\n   * Lookup234: pallet_election_provider_multi_phase::RawSolution<seed_runtime::NposCompactSolution16>\n   **/\n  PalletElectionProviderMultiPhaseRawSolution: {\n    solution: 'SeedRuntimeNposCompactSolution16',\n    score: 'SpNposElectionsElectionScore',\n    round: 'u32'\n  },\n  /**\n   * Lookup235: seed_runtime::NposCompactSolution16\n   **/\n  SeedRuntimeNposCompactSolution16: {\n    votes1: 'Vec<(Compact<u32>,Compact<u16>)>',\n    votes2: 'Vec<(Compact<u32>,(Compact<u16>,Compact<PerU16>),Compact<u16>)>',\n    votes3: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);2],Compact<u16>)>',\n    votes4: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);3],Compact<u16>)>',\n    votes5: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);4],Compact<u16>)>',\n    votes6: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);5],Compact<u16>)>',\n    votes7: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);6],Compact<u16>)>',\n    votes8: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);7],Compact<u16>)>',\n    votes9: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);8],Compact<u16>)>',\n    votes10: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);9],Compact<u16>)>',\n    votes11: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);10],Compact<u16>)>',\n    votes12: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);11],Compact<u16>)>',\n    votes13: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);12],Compact<u16>)>',\n    votes14: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);13],Compact<u16>)>',\n    votes15: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);14],Compact<u16>)>',\n    votes16: 'Vec<(Compact<u32>,[(Compact<u16>,Compact<PerU16>);15],Compact<u16>)>'\n  },\n  /**\n   * Lookup286: sp_npos_elections::ElectionScore\n   **/\n  SpNposElectionsElectionScore: {\n    minimalStake: 'u128',\n    sumStake: 'u128',\n    sumStakeSquared: 'u128'\n  },\n  /**\n   * Lookup287: pallet_election_provider_multi_phase::SolutionOrSnapshotSize\n   **/\n  PalletElectionProviderMultiPhaseSolutionOrSnapshotSize: {\n    voters: 'Compact<u32>',\n    targets: 'Compact<u32>'\n  },\n  /**\n   * Lookup291: sp_npos_elections::Support<seed_primitives::signature::AccountId20>\n   **/\n  SpNposElectionsSupport: {\n    total: 'u128',\n    voters: 'Vec<(SeedPrimitivesSignatureAccountId20,u128)>'\n  },\n  /**\n   * Lookup292: pallet_bags_list::pallet::Call<T, I>\n   **/\n  PalletBagsListCall: {\n    _enum: {\n      rebag: {\n        dislocated: 'SeedPrimitivesSignatureAccountId20',\n      },\n      put_in_front_of: {\n        lighter: 'SeedPrimitivesSignatureAccountId20'\n      }\n    }\n  },\n  /**\n   * Lookup293: pallet_ethy::Call<T>\n   **/\n  PalletEthyCall: {\n    _enum: {\n      set_xrpl_door_signers: {\n        newSigners: 'Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>',\n      },\n      set_relayer: {\n        relayer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      deposit_relayer_bond: 'Null',\n      withdraw_relayer_bond: 'Null',\n      set_event_block_confirmations: {\n        confirmations: 'u64',\n      },\n      set_delayed_event_proofs_per_block: {\n        count: 'u8',\n      },\n      set_challenge_period: {\n        blocks: 'u32',\n      },\n      set_contract_address: {\n        contractAddress: 'H160',\n      },\n      set_bridge_paused: {\n        paused: 'bool',\n      },\n      finalise_authorities_change: {\n        nextNotaryKeys: 'Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>',\n      },\n      submit_event: {\n        txHash: 'H256',\n        event: 'Bytes',\n      },\n      submit_challenge: {\n        eventClaimId: 'u64',\n      },\n      submit_notarization: {\n        payload: 'PalletEthyNotarizationPayload',\n        signature: 'SeedPrimitivesEthyCryptoAppCryptoSignature'\n      }\n    }\n  },\n  /**\n   * Lookup295: pallet_ethy::types::NotarizationPayload\n   **/\n  PalletEthyNotarizationPayload: {\n    _enum: {\n      Call: {\n        callId: 'u64',\n        authorityIndex: 'u16',\n        result: 'PalletEthyCheckedEthCallResult',\n      },\n      Event: {\n        eventClaimId: 'u64',\n        authorityIndex: 'u16',\n        result: 'PalletEthyEventClaimResult'\n      }\n    }\n  },\n  /**\n   * Lookup296: pallet_ethy::types::CheckedEthCallResult\n   **/\n  PalletEthyCheckedEthCallResult: {\n    _enum: {\n      Ok: '([u8;32],u64,u64)',\n      ReturnDataExceedsLimit: 'Null',\n      ReturnDataEmpty: 'Null',\n      DataProviderErr: 'Null',\n      InvalidEthBlock: 'Null',\n      InvalidTimestamp: 'Null'\n    }\n  },\n  /**\n   * Lookup297: pallet_ethy::types::EventClaimResult\n   **/\n  PalletEthyEventClaimResult: {\n    _enum: ['Valid', 'DataProviderErr', 'TxStatusFailed', 'UnexpectedContractAddress', 'NoTxLogs', 'NotEnoughConfirmations', 'UnexpectedData', 'NoTxReceipt', 'UnexpectedSource']\n  },\n  /**\n   * Lookup298: seed_primitives::ethy::crypto::app_crypto::Signature\n   **/\n  SeedPrimitivesEthyCryptoAppCryptoSignature: 'SpCoreEcdsaSignature',\n  /**\n   * Lookup299: sp_core::ecdsa::Signature\n   **/\n  SpCoreEcdsaSignature: '[u8;65]',\n  /**\n   * Lookup301: pallet_ethereum::pallet::Call<T>\n   **/\n  PalletEthereumCall: {\n    _enum: {\n      transact: {\n        transaction: 'EthereumTransactionTransactionV2'\n      }\n    }\n  },\n  /**\n   * Lookup302: ethereum::transaction::TransactionV2\n   **/\n  EthereumTransactionTransactionV2: {\n    _enum: {\n      Legacy: 'EthereumTransactionLegacyTransaction',\n      EIP2930: 'EthereumTransactionEip2930Transaction',\n      EIP1559: 'EthereumTransactionEip1559Transaction'\n    }\n  },\n  /**\n   * Lookup303: ethereum::transaction::LegacyTransaction\n   **/\n  EthereumTransactionLegacyTransaction: {\n    nonce: 'U256',\n    gasPrice: 'U256',\n    gasLimit: 'U256',\n    action: 'EthereumTransactionTransactionAction',\n    value: 'U256',\n    input: 'Bytes',\n    signature: 'EthereumTransactionTransactionSignature'\n  },\n  /**\n   * Lookup306: ethereum::transaction::TransactionAction\n   **/\n  EthereumTransactionTransactionAction: {\n    _enum: {\n      Call: 'H160',\n      Create: 'Null'\n    }\n  },\n  /**\n   * Lookup307: ethereum::transaction::TransactionSignature\n   **/\n  EthereumTransactionTransactionSignature: {\n    v: 'u64',\n    r: 'H256',\n    s: 'H256'\n  },\n  /**\n   * Lookup309: ethereum::transaction::EIP2930Transaction\n   **/\n  EthereumTransactionEip2930Transaction: {\n    chainId: 'u64',\n    nonce: 'U256',\n    gasPrice: 'U256',\n    gasLimit: 'U256',\n    action: 'EthereumTransactionTransactionAction',\n    value: 'U256',\n    input: 'Bytes',\n    accessList: 'Vec<EthereumTransactionAccessListItem>',\n    oddYParity: 'bool',\n    r: 'H256',\n    s: 'H256'\n  },\n  /**\n   * Lookup311: ethereum::transaction::AccessListItem\n   **/\n  EthereumTransactionAccessListItem: {\n    address: 'H160',\n    storageKeys: 'Vec<H256>'\n  },\n  /**\n   * Lookup312: ethereum::transaction::EIP1559Transaction\n   **/\n  EthereumTransactionEip1559Transaction: {\n    chainId: 'u64',\n    nonce: 'U256',\n    maxPriorityFeePerGas: 'U256',\n    maxFeePerGas: 'U256',\n    gasLimit: 'U256',\n    action: 'EthereumTransactionTransactionAction',\n    value: 'U256',\n    input: 'Bytes',\n    accessList: 'Vec<EthereumTransactionAccessListItem>',\n    oddYParity: 'bool',\n    r: 'H256',\n    s: 'H256'\n  },\n  /**\n   * Lookup313: pallet_evm::pallet::Call<T>\n   **/\n  PalletEvmCall: {\n    _enum: {\n      withdraw: {\n        address: 'H160',\n        value: 'u128',\n      },\n      call: {\n        source: 'H160',\n        target: 'H160',\n        input: 'Bytes',\n        value: 'U256',\n        gasLimit: 'u64',\n        maxFeePerGas: 'U256',\n        maxPriorityFeePerGas: 'Option<U256>',\n        nonce: 'Option<U256>',\n        accessList: 'Vec<(H160,Vec<H256>)>',\n      },\n      create: {\n        source: 'H160',\n        init: 'Bytes',\n        value: 'U256',\n        gasLimit: 'u64',\n        maxFeePerGas: 'U256',\n        maxPriorityFeePerGas: 'Option<U256>',\n        nonce: 'Option<U256>',\n        accessList: 'Vec<(H160,Vec<H256>)>',\n      },\n      create2: {\n        source: 'H160',\n        init: 'Bytes',\n        salt: 'H256',\n        value: 'U256',\n        gasLimit: 'u64',\n        maxFeePerGas: 'U256',\n        maxPriorityFeePerGas: 'Option<U256>',\n        nonce: 'Option<U256>',\n        accessList: 'Vec<(H160,Vec<H256>)>'\n      }\n    }\n  },\n  /**\n   * Lookup317: pallet_evm_chain_id::pallet::Call<T>\n   **/\n  PalletEvmChainIdCall: {\n    _enum: {\n      set_chain_id: {\n        chainId: 'Compact<u64>'\n      }\n    }\n  },\n  /**\n   * Lookup318: pallet_erc20_peg::Call<T>\n   **/\n  PalletErc20PegCall: {\n    _enum: {\n      activate_deposits: {\n        activate: 'bool',\n      },\n      activate_withdrawals: {\n        activate: 'bool',\n      },\n      withdraw: {\n        assetId: 'u32',\n        amount: 'u128',\n        beneficiary: 'H160',\n      },\n      set_contract_address: {\n        ethAddress: 'H160',\n      },\n      set_erc20_meta: {\n        details: 'Vec<(H160,Bytes,u8)>',\n      },\n      set_payment_delay: {\n        assetId: 'u32',\n        minBalance: 'u128',\n        delay: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup321: pallet_nft_peg::pallet::Call<T>\n   **/\n  PalletNftPegCall: {\n    _enum: {\n      set_contract_address: {\n        contract: 'H160',\n      },\n      withdraw: {\n        collectionIds: 'Vec<u32>',\n        serialNumbers: 'Vec<Vec<u32>>',\n        destination: 'H160'\n      }\n    }\n  },\n  /**\n   * Lookup322: pallet_fee_proxy::pallet::Call<T>\n   **/\n  PalletFeeProxyCall: {\n    _enum: {\n      call_with_fee_preferences: {\n        paymentAsset: 'u32',\n        maxPayment: 'u128',\n        call: 'Call'\n      }\n    }\n  },\n  /**\n   * Lookup323: pallet_fee_control::pallet::Call<T>\n   **/\n  PalletFeeControlCall: {\n    _enum: {\n      set_evm_base_fee: {\n        value: 'U256',\n      },\n      set_weight_multiplier: {\n        value: 'Perbill'\n      }\n    }\n  },\n  /**\n   * Lookup324: pallet_xls20::pallet::Call<T>\n   **/\n  PalletXls20Call: {\n    _enum: {\n      set_relayer: {\n        relayer: 'SeedPrimitivesSignatureAccountId20',\n      },\n      set_xls20_fee: {\n        newFee: 'u128',\n      },\n      enable_xls20_compatibility: {\n        collectionId: 'u32',\n      },\n      re_request_xls20_mint: {\n        collectionId: 'u32',\n        serialNumbers: 'Vec<u32>',\n      },\n      fulfill_xls20_mint: {\n        collectionId: 'u32',\n        tokenMappings: 'Vec<(u32,[u8;64])>'\n      }\n    }\n  },\n  /**\n   * Lookup327: pallet_proxy::pallet::Call<T>\n   **/\n  PalletProxyCall: {\n    _enum: {\n      proxy: {\n        real: 'SeedPrimitivesSignatureAccountId20',\n        forceProxyType: 'Option<SeedRuntimeImplsProxyType>',\n        call: 'Call',\n      },\n      add_proxy: {\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        proxyType: 'SeedRuntimeImplsProxyType',\n        delay: 'u32',\n      },\n      remove_proxy: {\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        proxyType: 'SeedRuntimeImplsProxyType',\n        delay: 'u32',\n      },\n      remove_proxies: 'Null',\n      anonymous: {\n        proxyType: 'SeedRuntimeImplsProxyType',\n        delay: 'u32',\n        index: 'u16',\n      },\n      kill_anonymous: {\n        spawner: 'SeedPrimitivesSignatureAccountId20',\n        proxyType: 'SeedRuntimeImplsProxyType',\n        index: 'u16',\n        height: 'Compact<u32>',\n        extIndex: 'Compact<u32>',\n      },\n      announce: {\n        real: 'SeedPrimitivesSignatureAccountId20',\n        callHash: 'H256',\n      },\n      remove_announcement: {\n        real: 'SeedPrimitivesSignatureAccountId20',\n        callHash: 'H256',\n      },\n      reject_announcement: {\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        callHash: 'H256',\n      },\n      proxy_announced: {\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        real: 'SeedPrimitivesSignatureAccountId20',\n        forceProxyType: 'Option<SeedRuntimeImplsProxyType>',\n        call: 'Call'\n      }\n    }\n  },\n  /**\n   * Lookup329: pallet_futurepass::pallet::Call<T>\n   **/\n  PalletFuturepassCall: {\n    _enum: {\n      create: {\n        account: 'SeedPrimitivesSignatureAccountId20',\n      },\n      register_delegate: {\n        futurepass: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n        proxyType: 'SeedRuntimeImplsProxyType',\n      },\n      unregister_delegate: {\n        futurepass: 'SeedPrimitivesSignatureAccountId20',\n        delegate: 'SeedPrimitivesSignatureAccountId20',\n      },\n      transfer_futurepass: {\n        newOwner: 'SeedPrimitivesSignatureAccountId20',\n      },\n      proxy_extrinsic: {\n        futurepass: 'SeedPrimitivesSignatureAccountId20',\n        call: 'Call',\n      },\n      set_futurepass_migrator: {\n        migrator: 'SeedPrimitivesSignatureAccountId20',\n      },\n      migrate_evm_futurepass: {\n        owner: 'SeedPrimitivesSignatureAccountId20',\n        evmFuturepass: 'SeedPrimitivesSignatureAccountId20',\n        collectionIds: 'Vec<u32>'\n      }\n    }\n  },\n  /**\n   * Lookup330: pallet_scheduler::pallet::Error<T>\n   **/\n  PalletSchedulerError: {\n    _enum: ['FailedToSchedule', 'NotFound', 'TargetBlockNumberInPast', 'RescheduleNoChange']\n  },\n  /**\n   * Lookup331: pallet_utility::pallet::Error<T>\n   **/\n  PalletUtilityError: {\n    _enum: ['TooManyCalls']\n  },\n  /**\n   * Lookup332: pallet_recovery::RecoveryConfig<BlockNumber, Balance, sp_runtime::bounded::bounded_vec::BoundedVec<seed_primitives::signature::AccountId20, S>>\n   **/\n  PalletRecoveryRecoveryConfig: {\n    delayPeriod: 'u32',\n    deposit: 'u128',\n    friends: 'Vec<SeedPrimitivesSignatureAccountId20>',\n    threshold: 'u16'\n  },\n  /**\n   * Lookup335: pallet_recovery::ActiveRecovery<BlockNumber, Balance, sp_runtime::bounded::bounded_vec::BoundedVec<seed_primitives::signature::AccountId20, S>>\n   **/\n  PalletRecoveryActiveRecovery: {\n    created: 'u32',\n    deposit: 'u128',\n    friends: 'Vec<SeedPrimitivesSignatureAccountId20>'\n  },\n  /**\n   * Lookup336: pallet_recovery::pallet::Error<T>\n   **/\n  PalletRecoveryError: {\n    _enum: ['NotAllowed', 'ZeroThreshold', 'NotEnoughFriends', 'MaxFriends', 'NotSorted', 'NotRecoverable', 'AlreadyRecoverable', 'AlreadyStarted', 'NotStarted', 'NotFriend', 'DelayPeriod', 'AlreadyVouched', 'Threshold', 'StillActive', 'AlreadyProxy', 'BadState']\n  },\n  /**\n   * Lookup338: pallet_balances::BalanceLock<Balance>\n   **/\n  PalletBalancesBalanceLock: {\n    id: '[u8;8]',\n    amount: 'u128',\n    reasons: 'PalletBalancesReasons'\n  },\n  /**\n   * Lookup339: pallet_balances::Reasons\n   **/\n  PalletBalancesReasons: {\n    _enum: ['Fee', 'Misc', 'All']\n  },\n  /**\n   * Lookup342: pallet_balances::ReserveData<ReserveIdentifier, Balance>\n   **/\n  PalletBalancesReserveData: {\n    id: '[u8;8]',\n    amount: 'u128'\n  },\n  /**\n   * Lookup344: pallet_balances::Releases\n   **/\n  PalletBalancesReleases: {\n    _enum: ['V1_0_0', 'V2_0_0']\n  },\n  /**\n   * Lookup345: pallet_balances::pallet::Error<T, I>\n   **/\n  PalletBalancesError: {\n    _enum: ['VestingBalance', 'LiquidityRestrictions', 'InsufficientBalance', 'ExistentialDeposit', 'KeepAlive', 'ExistingVestingSchedule', 'DeadAccount', 'TooManyReserves']\n  },\n  /**\n   * Lookup346: pallet_assets::types::AssetDetails<Balance, seed_primitives::signature::AccountId20, DepositBalance>\n   **/\n  PalletAssetsAssetDetails: {\n    owner: 'SeedPrimitivesSignatureAccountId20',\n    issuer: 'SeedPrimitivesSignatureAccountId20',\n    admin: 'SeedPrimitivesSignatureAccountId20',\n    freezer: 'SeedPrimitivesSignatureAccountId20',\n    supply: 'u128',\n    deposit: 'u128',\n    minBalance: 'u128',\n    isSufficient: 'bool',\n    accounts: 'u32',\n    sufficients: 'u32',\n    approvals: 'u32',\n    isFrozen: 'bool'\n  },\n  /**\n   * Lookup348: pallet_assets::types::AssetAccount<Balance, DepositBalance, Extra>\n   **/\n  PalletAssetsAssetAccount: {\n    balance: 'u128',\n    isFrozen: 'bool',\n    reason: 'PalletAssetsExistenceReason',\n    extra: 'Null'\n  },\n  /**\n   * Lookup349: pallet_assets::types::ExistenceReason<Balance>\n   **/\n  PalletAssetsExistenceReason: {\n    _enum: {\n      Consumer: 'Null',\n      Sufficient: 'Null',\n      DepositHeld: 'u128',\n      DepositRefunded: 'Null'\n    }\n  },\n  /**\n   * Lookup351: pallet_assets::types::Approval<Balance, DepositBalance>\n   **/\n  PalletAssetsApproval: {\n    amount: 'u128',\n    deposit: 'u128'\n  },\n  /**\n   * Lookup352: pallet_assets::types::AssetMetadata<DepositBalance, sp_runtime::bounded::bounded_vec::BoundedVec<T, S>>\n   **/\n  PalletAssetsAssetMetadata: {\n    deposit: 'u128',\n    name: 'Bytes',\n    symbol: 'Bytes',\n    decimals: 'u8',\n    isFrozen: 'bool'\n  },\n  /**\n   * Lookup354: pallet_assets::pallet::Error<T, I>\n   **/\n  PalletAssetsError: {\n    _enum: ['BalanceLow', 'NoAccount', 'NoPermission', 'Unknown', 'Frozen', 'InUse', 'BadWitness', 'MinBalanceZero', 'NoProvider', 'BadMetadata', 'Unapproved', 'WouldDie', 'AlreadyExists', 'NoDeposit', 'WouldBurn']\n  },\n  /**\n   * Lookup358: frame_support::PalletId\n   **/\n  FrameSupportPalletId: '[u8;8]',\n  /**\n   * Lookup359: pallet_assets_ext::pallet::Error<T>\n   **/\n  PalletAssetsExtError: {\n    _enum: ['NoAvailableIds', 'BalanceLow', 'NoAccount', 'Overflow', 'MaxHolds', 'CreateAssetFailed']\n  },\n  /**\n   * Lookup361: pallet_authorship::UncleEntryItem<BlockNumber, primitive_types::H256, seed_primitives::signature::AccountId20>\n   **/\n  PalletAuthorshipUncleEntryItem: {\n    _enum: {\n      InclusionHeight: 'u32',\n      Uncle: '(H256,Option<SeedPrimitivesSignatureAccountId20>)'\n    }\n  },\n  /**\n   * Lookup363: pallet_authorship::pallet::Error<T>\n   **/\n  PalletAuthorshipError: {\n    _enum: ['InvalidUncleParent', 'UnclesAlreadySet', 'TooManyUncles', 'GenesisUncle', 'TooHighUncle', 'UncleAlreadyIncluded', 'OldUncle']\n  },\n  /**\n   * Lookup364: pallet_staking::StakingLedger<T>\n   **/\n  PalletStakingStakingLedger: {\n    stash: 'SeedPrimitivesSignatureAccountId20',\n    total: 'Compact<u128>',\n    active: 'Compact<u128>',\n    unlocking: 'Vec<PalletStakingUnlockChunk>',\n    claimedRewards: 'Vec<u32>'\n  },\n  /**\n   * Lookup366: pallet_staking::UnlockChunk<Balance>\n   **/\n  PalletStakingUnlockChunk: {\n    value: 'Compact<u128>',\n    era: 'Compact<u32>'\n  },\n  /**\n   * Lookup368: pallet_staking::Nominations<T>\n   **/\n  PalletStakingNominations: {\n    targets: 'Vec<SeedPrimitivesSignatureAccountId20>',\n    submittedIn: 'u32',\n    suppressed: 'bool'\n  },\n  /**\n   * Lookup370: pallet_staking::ActiveEraInfo\n   **/\n  PalletStakingActiveEraInfo: {\n    index: 'u32',\n    start: 'Option<u64>'\n  },\n  /**\n   * Lookup371: pallet_staking::EraRewardPoints<seed_primitives::signature::AccountId20>\n   **/\n  PalletStakingEraRewardPoints: {\n    total: 'u32',\n    individual: 'BTreeMap<SeedPrimitivesSignatureAccountId20, u32>'\n  },\n  /**\n   * Lookup375: pallet_staking::Forcing\n   **/\n  PalletStakingForcing: {\n    _enum: ['NotForcing', 'ForceNew', 'ForceNone', 'ForceAlways']\n  },\n  /**\n   * Lookup377: pallet_staking::UnappliedSlash<seed_primitives::signature::AccountId20, Balance>\n   **/\n  PalletStakingUnappliedSlash: {\n    validator: 'SeedPrimitivesSignatureAccountId20',\n    own: 'u128',\n    others: 'Vec<(SeedPrimitivesSignatureAccountId20,u128)>',\n    reporters: 'Vec<SeedPrimitivesSignatureAccountId20>',\n    payout: 'u128'\n  },\n  /**\n   * Lookup379: pallet_staking::slashing::SlashingSpans\n   **/\n  PalletStakingSlashingSlashingSpans: {\n    spanIndex: 'u32',\n    lastStart: 'u32',\n    lastNonzeroSlash: 'u32',\n    prior: 'Vec<u32>'\n  },\n  /**\n   * Lookup380: pallet_staking::slashing::SpanRecord<Balance>\n   **/\n  PalletStakingSlashingSpanRecord: {\n    slashed: 'u128',\n    paidOut: 'u128'\n  },\n  /**\n   * Lookup383: pallet_staking::Releases\n   **/\n  PalletStakingReleases: {\n    _enum: ['V1_0_0Ancient', 'V2_0_0', 'V3_0_0', 'V4_0_0', 'V5_0_0', 'V6_0_0', 'V7_0_0', 'V8_0_0', 'V9_0_0', 'V10_0_0']\n  },\n  /**\n   * Lookup384: pallet_staking::pallet::pallet::Error<T>\n   **/\n  PalletStakingPalletError: {\n    _enum: ['NotController', 'NotStash', 'AlreadyBonded', 'AlreadyPaired', 'EmptyTargets', 'DuplicateIndex', 'InvalidSlashIndex', 'InsufficientBond', 'NoMoreChunks', 'NoUnlockChunk', 'FundedTarget', 'InvalidEraToReward', 'InvalidNumberOfNominations', 'NotSortedAndUnique', 'AlreadyClaimed', 'IncorrectHistoryDepth', 'IncorrectSlashingSpans', 'BadState', 'TooManyTargets', 'BadTarget', 'CannotChillOther', 'TooManyNominators', 'TooManyValidators', 'CommissionTooLow']\n  },\n  /**\n   * Lookup385: sp_staking::offence::OffenceDetails<seed_primitives::signature::AccountId20, Offender>\n   **/\n  SpStakingOffenceOffenceDetails: {\n    offender: '(SeedPrimitivesSignatureAccountId20,PalletStakingExposure)',\n    reporters: 'Vec<SeedPrimitivesSignatureAccountId20>'\n  },\n  /**\n   * Lookup390: sp_core::crypto::KeyTypeId\n   **/\n  SpCoreCryptoKeyTypeId: '[u8;4]',\n  /**\n   * Lookup391: pallet_session::pallet::Error<T>\n   **/\n  PalletSessionError: {\n    _enum: ['InvalidProof', 'NoAssociatedValidatorId', 'DuplicatedKey', 'NoKeys', 'NoAccount']\n  },\n  /**\n   * Lookup392: pallet_grandpa::StoredState<N>\n   **/\n  PalletGrandpaStoredState: {\n    _enum: {\n      Live: 'Null',\n      PendingPause: {\n        scheduledAt: 'u32',\n        delay: 'u32',\n      },\n      Paused: 'Null',\n      PendingResume: {\n        scheduledAt: 'u32',\n        delay: 'u32'\n      }\n    }\n  },\n  /**\n   * Lookup393: pallet_grandpa::StoredPendingChange<N, Limit>\n   **/\n  PalletGrandpaStoredPendingChange: {\n    scheduledAt: 'u32',\n    delay: 'u32',\n    nextAuthorities: 'Vec<(SpFinalityGrandpaAppPublic,u64)>',\n    forced: 'Option<u32>'\n  },\n  /**\n   * Lookup395: pallet_grandpa::pallet::Error<T>\n   **/\n  PalletGrandpaError: {\n    _enum: ['PauseFailed', 'ResumeFailed', 'ChangePending', 'TooSoon', 'InvalidKeyOwnershipProof', 'InvalidEquivocationProof', 'DuplicateOffenceReport']\n  },\n  /**\n   * Lookup399: pallet_im_online::BoundedOpaqueNetworkState<PeerIdEncodingLimit, MultiAddrEncodingLimit, AddressesLimit>\n   **/\n  PalletImOnlineBoundedOpaqueNetworkState: {\n    peerId: 'Bytes',\n    externalAddresses: 'Vec<Bytes>'\n  },\n  /**\n   * Lookup403: pallet_im_online::pallet::Error<T>\n   **/\n  PalletImOnlineError: {\n    _enum: ['InvalidKey', 'DuplicatedHeartbeat']\n  },\n  /**\n   * Lookup404: pallet_sudo::pallet::Error<T>\n   **/\n  PalletSudoError: {\n    _enum: ['RequireSudo']\n  },\n  /**\n   * Lookup406: pallet_transaction_payment::Releases\n   **/\n  PalletTransactionPaymentReleases: {\n    _enum: ['V1Ancient', 'V2']\n  },\n  /**\n   * Lookup408: pallet_dex::TradingPairStatus\n   **/\n  PalletDexTradingPairStatus: {\n    _enum: ['NotEnabled', 'Enabled']\n  },\n  /**\n   * Lookup409: pallet_dex::pallet::Error<T>\n   **/\n  PalletDexError: {\n    _enum: ['MustBeEnabled', 'MustBeNotEnabled', 'InsufficientInputAmount', 'InvalidInputAmounts', 'InsufficientAmount', 'InsufficientAmountA', 'InsufficientAmountB', 'InsufficientLiquidityBurnt', 'InsufficientWithdrawnAmountA', 'InsufficientWithdrawnAmountB', 'InsufficientOutputAmount', 'InvalidLiquidityIncrement', 'InvalidConstantProduct', 'IdenticalTokenAddress', 'InvalidAssetId', 'InvalidTradingPathLength', 'InsufficientTargetAmount', 'ExcessiveSupplyAmount', 'InsufficientLiquidity', 'ZeroSupplyAmount', 'ZeroTargetAmount', 'UnacceptableShareIncrement', 'LiquidityProviderTokenNotCreated']\n  },\n  /**\n   * Lookup410: pallet_nft::types::CollectionInformation<seed_primitives::signature::AccountId20, MaxTokensPerCollection>\n   **/\n  PalletNftCollectionInformation: {\n    owner: 'SeedPrimitivesSignatureAccountId20',\n    name: 'Bytes',\n    metadataScheme: 'Bytes',\n    royaltiesSchedule: 'Option<PalletNftRoyaltiesSchedule>',\n    maxIssuance: 'Option<u32>',\n    originChain: 'PalletNftOriginChain',\n    nextSerialNumber: 'u32',\n    collectionIssuance: 'u32',\n    crossChainCompatibility: 'PalletNftCrossChainCompatibility',\n    ownedTokens: 'Vec<PalletNftTokenOwnership>'\n  },\n  /**\n   * Lookup412: pallet_nft::types::TokenOwnership<seed_primitives::signature::AccountId20, MaxTokensPerCollection>\n   **/\n  PalletNftTokenOwnership: {\n    owner: 'SeedPrimitivesSignatureAccountId20',\n    ownedSerials: 'Vec<u32>'\n  },\n  /**\n   * Lookup414: pallet_nft::types::TokenLockReason\n   **/\n  PalletNftTokenLockReason: {\n    _enum: {\n      Listed: 'u128'\n    }\n  },\n  /**\n   * Lookup415: pallet_nft::types::Marketplace<seed_primitives::signature::AccountId20>\n   **/\n  PalletNftMarketplace: {\n    account: 'SeedPrimitivesSignatureAccountId20',\n    entitlement: 'Permill'\n  },\n  /**\n   * Lookup416: pallet_nft::types::Listing<T>\n   **/\n  PalletNftListing: {\n    _enum: {\n      FixedPrice: 'PalletNftFixedPriceListing',\n      Auction: 'PalletNftAuctionListing'\n    }\n  },\n  /**\n   * Lookup417: pallet_nft::types::FixedPriceListing<T>\n   **/\n  PalletNftFixedPriceListing: {\n    paymentAsset: 'u32',\n    fixedPrice: 'u128',\n    close: 'u32',\n    buyer: 'Option<SeedPrimitivesSignatureAccountId20>',\n    seller: 'SeedPrimitivesSignatureAccountId20',\n    collectionId: 'u32',\n    serialNumbers: 'Vec<u32>',\n    royaltiesSchedule: 'PalletNftRoyaltiesSchedule',\n    marketplaceId: 'Option<u32>'\n  },\n  /**\n   * Lookup418: pallet_nft::types::AuctionListing<T>\n   **/\n  PalletNftAuctionListing: {\n    paymentAsset: 'u32',\n    reservePrice: 'u128',\n    close: 'u32',\n    seller: 'SeedPrimitivesSignatureAccountId20',\n    collectionId: 'u32',\n    serialNumbers: 'Vec<u32>',\n    royaltiesSchedule: 'PalletNftRoyaltiesSchedule',\n    marketplaceId: 'Option<u32>'\n  },\n  /**\n   * Lookup420: pallet_nft::types::OfferType<seed_primitives::signature::AccountId20>\n   **/\n  PalletNftOfferType: {\n    _enum: {\n      Simple: 'PalletNftSimpleOffer'\n    }\n  },\n  /**\n   * Lookup421: pallet_nft::types::SimpleOffer<seed_primitives::signature::AccountId20>\n   **/\n  PalletNftSimpleOffer: {\n    tokenId: '(u32,u32)',\n    assetId: 'u32',\n    amount: 'u128',\n    buyer: 'SeedPrimitivesSignatureAccountId20',\n    marketplaceId: 'Option<u32>'\n  },\n  /**\n   * Lookup424: pallet_nft::pallet::Error<T>\n   **/\n  PalletNftError: {\n    _enum: ['CollectionNameInvalid', 'NoAvailableIds', 'NotTokenOwner', 'NoToken', 'NotForFixedPriceSale', 'NotForAuction', 'NotCollectionOwner', 'TokenNotListed', 'MaxOffersReached', 'TokenLocked', 'RoyaltiesInvalid', 'BidTooLow', 'MixedBundleSale', 'MarketplaceNotRegistered', 'NoCollectionFound', 'InvalidMetadataPath', 'InvalidOffer', 'NotBuyer', 'NotSeller', 'IsTokenOwner', 'ZeroOffer', 'TokenLimitExceeded', 'MintLimitExceeded', 'TokenOnAuction', 'InvalidMaxIssuance', 'MaxIssuanceAlreadySet', 'MaxIssuanceReached', 'AttemptedMintOnBridgedToken', 'CannotClaimNonClaimableCollections', 'InitialIssuanceNotZero', 'CollectionIssuanceNotZero']\n  },\n  /**\n   * Lookup428: pallet_xrpl_bridge::helpers::XrpTransaction\n   **/\n  PalletXrplBridgeHelpersXrpTransaction: {\n    transactionHash: 'H512',\n    transaction: 'PalletXrplBridgeHelpersXrplTxData',\n    timestamp: 'u64'\n  },\n  /**\n   * Lookup429: pallet_xrpl_bridge::helpers::XrplTicketSequenceParams\n   **/\n  PalletXrplBridgeHelpersXrplTicketSequenceParams: {\n    startSequence: 'u32',\n    bucketSize: 'u32'\n  },\n  /**\n   * Lookup430: pallet_xrpl_bridge::pallet::Error<T>\n   **/\n  PalletXrplBridgeError: {\n    _enum: ['NotPermitted', 'RelayerDoesNotExists', 'WithdrawInvalidAmount', 'DoorAddressNotSet', 'TooManySigners', 'InvalidSigners', 'TxReplay', 'NextTicketSequenceParamsNotSet', 'NextTicketSequenceParamsInvalid', 'TicketSequenceParamsInvalid', 'CannotProcessMoreTransactionsAtThatBlock']\n  },\n  /**\n   * Lookup433: pallet_token_approvals::pallet::Error<T>\n   **/\n  PalletTokenApprovalsError: {\n    _enum: ['NoToken', 'NotTokenOwner', 'NotTokenOwnerOrApproved', 'CallerNotOperator', 'ApprovedAmountTooLow', 'CallerNotApproved', 'AlreadyApproved', 'ApprovalDoesntExist']\n  },\n  /**\n   * Lookup434: pallet_echo::pallet::Error<T>\n   **/\n  PalletEchoError: {\n    _enum: ['NoAvailableIds', 'InvalidParameter', 'InvalidAbiEncoding']\n  },\n  /**\n   * Lookup435: pallet_election_provider_multi_phase::Phase<Bn>\n   **/\n  PalletElectionProviderMultiPhasePhase: {\n    _enum: {\n      Off: 'Null',\n      Signed: 'Null',\n      Unsigned: '(bool,u32)',\n      Emergency: 'Null'\n    }\n  },\n  /**\n   * Lookup437: pallet_election_provider_multi_phase::ReadySolution<seed_primitives::signature::AccountId20>\n   **/\n  PalletElectionProviderMultiPhaseReadySolution: {\n    supports: 'Vec<(SeedPrimitivesSignatureAccountId20,SpNposElectionsSupport)>',\n    score: 'SpNposElectionsElectionScore',\n    compute: 'PalletElectionProviderMultiPhaseElectionCompute'\n  },\n  /**\n   * Lookup438: pallet_election_provider_multi_phase::RoundSnapshot<T>\n   **/\n  PalletElectionProviderMultiPhaseRoundSnapshot: {\n    voters: 'Vec<(SeedPrimitivesSignatureAccountId20,u64,Vec<SeedPrimitivesSignatureAccountId20>)>',\n    targets: 'Vec<SeedPrimitivesSignatureAccountId20>'\n  },\n  /**\n   * Lookup445: pallet_election_provider_multi_phase::signed::SignedSubmission<seed_primitives::signature::AccountId20, Balance, seed_runtime::NposCompactSolution16>\n   **/\n  PalletElectionProviderMultiPhaseSignedSignedSubmission: {\n    who: 'SeedPrimitivesSignatureAccountId20',\n    deposit: 'u128',\n    rawSolution: 'PalletElectionProviderMultiPhaseRawSolution',\n    callFee: 'u128'\n  },\n  /**\n   * Lookup446: pallet_election_provider_multi_phase::pallet::Error<T>\n   **/\n  PalletElectionProviderMultiPhaseError: {\n    _enum: ['PreDispatchEarlySubmission', 'PreDispatchWrongWinnerCount', 'PreDispatchWeakSubmission', 'SignedQueueFull', 'SignedCannotPayDeposit', 'SignedInvalidWitness', 'SignedTooMuchWeight', 'OcwCallWrongEra', 'MissingSnapshotMetadata', 'InvalidSubmissionIndex', 'CallNotAllowed', 'FallbackFailed']\n  },\n  /**\n   * Lookup447: pallet_bags_list::list::Node<T, I>\n   **/\n  PalletBagsListListNode: {\n    id: 'SeedPrimitivesSignatureAccountId20',\n    prev: 'Option<SeedPrimitivesSignatureAccountId20>',\n    next: 'Option<SeedPrimitivesSignatureAccountId20>',\n    bagUpper: 'u64',\n    score: 'u64'\n  },\n  /**\n   * Lookup448: pallet_bags_list::list::Bag<T, I>\n   **/\n  PalletBagsListListBag: {\n    head: 'Option<SeedPrimitivesSignatureAccountId20>',\n    tail: 'Option<SeedPrimitivesSignatureAccountId20>'\n  },\n  /**\n   * Lookup449: pallet_bags_list::pallet::Error<T, I>\n   **/\n  PalletBagsListError: {\n    _enum: {\n      List: 'PalletBagsListListListError'\n    }\n  },\n  /**\n   * Lookup450: pallet_bags_list::list::ListError\n   **/\n  PalletBagsListListListError: {\n    _enum: ['Duplicate', 'NotHeavier', 'NotInSameBag', 'NodeNotFound']\n  },\n  /**\n   * Lookup452: pallet_ethy::types::EventClaimStatus\n   **/\n  PalletEthyEventClaimStatus: {\n    _enum: ['Pending', 'Challenged', 'ProvenValid']\n  },\n  /**\n   * Lookup456: pallet_ethy::types::CheckedEthCallRequest\n   **/\n  PalletEthyCheckedEthCallRequest: {\n    input: 'Bytes',\n    target: 'H160',\n    timestamp: 'u64',\n    maxBlockLookBehind: 'u64',\n    tryBlockNumber: 'u64',\n    checkTimestamp: 'u64'\n  },\n  /**\n   * Lookup457: pallet_ethy::Error<T>\n   **/\n  PalletEthyError: {\n    _enum: ['NoLocalSigningAccount', 'OffchainUnsignedTxSignedPayload', 'InvalidNotarization', 'HttpFetch', 'InvalidClaim', 'OcwConfig', 'EventReplayPending', 'EventReplayProcessed', 'BridgePaused', 'Internal', 'NoPermission', 'NoClaim', 'ClaimAlreadyChallenged', 'CantUnbondRelayer', 'CantBondRelayer', 'NoBondPaid', 'MaxNewSignersExceeded']\n  },\n  /**\n   * Lookup460: fp_rpc::TransactionStatus\n   **/\n  FpRpcTransactionStatus: {\n    transactionHash: 'H256',\n    transactionIndex: 'u32',\n    from: 'H160',\n    to: 'Option<H160>',\n    contractAddress: 'Option<H160>',\n    logs: 'Vec<EthereumLog>',\n    logsBloom: 'EthbloomBloom'\n  },\n  /**\n   * Lookup463: ethbloom::Bloom\n   **/\n  EthbloomBloom: '[u8;256]',\n  /**\n   * Lookup465: ethereum::receipt::ReceiptV3\n   **/\n  EthereumReceiptReceiptV3: {\n    _enum: {\n      Legacy: 'EthereumReceiptEip658ReceiptData',\n      EIP2930: 'EthereumReceiptEip658ReceiptData',\n      EIP1559: 'EthereumReceiptEip658ReceiptData'\n    }\n  },\n  /**\n   * Lookup466: ethereum::receipt::EIP658ReceiptData\n   **/\n  EthereumReceiptEip658ReceiptData: {\n    statusCode: 'u8',\n    usedGas: 'U256',\n    logsBloom: 'EthbloomBloom',\n    logs: 'Vec<EthereumLog>'\n  },\n  /**\n   * Lookup467: ethereum::block::Block<ethereum::transaction::TransactionV2>\n   **/\n  EthereumBlock: {\n    header: 'EthereumHeader',\n    transactions: 'Vec<EthereumTransactionTransactionV2>',\n    ommers: 'Vec<EthereumHeader>'\n  },\n  /**\n   * Lookup468: ethereum::header::Header\n   **/\n  EthereumHeader: {\n    parentHash: 'H256',\n    ommersHash: 'H256',\n    beneficiary: 'H160',\n    stateRoot: 'H256',\n    transactionsRoot: 'H256',\n    receiptsRoot: 'H256',\n    logsBloom: 'EthbloomBloom',\n    difficulty: 'U256',\n    number: 'U256',\n    gasLimit: 'U256',\n    gasUsed: 'U256',\n    timestamp: 'u64',\n    extraData: 'Bytes',\n    mixHash: 'H256',\n    nonce: 'EthereumTypesHashH64'\n  },\n  /**\n   * Lookup469: ethereum_types::hash::H64\n   **/\n  EthereumTypesHashH64: '[u8;8]',\n  /**\n   * Lookup474: pallet_ethereum::pallet::Error<T>\n   **/\n  PalletEthereumError: {\n    _enum: ['InvalidSignature', 'PreLogExists', 'GasLimitTooLow', 'GasLimitTooHigh', 'GasPriceTooLow', 'BalanceLow', 'InvalidNonce', 'Undefined']\n  },\n  /**\n   * Lookup476: pallet_evm::pallet::Error<T>\n   **/\n  PalletEvmError: {\n    _enum: ['BalanceLow', 'FeeOverflow', 'PaymentOverflow', 'WithdrawFailed', 'GasPriceTooLow', 'InvalidNonce', 'GasLimitTooLow', 'GasLimitTooHigh', 'Undefined']\n  },\n  /**\n   * Lookup479: pallet_erc20_peg::types::PendingPayment\n   **/\n  PalletErc20PegPendingPayment: {\n    _enum: {\n      Deposit: 'PalletErc20PegErc20DepositEvent',\n      Withdrawal: 'PalletErc20PegWithdrawMessage'\n    }\n  },\n  /**\n   * Lookup480: pallet_erc20_peg::types::Erc20DepositEvent\n   **/\n  PalletErc20PegErc20DepositEvent: {\n    tokenAddress: 'H160',\n    amount: 'U256',\n    beneficiary: 'H160'\n  },\n  /**\n   * Lookup481: pallet_erc20_peg::types::WithdrawMessage\n   **/\n  PalletErc20PegWithdrawMessage: {\n    tokenAddress: 'H160',\n    amount: 'U256',\n    beneficiary: 'H160'\n  },\n  /**\n   * Lookup482: pallet_erc20_peg::Error<T>\n   **/\n  PalletErc20PegError: {\n    _enum: ['CreateAssetFailed', 'InvalidAmount', 'InvalidPalletId', 'DepositsPaused', 'WithdrawalsPaused', 'UnsupportedAsset', 'EvmWithdrawalFailed', 'InvalidAbiEncoding']\n  },\n  /**\n   * Lookup483: pallet_nft_peg::pallet::Error<T>\n   **/\n  PalletNftPegError: {\n    _enum: ['ExceedsMaxAddresses', 'ExceedsMaxTokens', 'InvalidAbiEncoding', 'InvalidAbiPrefix', 'NoCollectionFound', 'NoMappedTokenExists', 'NoPermissionToBridge', 'StateSyncDisabled', 'TokenListLengthMismatch', 'ExceedsMaxVecLength']\n  },\n  /**\n   * Lookup484: pallet_fee_proxy::pallet::Error<T>\n   **/\n  PalletFeeProxyError: {\n    _enum: ['NestedFeePreferenceCall', 'FeeTokenIsGasToken']\n  },\n  /**\n   * Lookup485: pallet_fee_control::FeeConfig\n   **/\n  PalletFeeControlFeeConfig: {\n    evmBaseFeePerGas: 'U256',\n    weightMultiplier: 'Perbill',\n    lengthMultiplier: 'u128'\n  },\n  /**\n   * Lookup486: pallet_xls20::pallet::Error<T>\n   **/\n  PalletXls20Error: {\n    _enum: ['NotRelayer', 'MappingAlreadyExists', 'Xls20MintFeeTooLow', 'NotXLS20Compatible', 'NoToken', 'NotCollectionOwner']\n  },\n  /**\n   * Lookup489: pallet_proxy::ProxyDefinition<seed_primitives::signature::AccountId20, seed_runtime::impls::ProxyType, BlockNumber>\n   **/\n  PalletProxyProxyDefinition: {\n    delegate: 'SeedPrimitivesSignatureAccountId20',\n    proxyType: 'SeedRuntimeImplsProxyType',\n    delay: 'u32'\n  },\n  /**\n   * Lookup493: pallet_proxy::Announcement<seed_primitives::signature::AccountId20, primitive_types::H256, BlockNumber>\n   **/\n  PalletProxyAnnouncement: {\n    real: 'SeedPrimitivesSignatureAccountId20',\n    callHash: 'H256',\n    height: 'u32'\n  },\n  /**\n   * Lookup495: pallet_proxy::pallet::Error<T>\n   **/\n  PalletProxyError: {\n    _enum: ['TooMany', 'NotFound', 'NotProxy', 'Unproxyable', 'Duplicate', 'NoPermission', 'Unannounced', 'NoSelfProxy']\n  },\n  /**\n   * Lookup496: pallet_futurepass::pallet::Error<T>\n   **/\n  PalletFuturepassError: {\n    _enum: ['AccountAlreadyRegistered', 'DelegateNotRegistered', 'DelegateAlreadyExists', 'NotFuturepassOwner', 'OwnerCannotUnregister', 'PermissionDenied', 'MigratorNotSet']\n  },\n  /**\n   * Lookup498: seed_primitives::signature::EthereumSignature\n   **/\n  SeedPrimitivesSignatureEthereumSignature: 'SpCoreEcdsaSignature',\n  /**\n   * Lookup500: frame_system::extensions::check_non_zero_sender::CheckNonZeroSender<T>\n   **/\n  FrameSystemExtensionsCheckNonZeroSender: 'Null',\n  /**\n   * Lookup501: frame_system::extensions::check_spec_version::CheckSpecVersion<T>\n   **/\n  FrameSystemExtensionsCheckSpecVersion: 'Null',\n  /**\n   * Lookup502: frame_system::extensions::check_tx_version::CheckTxVersion<T>\n   **/\n  FrameSystemExtensionsCheckTxVersion: 'Null',\n  /**\n   * Lookup503: frame_system::extensions::check_genesis::CheckGenesis<T>\n   **/\n  FrameSystemExtensionsCheckGenesis: 'Null',\n  /**\n   * Lookup506: frame_system::extensions::check_nonce::CheckNonce<T>\n   **/\n  FrameSystemExtensionsCheckNonce: 'Compact<u32>',\n  /**\n   * Lookup507: frame_system::extensions::check_weight::CheckWeight<T>\n   **/\n  FrameSystemExtensionsCheckWeight: 'Null',\n  /**\n   * Lookup508: pallet_transaction_payment::ChargeTransactionPayment<T>\n   **/\n  PalletTransactionPaymentChargeTransactionPayment: 'Compact<u128>',\n  /**\n   * Lookup510: seed_runtime::Runtime\n   **/\n  SeedRuntimeRuntime: 'Null'\n};\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/index.ts",{"fileContent":"/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport type { OverrideVersionedType } from '@polkadot/types/types';\n\nimport { rpc as ormlRpc, types as ormlTypes, typesAlias as ormlAlias } from '@open-web3/orml-type-definitions';\nimport { jsonrpcFromDefs, typesAliasFromDefs, typesFromDefs } from '@open-web3/orml-type-definitions/utils';\n\nimport rootnetVersioned from './spec/rootnet';\nimport porciniVersioned from './spec/porcini';\nimport dex from './dex';\nimport ethy from './ethy';\nimport ethWallet from './ethWallet';\nimport xrplBridge from './xrplBridge';\nimport nft from './nft';\nimport runtime from './runtime';\n\nconst rootDefs = {\n  dex,\n  ethy,\n  ethWallet,\n  xrplBridge,\n  nft,\n  runtime,\n};\n\nexport const types = {\n  ...ormlTypes,\n  ...typesFromDefs(rootDefs),\n};\n\nexport const rpc = jsonrpcFromDefs(rootDefs, { ...ormlRpc });\nexport const typesAlias = typesAliasFromDefs(rootDefs, { ...ormlAlias });\n\nfunction getBundle (versioned: OverrideVersionedType[]) {\n  return {\n    rpc,\n    instances: { council: ['generalCouncil'] },\n    types: [...versioned].map((version) => {\n      return {\n        minmax: version.minmax,\n        types: {\n          ...types,\n          ...version.types\n        }\n      };\n    }),\n    alias: typesAlias\n  };\n}\n\nexport const typesBundle = {\n  spec: {\n    root: getBundle(rootnetVersioned),\n    porcini: getBundle(porciniVersioned),\n  }\n};\n\n// Type overrides have priority issues\nexport const typesBundleForPolkadot = {\n  spec: {\n    root: getBundle(rootnetVersioned),\n    porcini: getBundle(porciniVersioned),\n  }\n};\n\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/spec/rootnet.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/spec/porcini.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/dex.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/ethy.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/ethWallet.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/xrplBridge.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/nft.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/runtime.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/spec/rootnet.ts",{"fileContent":"import type { OverrideVersionedType } from '@polkadot/types/types';\n\n\nconst versioned: OverrideVersionedType[] = [\n    {\n  \"minmax\": [\n    0,\n    null\n  ],\n  \"types\": {\n    \"AccountId\": \"EthereumAccountId\",\n    \"AccountId20\": \"EthereumAccountId\",\n    \"AccountId32\": \"EthereumAccountId\",\n    \"Address\": \"AccountId\",\n    \"LookupSource\": \"AccountId\",\n    \"Lookup0\": \"AccountId\",\n    \"AssetId\": \"u32\",\n    \"Balance\": \"u128\",\n    \"EventProofId\": \"u64\",\n    \"ValidatorSetId\": \"u64\",\n    \"EthereumSignature\": {\n      \"r\": \"H256\",\n      \"s\": \"H256\",\n      \"v\": \"U8\"\n    },\n    \"ExtrinsicSignature\": \"EthereumSignature\",\n    \"EthyId\": \"[u8; 32]\",\n    \"EthWalletCall\": {\n      \"nonce\": \"u32\"\n    },\n    \"XRPLTxData\": {\n      \"_enum\": {\n        Payment: {\n          amount: \"Balance\",\n          destination: \"H160\"\n        },\n        CurrencyPayment: {\n          \"amount\": \"Balance\",\n          \"address\": \"H160\",\n          \"currencyId\": \"H256\"\n        }\n      }\n    } as any,\n    \"EthEventProofResponse\": {\n      \"event_id\": \"EventProofId\",\n      \"signatures\": \"Vec<Bytes>\",\n      \"validators\": \"Vec<AccountId20>\",\n      \"validator_set_id\": \"ValidatorSetId\",\n      \"block\": \"H256\",\n      \"tag\": \"Option<Bytes>\"\n    },\n    \"XrplEventProofResponse\": {\n      \"event_id\": \"EventProofId\",\n      \"signatures\": \"Vec<Bytes>\",\n      \"validators\": \"Vec<Bytes>\",\n      \"validator_set_id\": \"ValidatorSetId\",\n      \"block\": \"H256\",\n      \"tag\": \"Option<Bytes>\"\n    },\n    \"VersionedEventProof\": {\n      \"_enum\": {\n        \"sentinel\": null,\n        \"EventProof\": \"EventProof\"\n      }\n    },\n    \"CollectionUuid\": \"u32\",\n    \"SerialNumber\": \"u32\",\n    \"TokenId\": \"(CollectionUuid, SerialNumber)\"\n  }\n}\n]\n\nexport default versioned;\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/spec/porcini.ts",{"fileContent":"import versioned from './rootnet';\n\nexport default versioned;\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/spec/rootnet.ts"]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/dex.ts",{"fileContent":"export default {\n  rpc: {\n    \"quote\": {\n      \"description\": \"Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\",\n      \"params\": [\n        {\n          \"name\": \"amountA\",\n          \"type\": \"u128\"\n        },\n        {\n          \"name\": \"reserveA\",\n          \"type\": \"u128\"\n        },\n        {\n          \"name\": \"reserveB\",\n          \"type\": \"u128\"\n        }\n      ],\n      \"type\": \"Json\"\n    },\n    \"getAmountsOut\": {\n      \"description\": \"Given an array of AssetIds, return amounts out for an amount in\",\n      \"params\": [\n        {\n          \"name\": \"amountIn\",\n          \"type\": \"Balance\"\n        },\n        {\n          \"name\": \"path\",\n          \"type\": \"Vec<AssetId>\"\n        }\n      ],\n      \"type\": \"Json\"\n    },\n    \"getAmountsIn\": {\n      \"description\": \"Given an array of AssetIds, return amounts in for an amount out\",\n      \"params\": [\n        {\n          \"name\": \"amountOut\",\n          \"type\": \"Balance\"\n        },\n        {\n          \"name\": \"path\",\n          \"type\": \"Vec<AssetId>\"\n        }\n      ],\n      \"type\": \"Json\"\n    },\n    \"getLPTokenID\": {\n      \"description\": \"Given two AssetIds, return liquidity token created for the pair\",\n      \"params\": [\n        {\n          \"name\": \"assetA\",\n          \"type\": \"AssetId\"\n        },\n        {\n          \"name\": \"assetB\",\n          \"type\": \"AssetId\"\n        }\n      ],\n      \"type\": \"Json\"\n    },\n    \"getLiquidity\": {\n      \"description\": \"Given two AssetIds, return liquidity\",\n      \"params\": [\n        {\n          \"name\": \"assetA\",\n          \"type\": \"AssetId\"\n        },\n        {\n          \"name\": \"assetB\",\n          \"type\": \"AssetId\"\n        }\n      ],\n      \"type\": \"Json\"\n    },\n    \"getTradingPairStatus\": {\n      \"description\": \"Given two AssetIds, return whether trading pair is enabled or disabled\",\n      \"params\": [\n        {\n          \"name\": \"assetA\",\n          \"type\": \"AssetId\"\n        },\n        {\n          \"name\": \"assetB\",\n          \"type\": \"AssetId\"\n        }\n      ],\n      \"type\": \"Json\"\n    }\n  },\n  types: {}\n};\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/ethy.ts",{"fileContent":"export default {\n  rpc: {\n    \"getEventProof\": {\n      \"description\": \"Get ETH event proof for event Id\",\n      \"params\": [\n        {\n          \"name\": \"eventId\",\n          \"type\": \"EventProofId\"\n        }\n      ],\n      \"type\": \"Option<EthEventProofResponse>\"\n    },\n    \"getXrplTxProof\": {\n      \"description\": \"Get XRPL event proof for event Id\",\n      \"params\": [\n        {\n          \"name\": \"eventId\",\n          \"type\": \"EventProofId\"\n        }\n      ],\n      \"type\": \"Option<XrplEventProofResponse>\"\n    },\n    subscribeEventProofs: {\n      alias: ['ethy_subscribeEventProofs', 'ethy_unsubscribeEventProofs'],\n      description: 'Subscribe to Eth event proof.',\n      params: [],\n      pubsub: [\n        'subscribeEventProofs',\n        'unsubscribeEventProofs',\n      ],\n      type: 'Null'\n    },\n  },\n  types: {\n    VersionedEventProof: {\n      _enum: {\n        sentinel: null,\n        EventProof: \"EventProof\",\n      },\n    },\n    ExtrinsicSignature: \"EthereumSignature\",\n    EthyId: \"[u8; 32]\",\n    EthyEventId: \"u64\",\n    EthEventProofResponse: {\n      \"event_id\": \"EventProofId\",\n      \"signatures\": \"Vec<Bytes>\",\n      \"validators\": \"Vec<AccountId20>\",\n      \"validator_set_id\": \"ValidatorSetId\",\n      \"block\": \"H256\",\n      \"tag\": \"Option<Bytes>\"\n    },\n    EventProofId: \"u64\",\n    EthereumSignature: {\n      r: \"H256\",\n      s: \"H256\",\n      v: \"U8\",\n    },\n  }\n};\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/ethWallet.ts",{"fileContent":"export default {\n  rpc: {},\n  types: {\n    EthWalletCall: {\n      nonce: \"u32\",\n    },\n  }\n};\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/xrplBridge.ts",{"fileContent":"export default {\n  rpc: {},\n  types: {\n    XRPLTxData: {\n      _enum: {\n        Payment: {\n          amount: \"Balance\",\n          destination: \"H160\",\n        },\n        CurrencyPayment: {\n          amount: \"Balance\",\n          address: \"H160\",\n          currencyId: \"H256\",\n        },\n      },\n      //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    XrplEventProofResponse: {\n      \"event_id\": \"EventProofId\",\n      \"signatures\": \"Vec<Bytes>\",\n      \"validators\": \"Vec<Bytes>\",\n      \"validator_set_id\": \"ValidatorSetId\",\n      \"block\": \"H256\",\n      \"tag\": \"Option<Bytes>\"\n    },\n  }\n};\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/nft.ts",{"fileContent":"export default {\n  rpc: {\n    \"ownedTokens\": {\n      \"description\": \"Get all NFTs owned by an account\",\n      \"params\": [\n        {\n          \"name\": \"collectionId\",\n          \"type\": \"CollectionUuid\"\n        },\n        {\n          \"name\": \"who\",\n          \"type\": \"AccountId\"\n        },\n        { \"name\": \"cursor\", \"type\": \"SerialNumber\" },\n        { \"name\": \"limit\", \"type\": \"u16\" }\n      ],\n      \"type\": \"Json\"\n    },\n    \"tokenUri\": {\n      \"description\": \"Get the URI of a token\",\n      \"params\": [\n        {\n          \"name\": \"tokenId\",\n          \"type\": \"TokenId\"\n        }\n      ],\n      \"type\": \"Json\"\n    }\n  },\n  types: {\n    \"CollectionUuid\": \"u32\",\n    \"SerialNumber\": \"u32\",\n    \"TokenId\": \"(CollectionUuid, SerialNumber)\"\n  },\n};\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/type-definitions/src/runtime.ts",{"fileContent":"export default {\n  rpc: {},\n  types: {\n    \"AccountId\": \"EthereumAccountId\",\n    \"AccountId20\": \"EthereumAccountId\",\n    \"AccountId32\": \"EthereumAccountId\",\n    \"Address\": \"AccountId\",\n    \"LookupSource\": \"AccountId\",\n    \"Lookup0\": \"AccountId\",\n    \"AssetId\": \"u32\",\n    \"Balance\": \"u128\",\n  }\n};\n","resolvedModuleNames":[]}],["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/dex.e2e.ts",{"fileContent":"\nimport {ApiPromise, Keyring, WsProvider} from \"@polkadot/api\";\nimport {options} from \"@therootnetwork/api\";\nimport {hexToU8a} from \"@polkadot/util\";\n\nexport const ALITH_PRIVATE_KEY = \"0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133\";\nexport const BOB_PRIVATE_KEY = \"0x79c3b7fc0b7697b9414cb87adcb37317d1cab32818ae18c0e97ad76395d1fdcf\";\nconst TOKEN_ID = 1124;\nexport const GAS_TOKEN_ID = 2;\n\ndescribe('DEX RPC calls testing', () => {\n  let api;\n  let alith, bob;\n  beforeAll(async () => {\n    const providerUrl = 'ws://127.0.0.1:9944/';\n    const provider = new WsProvider(providerUrl);\n    console.log('providerUrl', providerUrl);\n    api = new ApiPromise(options({ provider }));\n    await api.isReady;\n    const keyring = new Keyring({ type: \"ethereum\" });\n    alith = keyring.addFromSeed(hexToU8a(ALITH_PRIVATE_KEY));\n    bob = keyring.addFromSeed(hexToU8a(BOB_PRIVATE_KEY));\n  });\n\n  afterAll(async () => {\n    api.disconnect();\n  });\n\n  describe('Queries()', () => {\n\n    it.skip(\"Deposit liquidity in DEX asset's pool\",  async () => {\n      const txs = [\n        api.tx.assetsExt.createAsset(\"test\", \"TEST\", 18, 1, alith.address), // create asset\n        api.tx.assets.mint(TOKEN_ID, alith.address, \"10000000000000000\"),\n        api.tx.dex.addLiquidity(\n            // provide liquidity\n            TOKEN_ID,\n            GAS_TOKEN_ID,\n            \"1000000000000000\",\n            250_000_000,\n            \"10000000000000000\",\n            250_000_000,\n            0,\n        ),\n      ];\n\n      await new Promise<void>((resolve, reject) => {\n        api.tx.utility\n            .batch(txs)\n            .signAndSend(alith, ({ events, status }) => {\n              if (status.isInBlock) {\n                console.log(`setup block hash: ${status.asInBlock}`);\n                  for (const {event} of events) {\n                    if (event.method === 'AddLiquidity') {\n                      resolve();\n                    }\n                  }\n              }\n            })\n            .catch((err) => reject(err));\n      });\n\n      console.log(\"done setting up dex liquidity.\");\n          });\n\n    it(\"getAmountsOut rpc works\", async () => {\n      const result = await (api.rpc as any).dex.getAmountsOut(100, [GAS_TOKEN_ID, TOKEN_ID]);\n      expect(result.toJSON()).toEqual({\"Ok\":[100, 398799840]});\n    });\n\n    it(\"quote rpc works\", async () => {\n      const result = await api.rpc.dex.quote(1, 5, 10);\n      expect(result.toJSON()).toEqual({\"Ok\":2});\n    });\n\n    /// TODO add more test for happy and sad flow\n  });\n});\n","resolvedModuleNames":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/src/index.ts","/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/index.ts"]}]]