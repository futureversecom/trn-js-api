f49bbe980bd364ee3e54eca5d96c17dd
"use strict";
// // Copyright 2019-2020 Centrality Investments Limited
// //
// // Licensed under the Apache License, Version 2.0 (the "License");
// // you may not use this file except in compliance with the License.
// // You may obtain a copy of the License at
// //
// //     http://www.apache.org/licenses/LICENSE-2.0
// //
// // Unless required by applicable law or agreed to in writing, software
// // distributed under the License is distributed on an "AS IS" BASIS,
// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// // See the License for the specific language governing permissions and
// // limitations under the License.
//
// import {AssetInfoV40 as AssetInfo, AssetOptions, Balance, LiquidityPriceResponse} from "@cennznet/types";
// import {cvmToAddress} from "@cennznet/types/utils";
// import { SubmittableResult } from '@polkadot/api';
// import { Keyring } from '@polkadot/keyring';
// import { KeyringPair } from '@polkadot/keyring/types';
// import { stringToHex } from '@polkadot/util';
// import { cryptoWaitReady } from '@polkadot/util-crypto';
// import initApiPromise from '../../../../jest/initApiPromise';
// import { SingleAccountSigner } from "./util/SingleAccountSigner";
// import { mock } from '@depay/web3-mock'
//
// const keyring = new Keyring({ type: 'sr25519' });
//
describe.skip('e2e transactions', () => { });
//   let api;
//   let alice, bob;
//   let spendingAssetId, stakingAssetId;
//
//   beforeAll(async () => {
//     await cryptoWaitReady();
//     api = await initApiPromise();
//     alice = keyring.addFromUri('//Alice');
//     bob = keyring.addFromUri('//Bob');
//
//     spendingAssetId = await api.query.genericAsset.spendingAssetId();
//     stakingAssetId = await api.query.genericAsset.stakingAssetId();
//
//     mock('ethereum');
//   });
//
//   afterAll(async () => {
//     await api.disconnect();
//   });
//
//   describe('Send', () => {
//
//     it('Makes a tx using immortal era', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(bob.address);
//       await api.tx.genericAsset
//         .transfer(stakingAssetId, alice.address, 100)
//         .signAndSend(bob, { nonce },
//           async ({ events, status }: SubmittableResult) => {
//             if (status.isInBlock) {
//               expect(events[0].event.method).toEqual('Transferred');
//               expect(events[0].event.section).toEqual('genericAsset');
//               done();
//             }
//           });
//     });
//
//     it('Makes a tx via send', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(bob.address);
//       const tx = api.tx.genericAsset
//         .transfer(stakingAssetId, alice.address, 1)
//         .sign(bob, { nonce });
//       await tx.send(async ({ events, status }: SubmittableResult) => {
//         if (status.isInBlock) {
//           expect(events[0].event.method).toEqual('Transferred');
//           expect(events[0].event.section).toEqual('genericAsset');
//           done();
//         }
//       });
//     });
//
//     it('Makes a tx', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(bob.address);
//       await api.tx.genericAsset
//         .transfer(stakingAssetId, alice.address, 1)
//         .signAndSend(bob, { nonce }, async ({ events, status }: SubmittableResult) => {
//           if (status.isInBlock) {
//             expect(events[0].event.method).toEqual('Transferred');
//             expect(events[0].event.section).toEqual('genericAsset');
//             done();
//           }
//         });
//     });
//
//   });
//
//   describe('Eth signining txs', () => {
//
//     it('Convert eth address to cennznet address', async done => {
//       const ethAddress = '0x5D5586341ca72146791C33c26c0c10eD971c9B53';
//       const cennznetAddress = cvmToAddress(ethAddress);
//       console.log('cennznetAddress:',cennznetAddress);
//       expect(cennznetAddress).toEqual('5EK7n4pa3FcCGoxvoqUFJM8CD6fngE31G4rAjqLYW2bXtstn');
//       done();
//     });
//
//     it('Uses eth wallet to sign', async done => {
//       const ethAddress = '0x5d5586341ca72146791c33c26c0c10ed971c9b53';
//       // Find the equivalent CENNZnet address for Ethereum address and send some CPAY to spend on txs
//       const cennznetAddress = cvmToAddress(ethAddress);
//       const amount = 100000;
//       const nonce = await api.rpc.system.accountNextIndex(alice.address);
//       const fundTransferred = new Promise<void>(async (resolve, reject) => {
//         await api.tx.genericAsset
//             .transfer(stakingAssetId, cennznetAddress, amount)
//             .signAndSend(
//                 alice,
//                 { nonce });
//         await api.tx.genericAsset
//             .transfer(spendingAssetId, cennznetAddress, amount)
//             .signAndSend(
//                 alice,
//                 { nonce: nonce+1 }, ({ status }) => status.isInBlock ? resolve() : null
//             );
//       });
//       fundTransferred.then(async () => {
//         // Start with a connected wallet
//         const accounts = [ethAddress];
//         mock({
//           blockchain: 'ethereum',
//           accounts: {return: accounts},
//           signature: {
//             params: [accounts[0], 'sign'],
//             return: "0xc8ee1390bc05479bb4e13eb36b46714af19821eb590142e3f8fb7d972f6f31fb070717be960e41e4ec33baf85776c43e5be588916e7c41ee20ad99c6695fa7fa1b"
//           }
//         });
//
//
//         const transferAmt = 20000;
//         await api.tx.genericAsset
//             .transfer(stakingAssetId, alice.address, transferAmt)
//             .signViaEthWallet(
//                 ethAddress,
//                 api,
//                 (global as any).ethereum,  async ({ events, status }: SubmittableResult) => {
//                   if (status.isInBlock) {
//                     expect(events[0].event.method).toEqual('Transferred');
//                     expect(events[0].event.section).toEqual('genericAsset');
//                     done();
//                   }
//                 }
//             );
//       });
//     });
//   });
//
//   describe('Extrinsic payment options', () => {
//     // A generic asset to be used for fee payment
//     let feeAssetId;
//     // This account will own the newly created asset and receive initial issuance
//     // It will also mint liquidity on CENNZ-X
//     let assetOwner: KeyringPair;
//
//     beforeAll(async done => {
//       // Setup:
//       // Create a new generic asset and mint a liquidity pool on CENNZX.
//       // This fee asset will be used for fee payment in place of the default asset, CPAY.
//       assetOwner = keyring.addFromUri('//Test//AssetOwner');
//
//       // Amount of test asset to create
//       const initialIssuance = 900_000_000_000_000;
//       const owner = api.registry.createType('Owner', assetOwner.address, 1); // Owner type is enum with 0 as none/null
//       const permissions = api.registry.createType('PermissionsV1', { update: owner, mint: owner, burn: owner});
//       const option = {initialIssuance , permissions};
//       const assetOption: AssetOptions = api.registry.createType('AssetOptions', option);
//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'TEST', decimalPlaces: 4, existentialDeposit: 5});
//       let createAssetTx = api.tx.genericAsset.create(assetOwner.address, assetOption, assetInfo);
//
//       // Lookup from keyring (assuming we have added all, on --dev this would be `//Alice`)
//       const sudoAddress = await api.query.sudo.key();
//       const sudoKeypair = keyring.getPair(sudoAddress.toString());
//
//       // when the new asset is created it will have this ID.
//       feeAssetId = await api.query.genericAsset.nextAssetId();
//
//       // 1) Create the new fee asset
//       // 2) Mint CPAY to assetOwner to fund subsequent pool liquidity and further transactions.
//       const assetCreated = new Promise<void>(async (resolve, reject) => {
//         let nonce = await api.rpc.system.accountNextIndex(sudoAddress);
//         await api.tx.sudo.sudo(createAssetTx).signAndSend(sudoKeypair, { nonce: nonce++ });
//         await api.tx.genericAsset.mint(spendingAssetId, assetOwner.address, initialIssuance).signAndSend(
//           sudoKeypair, { nonce: nonce++ }, ({ status }) => status.isInBlock ? resolve() : null
//         );
//       });
//
//       // 3) Mint liquidity for fee asset <> CPAY.
//       assetCreated.then(async () => {
//         const desiredLiquidity = 30_000_000;
//         const minimumLiquidity = 1;
//         const liquidityPrice: LiquidityPriceResponse = await (api.rpc.cennzx.liquidityPrice(feeAssetId, desiredLiquidity));
//         await api.tx.cennzx
//           .addLiquidity(feeAssetId, minimumLiquidity, liquidityPrice.asset, liquidityPrice.core)
//           .signAndSend(assetOwner, ({ events, status }) => status.isInBlock ? done() :null );
//
//       });
//
//     });
//
//     it('Uses keypair to sign', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);
//       await api.tx.genericAsset
//         .transfer(spendingAssetId, bob.address, 100)
//         .setPaymentOpts(api, {feeAssetId: feeAssetId, slippage: 0, tip: 0})
//         .signAndSend(
//           assetOwner,
//           { nonce },
//           ({ status }) => status.isInBlock ? done() : null
//         );
//     });
//
//     it('Use tip along with fee exchange', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);
//       await api.tx.genericAsset
//         .transfer(spendingAssetId, bob.address, 100)
//         .setPaymentOpts(api, { feeAssetId: feeAssetId, slippage: 0, tip: 2})
//         .signAndSend(
//           assetOwner,
//           { nonce },
//           ({ status }) => (status.isInBlock) ? done() : null
//       );
//     });
//
//     it('Use slippage for max payment in transaction', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);
//       await api.tx.genericAsset
//         .transfer(spendingAssetId, bob.address, 100)
//         .setPaymentOpts(api, { feeAssetId: feeAssetId, slippage: 0.03})
//         .signAndSend(
//           assetOwner,
//           { nonce },
//           ({ status }) => (status.isInBlock) ? done() : null
//         );
//     });
//
//     it('Update asset info', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);
//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'NEW_ASSET_ID', decimalPlaces: 5, existentialDeposit: 5});
//       await api.tx.genericAsset.updateAssetInfo( feeAssetId, assetInfo).signAndSend(assetOwner, { nonce }, async ({ events, status }) => {
//         if (status.isInBlock) {
//           for (const { event: { method, section, data } } of events) {
//             if (section === 'genericAsset' && method == 'AssetInfoUpdated') {
//               const [assetId, assetMeta] = data;
//               expect(assetId as number).toEqual(feeAssetId);
//               expect(assetMeta.toJSON()).toEqual({
//                 existentialDeposit: 5,
//                 decimalPlaces: 5,
//                 symbol: stringToHex('NEW_ASSET_ID')
//               });
//
//               done();
//             }
//           }
//         }
//       });
//     });
//   });
//
//
//   describe('Signed via signer', () => {
//     it('should sign with a signer', async done => {
//       const dave = keyring.addFromUri('//Dave');
//       const signer = new SingleAccountSigner(api.registry, dave);
//       const transfer = api.tx.genericAsset.transfer(spendingAssetId, alice.address, 54121);
//       await transfer.signAndSend(dave.address, { signer }, async ({events, status}) => {
//         if (status.isInBlock) {
//           for (const {event: { method, section } } of events) {
//             if (section === 'genericAsset' && method == 'Transferred') {
//               done();
//             }
//           }
//         }
//       });
//     });
//   });
//
// });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2thcmlzaG1hL3dvcmsvZnV0dXJldmVyc2UvdHJuLXJvb3RuZXQtYXBpL3BhY2thZ2VzL2FwaS90ZXN0L2UyZS90eC5lMmUudHMiLCJtYXBwaW5ncyI6IjtBQUFBLHdEQUF3RDtBQUN4RCxLQUFLO0FBQ0wscUVBQXFFO0FBQ3JFLHNFQUFzRTtBQUN0RSw2Q0FBNkM7QUFDN0MsS0FBSztBQUNMLG9EQUFvRDtBQUNwRCxLQUFLO0FBQ0wseUVBQXlFO0FBQ3pFLHVFQUF1RTtBQUN2RSw4RUFBOEU7QUFDOUUseUVBQXlFO0FBQ3pFLG9DQUFvQztBQUNwQyxFQUFFO0FBQ0YsNEdBQTRHO0FBQzVHLHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQsK0NBQStDO0FBQy9DLHlEQUF5RDtBQUN6RCxnREFBZ0Q7QUFDaEQsMkRBQTJEO0FBQzNELGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUNGLFFBQVEsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDLENBQUM7QUFDNUMsYUFBYTtBQUNiLG9CQUFvQjtBQUNwQix5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDLDZDQUE2QztBQUM3Qyx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSxzRUFBc0U7QUFDdEUsRUFBRTtBQUNGLHdCQUF3QjtBQUN4QixRQUFRO0FBQ1IsRUFBRTtBQUNGLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSLEVBQUU7QUFDRiw2QkFBNkI7QUFDN0IsRUFBRTtBQUNGLDBEQUEwRDtBQUMxRCwwRUFBMEU7QUFDMUUsa0NBQWtDO0FBQ2xDLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMsK0RBQStEO0FBQy9ELHNDQUFzQztBQUN0Qyx1RUFBdUU7QUFDdkUseUVBQXlFO0FBQ3pFLHdCQUF3QjtBQUN4Qixn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QUFDRixNQUFNIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXJpc2htYS93b3JrL2Z1dHVyZXZlcnNlL3Rybi1yb290bmV0LWFwaS9wYWNrYWdlcy9hcGkvdGVzdC9lMmUvdHguZTJlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIC8vIENvcHlyaWdodCAyMDE5LTIwMjAgQ2VudHJhbGl0eSBJbnZlc3RtZW50cyBMaW1pdGVkXG4vLyAvL1xuLy8gLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIC8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIC8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gLy9cbi8vIC8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIC8vXG4vLyAvLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyAvLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyAvLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIC8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIC8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLy9cbi8vIGltcG9ydCB7QXNzZXRJbmZvVjQwIGFzIEFzc2V0SW5mbywgQXNzZXRPcHRpb25zLCBCYWxhbmNlLCBMaXF1aWRpdHlQcmljZVJlc3BvbnNlfSBmcm9tIFwiQGNlbm56bmV0L3R5cGVzXCI7XG4vLyBpbXBvcnQge2N2bVRvQWRkcmVzc30gZnJvbSBcIkBjZW5uem5ldC90eXBlcy91dGlsc1wiO1xuLy8gaW1wb3J0IHsgU3VibWl0dGFibGVSZXN1bHQgfSBmcm9tICdAcG9sa2Fkb3QvYXBpJztcbi8vIGltcG9ydCB7IEtleXJpbmcgfSBmcm9tICdAcG9sa2Fkb3Qva2V5cmluZyc7XG4vLyBpbXBvcnQgeyBLZXlyaW5nUGFpciB9IGZyb20gJ0Bwb2xrYWRvdC9rZXlyaW5nL3R5cGVzJztcbi8vIGltcG9ydCB7IHN0cmluZ1RvSGV4IH0gZnJvbSAnQHBvbGthZG90L3V0aWwnO1xuLy8gaW1wb3J0IHsgY3J5cHRvV2FpdFJlYWR5IH0gZnJvbSAnQHBvbGthZG90L3V0aWwtY3J5cHRvJztcbi8vIGltcG9ydCBpbml0QXBpUHJvbWlzZSBmcm9tICcuLi8uLi8uLi8uLi9qZXN0L2luaXRBcGlQcm9taXNlJztcbi8vIGltcG9ydCB7IFNpbmdsZUFjY291bnRTaWduZXIgfSBmcm9tIFwiLi91dGlsL1NpbmdsZUFjY291bnRTaWduZXJcIjtcbi8vIGltcG9ydCB7IG1vY2sgfSBmcm9tICdAZGVwYXkvd2ViMy1tb2NrJ1xuLy9cbi8vIGNvbnN0IGtleXJpbmcgPSBuZXcgS2V5cmluZyh7IHR5cGU6ICdzcjI1NTE5JyB9KTtcbi8vXG5kZXNjcmliZS5za2lwKCdlMmUgdHJhbnNhY3Rpb25zJywgKCkgPT4ge30pO1xuLy8gICBsZXQgYXBpO1xuLy8gICBsZXQgYWxpY2UsIGJvYjtcbi8vICAgbGV0IHNwZW5kaW5nQXNzZXRJZCwgc3Rha2luZ0Fzc2V0SWQ7XG4vL1xuLy8gICBiZWZvcmVBbGwoYXN5bmMgKCkgPT4ge1xuLy8gICAgIGF3YWl0IGNyeXB0b1dhaXRSZWFkeSgpO1xuLy8gICAgIGFwaSA9IGF3YWl0IGluaXRBcGlQcm9taXNlKCk7XG4vLyAgICAgYWxpY2UgPSBrZXlyaW5nLmFkZEZyb21VcmkoJy8vQWxpY2UnKTtcbi8vICAgICBib2IgPSBrZXlyaW5nLmFkZEZyb21VcmkoJy8vQm9iJyk7XG4vL1xuLy8gICAgIHNwZW5kaW5nQXNzZXRJZCA9IGF3YWl0IGFwaS5xdWVyeS5nZW5lcmljQXNzZXQuc3BlbmRpbmdBc3NldElkKCk7XG4vLyAgICAgc3Rha2luZ0Fzc2V0SWQgPSBhd2FpdCBhcGkucXVlcnkuZ2VuZXJpY0Fzc2V0LnN0YWtpbmdBc3NldElkKCk7XG4vL1xuLy8gICAgIG1vY2soJ2V0aGVyZXVtJyk7XG4vLyAgIH0pO1xuLy9cbi8vICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuLy8gICAgIGF3YWl0IGFwaS5kaXNjb25uZWN0KCk7XG4vLyAgIH0pO1xuLy9cbi8vICAgZGVzY3JpYmUoJ1NlbmQnLCAoKSA9PiB7XG4vL1xuLy8gICAgIGl0KCdNYWtlcyBhIHR4IHVzaW5nIGltbW9ydGFsIGVyYScsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGJvYi5hZGRyZXNzKTtcbi8vICAgICAgIGF3YWl0IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgLnRyYW5zZmVyKHN0YWtpbmdBc3NldElkLCBhbGljZS5hZGRyZXNzLCAxMDApXG4vLyAgICAgICAgIC5zaWduQW5kU2VuZChib2IsIHsgbm9uY2UgfSxcbi8vICAgICAgICAgICBhc3luYyAoeyBldmVudHMsIHN0YXR1cyB9OiBTdWJtaXR0YWJsZVJlc3VsdCkgPT4ge1xuLy8gICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5tZXRob2QpLnRvRXF1YWwoJ1RyYW5zZmVycmVkJyk7XG4vLyAgICAgICAgICAgICAgIGV4cGVjdChldmVudHNbMF0uZXZlbnQuc2VjdGlvbikudG9FcXVhbCgnZ2VuZXJpY0Fzc2V0Jyk7XG4vLyAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9KTtcbi8vICAgICB9KTtcbi8vXG4vLyAgICAgaXQoJ01ha2VzIGEgdHggdmlhIHNlbmQnLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgYXBpLnJwYy5zeXN0ZW0uYWNjb3VudE5leHRJbmRleChib2IuYWRkcmVzcyk7XG4vLyAgICAgICBjb25zdCB0eCA9IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgLnRyYW5zZmVyKHN0YWtpbmdBc3NldElkLCBhbGljZS5hZGRyZXNzLCAxKVxuLy8gICAgICAgICAuc2lnbihib2IsIHsgbm9uY2UgfSk7XG4vLyAgICAgICBhd2FpdCB0eC5zZW5kKGFzeW5jICh7IGV2ZW50cywgc3RhdHVzIH06IFN1Ym1pdHRhYmxlUmVzdWx0KSA9PiB7XG4vLyAgICAgICAgIGlmIChzdGF0dXMuaXNJbkJsb2NrKSB7XG4vLyAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5tZXRob2QpLnRvRXF1YWwoJ1RyYW5zZmVycmVkJyk7XG4vLyAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5zZWN0aW9uKS50b0VxdWFsKCdnZW5lcmljQXNzZXQnKTtcbi8vICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICBpdCgnTWFrZXMgYSB0eCcsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGJvYi5hZGRyZXNzKTtcbi8vICAgICAgIGF3YWl0IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgLnRyYW5zZmVyKHN0YWtpbmdBc3NldElkLCBhbGljZS5hZGRyZXNzLCAxKVxuLy8gICAgICAgICAuc2lnbkFuZFNlbmQoYm9iLCB7IG5vbmNlIH0sIGFzeW5jICh7IGV2ZW50cywgc3RhdHVzIH06IFN1Ym1pdHRhYmxlUmVzdWx0KSA9PiB7XG4vLyAgICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICAgIGV4cGVjdChldmVudHNbMF0uZXZlbnQubWV0aG9kKS50b0VxdWFsKCdUcmFuc2ZlcnJlZCcpO1xuLy8gICAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5zZWN0aW9uKS50b0VxdWFsKCdnZW5lcmljQXNzZXQnKTtcbi8vICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgfSk7XG4vL1xuLy8gICBkZXNjcmliZSgnRXRoIHNpZ25pbmluZyB0eHMnLCAoKSA9PiB7XG4vL1xuLy8gICAgIGl0KCdDb252ZXJ0IGV0aCBhZGRyZXNzIHRvIGNlbm56bmV0IGFkZHJlc3MnLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgIGNvbnN0IGV0aEFkZHJlc3MgPSAnMHg1RDU1ODYzNDFjYTcyMTQ2NzkxQzMzYzI2YzBjMTBlRDk3MWM5QjUzJztcbi8vICAgICAgIGNvbnN0IGNlbm56bmV0QWRkcmVzcyA9IGN2bVRvQWRkcmVzcyhldGhBZGRyZXNzKTtcbi8vICAgICAgIGNvbnNvbGUubG9nKCdjZW5uem5ldEFkZHJlc3M6JyxjZW5uem5ldEFkZHJlc3MpO1xuLy8gICAgICAgZXhwZWN0KGNlbm56bmV0QWRkcmVzcykudG9FcXVhbCgnNUVLN240cGEzRmNDR294dm9xVUZKTThDRDZmbmdFMzFHNHJBanFMWVcyYlh0c3RuJyk7XG4vLyAgICAgICBkb25lKCk7XG4vLyAgICAgfSk7XG4vL1xuLy8gICAgIGl0KCdVc2VzIGV0aCB3YWxsZXQgdG8gc2lnbicsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3QgZXRoQWRkcmVzcyA9ICcweDVkNTU4NjM0MWNhNzIxNDY3OTFjMzNjMjZjMGMxMGVkOTcxYzliNTMnO1xuLy8gICAgICAgLy8gRmluZCB0aGUgZXF1aXZhbGVudCBDRU5OWm5ldCBhZGRyZXNzIGZvciBFdGhlcmV1bSBhZGRyZXNzIGFuZCBzZW5kIHNvbWUgQ1BBWSB0byBzcGVuZCBvbiB0eHNcbi8vICAgICAgIGNvbnN0IGNlbm56bmV0QWRkcmVzcyA9IGN2bVRvQWRkcmVzcyhldGhBZGRyZXNzKTtcbi8vICAgICAgIGNvbnN0IGFtb3VudCA9IDEwMDAwMDtcbi8vICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgYXBpLnJwYy5zeXN0ZW0uYWNjb3VudE5leHRJbmRleChhbGljZS5hZGRyZXNzKTtcbi8vICAgICAgIGNvbnN0IGZ1bmRUcmFuc2ZlcnJlZCA9IG5ldyBQcm9taXNlPHZvaWQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbi8vICAgICAgICAgYXdhaXQgYXBpLnR4LmdlbmVyaWNBc3NldFxuLy8gICAgICAgICAgICAgLnRyYW5zZmVyKHN0YWtpbmdBc3NldElkLCBjZW5uem5ldEFkZHJlc3MsIGFtb3VudClcbi8vICAgICAgICAgICAgIC5zaWduQW5kU2VuZChcbi8vICAgICAgICAgICAgICAgICBhbGljZSxcbi8vICAgICAgICAgICAgICAgICB7IG5vbmNlIH0pO1xuLy8gICAgICAgICBhd2FpdCBhcGkudHguZ2VuZXJpY0Fzc2V0XG4vLyAgICAgICAgICAgICAudHJhbnNmZXIoc3BlbmRpbmdBc3NldElkLCBjZW5uem5ldEFkZHJlc3MsIGFtb3VudClcbi8vICAgICAgICAgICAgIC5zaWduQW5kU2VuZChcbi8vICAgICAgICAgICAgICAgICBhbGljZSxcbi8vICAgICAgICAgICAgICAgICB7IG5vbmNlOiBub25jZSsxIH0sICh7IHN0YXR1cyB9KSA9PiBzdGF0dXMuaXNJbkJsb2NrID8gcmVzb2x2ZSgpIDogbnVsbFxuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgIH0pO1xuLy8gICAgICAgZnVuZFRyYW5zZmVycmVkLnRoZW4oYXN5bmMgKCkgPT4ge1xuLy8gICAgICAgICAvLyBTdGFydCB3aXRoIGEgY29ubmVjdGVkIHdhbGxldFxuLy8gICAgICAgICBjb25zdCBhY2NvdW50cyA9IFtldGhBZGRyZXNzXTtcbi8vICAgICAgICAgbW9jayh7XG4vLyAgICAgICAgICAgYmxvY2tjaGFpbjogJ2V0aGVyZXVtJyxcbi8vICAgICAgICAgICBhY2NvdW50czoge3JldHVybjogYWNjb3VudHN9LFxuLy8gICAgICAgICAgIHNpZ25hdHVyZToge1xuLy8gICAgICAgICAgICAgcGFyYW1zOiBbYWNjb3VudHNbMF0sICdzaWduJ10sXG4vLyAgICAgICAgICAgICByZXR1cm46IFwiMHhjOGVlMTM5MGJjMDU0NzliYjRlMTNlYjM2YjQ2NzE0YWYxOTgyMWViNTkwMTQyZTNmOGZiN2Q5NzJmNmYzMWZiMDcwNzE3YmU5NjBlNDFlNGVjMzNiYWY4NTc3NmM0M2U1YmU1ODg5MTZlN2M0MWVlMjBhZDk5YzY2OTVmYTdmYTFiXCJcbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy9cbi8vXG4vLyAgICAgICAgIGNvbnN0IHRyYW5zZmVyQW10ID0gMjAwMDA7XG4vLyAgICAgICAgIGF3YWl0IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgICAgIC50cmFuc2ZlcihzdGFraW5nQXNzZXRJZCwgYWxpY2UuYWRkcmVzcywgdHJhbnNmZXJBbXQpXG4vLyAgICAgICAgICAgICAuc2lnblZpYUV0aFdhbGxldChcbi8vICAgICAgICAgICAgICAgICBldGhBZGRyZXNzLFxuLy8gICAgICAgICAgICAgICAgIGFwaSxcbi8vICAgICAgICAgICAgICAgICAoZ2xvYmFsIGFzIGFueSkuZXRoZXJldW0sICBhc3luYyAoeyBldmVudHMsIHN0YXR1cyB9OiBTdWJtaXR0YWJsZVJlc3VsdCkgPT4ge1xuLy8gICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5tZXRob2QpLnRvRXF1YWwoJ1RyYW5zZmVycmVkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChldmVudHNbMF0uZXZlbnQuc2VjdGlvbikudG9FcXVhbCgnZ2VuZXJpY0Fzc2V0Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgfSk7XG4vLyAgICAgfSk7XG4vLyAgIH0pO1xuLy9cbi8vICAgZGVzY3JpYmUoJ0V4dHJpbnNpYyBwYXltZW50IG9wdGlvbnMnLCAoKSA9PiB7XG4vLyAgICAgLy8gQSBnZW5lcmljIGFzc2V0IHRvIGJlIHVzZWQgZm9yIGZlZSBwYXltZW50XG4vLyAgICAgbGV0IGZlZUFzc2V0SWQ7XG4vLyAgICAgLy8gVGhpcyBhY2NvdW50IHdpbGwgb3duIHRoZSBuZXdseSBjcmVhdGVkIGFzc2V0IGFuZCByZWNlaXZlIGluaXRpYWwgaXNzdWFuY2Vcbi8vICAgICAvLyBJdCB3aWxsIGFsc28gbWludCBsaXF1aWRpdHkgb24gQ0VOTlotWFxuLy8gICAgIGxldCBhc3NldE93bmVyOiBLZXlyaW5nUGFpcjtcbi8vXG4vLyAgICAgYmVmb3JlQWxsKGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgLy8gU2V0dXA6XG4vLyAgICAgICAvLyBDcmVhdGUgYSBuZXcgZ2VuZXJpYyBhc3NldCBhbmQgbWludCBhIGxpcXVpZGl0eSBwb29sIG9uIENFTk5aWC5cbi8vICAgICAgIC8vIFRoaXMgZmVlIGFzc2V0IHdpbGwgYmUgdXNlZCBmb3IgZmVlIHBheW1lbnQgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgYXNzZXQsIENQQVkuXG4vLyAgICAgICBhc3NldE93bmVyID0ga2V5cmluZy5hZGRGcm9tVXJpKCcvL1Rlc3QvL0Fzc2V0T3duZXInKTtcbi8vXG4vLyAgICAgICAvLyBBbW91bnQgb2YgdGVzdCBhc3NldCB0byBjcmVhdGVcbi8vICAgICAgIGNvbnN0IGluaXRpYWxJc3N1YW5jZSA9IDkwMF8wMDBfMDAwXzAwMF8wMDA7XG4vLyAgICAgICBjb25zdCBvd25lciA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdPd25lcicsIGFzc2V0T3duZXIuYWRkcmVzcywgMSk7IC8vIE93bmVyIHR5cGUgaXMgZW51bSB3aXRoIDAgYXMgbm9uZS9udWxsXG4vLyAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdQZXJtaXNzaW9uc1YxJywgeyB1cGRhdGU6IG93bmVyLCBtaW50OiBvd25lciwgYnVybjogb3duZXJ9KTtcbi8vICAgICAgIGNvbnN0IG9wdGlvbiA9IHtpbml0aWFsSXNzdWFuY2UgLCBwZXJtaXNzaW9uc307XG4vLyAgICAgICBjb25zdCBhc3NldE9wdGlvbjogQXNzZXRPcHRpb25zID0gYXBpLnJlZ2lzdHJ5LmNyZWF0ZVR5cGUoJ0Fzc2V0T3B0aW9ucycsIG9wdGlvbik7XG4vLyAgICAgICBjb25zdCBhc3NldEluZm86IEFzc2V0SW5mbyA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdBc3NldEluZm8nLCB7c3ltYm9sOiAnVEVTVCcsIGRlY2ltYWxQbGFjZXM6IDQsIGV4aXN0ZW50aWFsRGVwb3NpdDogNX0pO1xuLy8gICAgICAgbGV0IGNyZWF0ZUFzc2V0VHggPSBhcGkudHguZ2VuZXJpY0Fzc2V0LmNyZWF0ZShhc3NldE93bmVyLmFkZHJlc3MsIGFzc2V0T3B0aW9uLCBhc3NldEluZm8pO1xuLy9cbi8vICAgICAgIC8vIExvb2t1cCBmcm9tIGtleXJpbmcgKGFzc3VtaW5nIHdlIGhhdmUgYWRkZWQgYWxsLCBvbiAtLWRldiB0aGlzIHdvdWxkIGJlIGAvL0FsaWNlYClcbi8vICAgICAgIGNvbnN0IHN1ZG9BZGRyZXNzID0gYXdhaXQgYXBpLnF1ZXJ5LnN1ZG8ua2V5KCk7XG4vLyAgICAgICBjb25zdCBzdWRvS2V5cGFpciA9IGtleXJpbmcuZ2V0UGFpcihzdWRvQWRkcmVzcy50b1N0cmluZygpKTtcbi8vXG4vLyAgICAgICAvLyB3aGVuIHRoZSBuZXcgYXNzZXQgaXMgY3JlYXRlZCBpdCB3aWxsIGhhdmUgdGhpcyBJRC5cbi8vICAgICAgIGZlZUFzc2V0SWQgPSBhd2FpdCBhcGkucXVlcnkuZ2VuZXJpY0Fzc2V0Lm5leHRBc3NldElkKCk7XG4vL1xuLy8gICAgICAgLy8gMSkgQ3JlYXRlIHRoZSBuZXcgZmVlIGFzc2V0XG4vLyAgICAgICAvLyAyKSBNaW50IENQQVkgdG8gYXNzZXRPd25lciB0byBmdW5kIHN1YnNlcXVlbnQgcG9vbCBsaXF1aWRpdHkgYW5kIGZ1cnRoZXIgdHJhbnNhY3Rpb25zLlxuLy8gICAgICAgY29uc3QgYXNzZXRDcmVhdGVkID0gbmV3IFByb21pc2U8dm9pZD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuLy8gICAgICAgICBsZXQgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KHN1ZG9BZGRyZXNzKTtcbi8vICAgICAgICAgYXdhaXQgYXBpLnR4LnN1ZG8uc3VkbyhjcmVhdGVBc3NldFR4KS5zaWduQW5kU2VuZChzdWRvS2V5cGFpciwgeyBub25jZTogbm9uY2UrKyB9KTtcbi8vICAgICAgICAgYXdhaXQgYXBpLnR4LmdlbmVyaWNBc3NldC5taW50KHNwZW5kaW5nQXNzZXRJZCwgYXNzZXRPd25lci5hZGRyZXNzLCBpbml0aWFsSXNzdWFuY2UpLnNpZ25BbmRTZW5kKFxuLy8gICAgICAgICAgIHN1ZG9LZXlwYWlyLCB7IG5vbmNlOiBub25jZSsrIH0sICh7IHN0YXR1cyB9KSA9PiBzdGF0dXMuaXNJbkJsb2NrID8gcmVzb2x2ZSgpIDogbnVsbFxuLy8gICAgICAgICApO1xuLy8gICAgICAgfSk7XG4vL1xuLy8gICAgICAgLy8gMykgTWludCBsaXF1aWRpdHkgZm9yIGZlZSBhc3NldCA8PiBDUEFZLlxuLy8gICAgICAgYXNzZXRDcmVhdGVkLnRoZW4oYXN5bmMgKCkgPT4ge1xuLy8gICAgICAgICBjb25zdCBkZXNpcmVkTGlxdWlkaXR5ID0gMzBfMDAwXzAwMDtcbi8vICAgICAgICAgY29uc3QgbWluaW11bUxpcXVpZGl0eSA9IDE7XG4vLyAgICAgICAgIGNvbnN0IGxpcXVpZGl0eVByaWNlOiBMaXF1aWRpdHlQcmljZVJlc3BvbnNlID0gYXdhaXQgKGFwaS5ycGMuY2Vubnp4LmxpcXVpZGl0eVByaWNlKGZlZUFzc2V0SWQsIGRlc2lyZWRMaXF1aWRpdHkpKTtcbi8vICAgICAgICAgYXdhaXQgYXBpLnR4LmNlbm56eFxuLy8gICAgICAgICAgIC5hZGRMaXF1aWRpdHkoZmVlQXNzZXRJZCwgbWluaW11bUxpcXVpZGl0eSwgbGlxdWlkaXR5UHJpY2UuYXNzZXQsIGxpcXVpZGl0eVByaWNlLmNvcmUpXG4vLyAgICAgICAgICAgLnNpZ25BbmRTZW5kKGFzc2V0T3duZXIsICh7IGV2ZW50cywgc3RhdHVzIH0pID0+IHN0YXR1cy5pc0luQmxvY2sgPyBkb25lKCkgOm51bGwgKTtcbi8vXG4vLyAgICAgICB9KTtcbi8vXG4vLyAgICAgfSk7XG4vL1xuLy8gICAgIGl0KCdVc2VzIGtleXBhaXIgdG8gc2lnbicsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGFzc2V0T3duZXIuYWRkcmVzcyk7XG4vLyAgICAgICBhd2FpdCBhcGkudHguZ2VuZXJpY0Fzc2V0XG4vLyAgICAgICAgIC50cmFuc2ZlcihzcGVuZGluZ0Fzc2V0SWQsIGJvYi5hZGRyZXNzLCAxMDApXG4vLyAgICAgICAgIC5zZXRQYXltZW50T3B0cyhhcGksIHtmZWVBc3NldElkOiBmZWVBc3NldElkLCBzbGlwcGFnZTogMCwgdGlwOiAwfSlcbi8vICAgICAgICAgLnNpZ25BbmRTZW5kKFxuLy8gICAgICAgICAgIGFzc2V0T3duZXIsXG4vLyAgICAgICAgICAgeyBub25jZSB9LFxuLy8gICAgICAgICAgICh7IHN0YXR1cyB9KSA9PiBzdGF0dXMuaXNJbkJsb2NrID8gZG9uZSgpIDogbnVsbFxuLy8gICAgICAgICApO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICBpdCgnVXNlIHRpcCBhbG9uZyB3aXRoIGZlZSBleGNoYW5nZScsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGFzc2V0T3duZXIuYWRkcmVzcyk7XG4vLyAgICAgICBhd2FpdCBhcGkudHguZ2VuZXJpY0Fzc2V0XG4vLyAgICAgICAgIC50cmFuc2ZlcihzcGVuZGluZ0Fzc2V0SWQsIGJvYi5hZGRyZXNzLCAxMDApXG4vLyAgICAgICAgIC5zZXRQYXltZW50T3B0cyhhcGksIHsgZmVlQXNzZXRJZDogZmVlQXNzZXRJZCwgc2xpcHBhZ2U6IDAsIHRpcDogMn0pXG4vLyAgICAgICAgIC5zaWduQW5kU2VuZChcbi8vICAgICAgICAgICBhc3NldE93bmVyLFxuLy8gICAgICAgICAgIHsgbm9uY2UgfSxcbi8vICAgICAgICAgICAoeyBzdGF0dXMgfSkgPT4gKHN0YXR1cy5pc0luQmxvY2spID8gZG9uZSgpIDogbnVsbFxuLy8gICAgICAgKTtcbi8vICAgICB9KTtcbi8vXG4vLyAgICAgaXQoJ1VzZSBzbGlwcGFnZSBmb3IgbWF4IHBheW1lbnQgaW4gdHJhbnNhY3Rpb24nLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgYXBpLnJwYy5zeXN0ZW0uYWNjb3VudE5leHRJbmRleChhc3NldE93bmVyLmFkZHJlc3MpO1xuLy8gICAgICAgYXdhaXQgYXBpLnR4LmdlbmVyaWNBc3NldFxuLy8gICAgICAgICAudHJhbnNmZXIoc3BlbmRpbmdBc3NldElkLCBib2IuYWRkcmVzcywgMTAwKVxuLy8gICAgICAgICAuc2V0UGF5bWVudE9wdHMoYXBpLCB7IGZlZUFzc2V0SWQ6IGZlZUFzc2V0SWQsIHNsaXBwYWdlOiAwLjAzfSlcbi8vICAgICAgICAgLnNpZ25BbmRTZW5kKFxuLy8gICAgICAgICAgIGFzc2V0T3duZXIsXG4vLyAgICAgICAgICAgeyBub25jZSB9LFxuLy8gICAgICAgICAgICh7IHN0YXR1cyB9KSA9PiAoc3RhdHVzLmlzSW5CbG9jaykgPyBkb25lKCkgOiBudWxsXG4vLyAgICAgICAgICk7XG4vLyAgICAgfSk7XG4vL1xuLy8gICAgIGl0KCdVcGRhdGUgYXNzZXQgaW5mbycsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGFzc2V0T3duZXIuYWRkcmVzcyk7XG4vLyAgICAgICBjb25zdCBhc3NldEluZm86IEFzc2V0SW5mbyA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdBc3NldEluZm8nLCB7c3ltYm9sOiAnTkVXX0FTU0VUX0lEJywgZGVjaW1hbFBsYWNlczogNSwgZXhpc3RlbnRpYWxEZXBvc2l0OiA1fSk7XG4vLyAgICAgICBhd2FpdCBhcGkudHguZ2VuZXJpY0Fzc2V0LnVwZGF0ZUFzc2V0SW5mbyggZmVlQXNzZXRJZCwgYXNzZXRJbmZvKS5zaWduQW5kU2VuZChhc3NldE93bmVyLCB7IG5vbmNlIH0sIGFzeW5jICh7IGV2ZW50cywgc3RhdHVzIH0pID0+IHtcbi8vICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICBmb3IgKGNvbnN0IHsgZXZlbnQ6IHsgbWV0aG9kLCBzZWN0aW9uLCBkYXRhIH0gfSBvZiBldmVudHMpIHtcbi8vICAgICAgICAgICAgIGlmIChzZWN0aW9uID09PSAnZ2VuZXJpY0Fzc2V0JyAmJiBtZXRob2QgPT0gJ0Fzc2V0SW5mb1VwZGF0ZWQnKSB7XG4vLyAgICAgICAgICAgICAgIGNvbnN0IFthc3NldElkLCBhc3NldE1ldGFdID0gZGF0YTtcbi8vICAgICAgICAgICAgICAgZXhwZWN0KGFzc2V0SWQgYXMgbnVtYmVyKS50b0VxdWFsKGZlZUFzc2V0SWQpO1xuLy8gICAgICAgICAgICAgICBleHBlY3QoYXNzZXRNZXRhLnRvSlNPTigpKS50b0VxdWFsKHtcbi8vICAgICAgICAgICAgICAgICBleGlzdGVudGlhbERlcG9zaXQ6IDUsXG4vLyAgICAgICAgICAgICAgICAgZGVjaW1hbFBsYWNlczogNSxcbi8vICAgICAgICAgICAgICAgICBzeW1ib2w6IHN0cmluZ1RvSGV4KCdORVdfQVNTRVRfSUQnKVxuLy8gICAgICAgICAgICAgICB9KTtcbi8vXG4vLyAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy8gICB9KTtcbi8vXG4vL1xuLy8gICBkZXNjcmliZSgnU2lnbmVkIHZpYSBzaWduZXInLCAoKSA9PiB7XG4vLyAgICAgaXQoJ3Nob3VsZCBzaWduIHdpdGggYSBzaWduZXInLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgIGNvbnN0IGRhdmUgPSBrZXlyaW5nLmFkZEZyb21VcmkoJy8vRGF2ZScpO1xuLy8gICAgICAgY29uc3Qgc2lnbmVyID0gbmV3IFNpbmdsZUFjY291bnRTaWduZXIoYXBpLnJlZ2lzdHJ5LCBkYXZlKTtcbi8vICAgICAgIGNvbnN0IHRyYW5zZmVyID0gYXBpLnR4LmdlbmVyaWNBc3NldC50cmFuc2ZlcihzcGVuZGluZ0Fzc2V0SWQsIGFsaWNlLmFkZHJlc3MsIDU0MTIxKTtcbi8vICAgICAgIGF3YWl0IHRyYW5zZmVyLnNpZ25BbmRTZW5kKGRhdmUuYWRkcmVzcywgeyBzaWduZXIgfSwgYXN5bmMgKHtldmVudHMsIHN0YXR1c30pID0+IHtcbi8vICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICBmb3IgKGNvbnN0IHtldmVudDogeyBtZXRob2QsIHNlY3Rpb24gfSB9IG9mIGV2ZW50cykge1xuLy8gICAgICAgICAgICAgaWYgKHNlY3Rpb24gPT09ICdnZW5lcmljQXNzZXQnICYmIG1ldGhvZCA9PSAnVHJhbnNmZXJyZWQnKSB7XG4vLyAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy8gICB9KTtcbi8vXG4vLyB9KTtcbiJdLCJ2ZXJzaW9uIjozfQ==