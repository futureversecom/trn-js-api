{"file":"/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-query.ts","mappings":";AAAA,mEAAmE;AACnE,oBAAoB;;AAEpB,8DAA8D;AAC9D,6DAA6D;AAC7D,4CAA0C","names":[],"sources":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-query.ts"],"sourcesContent":["// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/api-base/types/storage';\n\nimport type { ApiTypes, AugmentedQuery, QueryableStorageEntry } from '@polkadot/api-base/types';\nimport type { BTreeMap, Bytes, Option, U256, U8aFixed, Vec, WrapperOpaque, bool, u128, u32, u64, u8 } from '@polkadot/types-codec';\nimport type { AnyNumber, ITuple } from '@polkadot/types-codec/types';\nimport type { EthereumBlock, EthereumReceiptReceiptV3, EthereumTransactionTransactionV2, FpRpcTransactionStatus, FrameSupportWeightsPerDispatchClassU64, FrameSystemAccountInfo, FrameSystemEventRecord, FrameSystemLastRuntimeUpgradeInfo, FrameSystemPhase, PalletAssetsApproval, PalletAssetsAssetAccount, PalletAssetsAssetDetails, PalletAssetsAssetMetadata, PalletAuthorshipUncleEntryItem, PalletBagsListListBag, PalletBagsListListNode, PalletBalancesAccountData, PalletBalancesBalanceLock, PalletBalancesReleases, PalletBalancesReserveData, PalletDexTradingPair, PalletDexTradingPairStatus, PalletElectionProviderMultiPhasePhase, PalletElectionProviderMultiPhaseReadySolution, PalletElectionProviderMultiPhaseRoundSnapshot, PalletElectionProviderMultiPhaseSignedSignedSubmission, PalletElectionProviderMultiPhaseSolutionOrSnapshotSize, PalletErc20PegPendingPayment, PalletEthyCheckedEthCallRequest, PalletEthyCheckedEthCallResult, PalletEthyEthySigningRequest, PalletEthyEventClaim, PalletEthyEventClaimResult, PalletEthyEventClaimStatus, PalletFeeControlFeeConfig, PalletGrandpaStoredPendingChange, PalletGrandpaStoredState, PalletImOnlineBoundedOpaqueNetworkState, PalletImOnlineSr25519AppSr25519Public, PalletNftCollectionInformation, PalletNftListing, PalletNftMarketplace, PalletNftOfferType, PalletNftTokenLockReason, PalletProxyAnnouncement, PalletProxyProxyDefinition, PalletRecoveryActiveRecovery, PalletRecoveryRecoveryConfig, PalletSchedulerScheduledV3, PalletStakingActiveEraInfo, PalletStakingEraRewardPoints, PalletStakingExposure, PalletStakingForcing, PalletStakingNominations, PalletStakingReleases, PalletStakingRewardDestination, PalletStakingSlashingSlashingSpans, PalletStakingSlashingSpanRecord, PalletStakingStakingLedger, PalletStakingUnappliedSlash, PalletStakingValidatorPrefs, PalletTransactionPaymentReleases, PalletXrplBridgeHelpersXrpTransaction, PalletXrplBridgeHelpersXrplTicketSequenceParams, SeedPrimitivesEthyCryptoAppCryptoPublic, SeedPrimitivesSignatureAccountId20, SeedRuntimeSessionKeys, SpConsensusBabeAppPublic, SpConsensusBabeBabeEpochConfiguration, SpConsensusBabeDigestsNextConfigDescriptor, SpConsensusBabeDigestsPreDigest, SpCoreCryptoKeyTypeId, SpNposElectionsElectionScore, SpRuntimeDigest, SpStakingOffenceOffenceDetails } from '@polkadot/types/lookup';\nimport type { Observable } from '@polkadot/types/types';\nimport type { H160, H256, H512, Perbill, Percent } from '@therootnetwork/types/interfaces/runtime';\n\nexport type __AugmentedQuery<ApiType extends ApiTypes> = AugmentedQuery<ApiType, () => unknown>;\nexport type __QueryableStorageEntry<ApiType extends ApiTypes> = QueryableStorageEntry<ApiType>;\n\ndeclare module '@polkadot/api-base/types/storage' {\n  interface AugmentedQueries<ApiType extends ApiTypes> {\n    assets: {\n      /**\n       * The holdings of a specific account for a specific asset.\n       **/\n      account: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletAssetsAssetAccount>>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Approved balance transfers. First balance is the amount approved for transfer. Second\n       * is the amount of `T::Currency` reserved for storing this.\n       * First key is the asset ID, second key is the owner and third key is the delegate.\n       **/\n      approvals: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, arg3: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletAssetsApproval>>, [u32, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Details of an asset.\n       **/\n      asset: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<PalletAssetsAssetDetails>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Metadata of an asset.\n       **/\n      metadata: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<PalletAssetsAssetMetadata>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    assetsExt: {\n      /**\n       * The holdings of a specific account for a specific asset.\n       **/\n      holds: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Vec<ITuple<[U8aFixed, u128]>>>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The total units issued in the system.\n       **/\n      nextAssetId: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    authorship: {\n      /**\n       * Author of current block.\n       **/\n      author: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Whether uncles were already set in this block.\n       **/\n      didSetUncles: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Uncles\n       **/\n      uncles: AugmentedQuery<ApiType, () => Observable<Vec<PalletAuthorshipUncleEntryItem>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    babe: {\n      /**\n       * Current epoch authorities.\n       **/\n      authorities: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[SpConsensusBabeAppPublic, u64]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * This field should always be populated during block processing unless\n       * secondary plain slots are enabled (which don't contain a VRF output).\n       * \n       * It is set in `on_finalize`, before it will contain the value from the last block.\n       **/\n      authorVrfRandomness: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current slot number.\n       **/\n      currentSlot: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The configuration for the current epoch. Should never be `None` as it is initialized in\n       * genesis.\n       **/\n      epochConfig: AugmentedQuery<ApiType, () => Observable<Option<SpConsensusBabeBabeEpochConfiguration>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current epoch index.\n       **/\n      epochIndex: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The block numbers when the last and current epoch have started, respectively `N-1` and\n       * `N`.\n       * NOTE: We track this is in order to annotate the block number when a given pool of\n       * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in\n       * slots, which may be skipped, the block numbers may not line up with the slot numbers.\n       **/\n      epochStart: AugmentedQuery<ApiType, () => Observable<ITuple<[u32, u32]>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The slot at which the first epoch actually started. This is 0\n       * until the first block of the chain.\n       **/\n      genesisSlot: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Temporary value (cleared at block finalization) which is `Some`\n       * if per-block initialization has already been called for current block.\n       **/\n      initialized: AugmentedQuery<ApiType, () => Observable<Option<Option<SpConsensusBabeDigestsPreDigest>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * How late the current block is compared to its parent.\n       * \n       * This entry is populated as part of block execution and is cleaned up\n       * on block finalization. Querying this storage entry outside of block\n       * execution context should always yield zero.\n       **/\n      lateness: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Next epoch authorities.\n       **/\n      nextAuthorities: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[SpConsensusBabeAppPublic, u64]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The configuration for the next epoch, `None` if the config will not change\n       * (you can fallback to `EpochConfig` instead in that case).\n       **/\n      nextEpochConfig: AugmentedQuery<ApiType, () => Observable<Option<SpConsensusBabeBabeEpochConfiguration>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Next epoch randomness.\n       **/\n      nextRandomness: AugmentedQuery<ApiType, () => Observable<U8aFixed>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Pending epoch configuration change that will be applied when the next epoch is enacted.\n       **/\n      pendingEpochConfigChange: AugmentedQuery<ApiType, () => Observable<Option<SpConsensusBabeDigestsNextConfigDescriptor>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The epoch randomness for the *current* epoch.\n       * \n       * # Security\n       * \n       * This MUST NOT be used for gambling, as it can be influenced by a\n       * malicious validator in the short term. It MAY be used in many\n       * cryptographic protocols, however, so long as one remembers that this\n       * (like everything else on-chain) it is public. For example, it can be\n       * used where a number is needed that cannot have been chosen by an\n       * adversary, for purposes such as public-coin zero-knowledge proofs.\n       **/\n      randomness: AugmentedQuery<ApiType, () => Observable<U8aFixed>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Randomness under construction.\n       * \n       * We make a trade-off between storage accesses and list length.\n       * We store the under-construction randomness in segments of up to\n       * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.\n       * \n       * Once a segment reaches this length, we begin the next one.\n       * We reset all segments and return to `0` at the beginning of every\n       * epoch.\n       **/\n      segmentIndex: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.\n       **/\n      underConstruction: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<U8aFixed>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    balances: {\n      /**\n       * The Balances pallet example of storing the balance of an account.\n       * \n       * # Example\n       * \n       * ```nocompile\n       * impl pallet_balances::Config for Runtime {\n       * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>\n       * }\n       * ```\n       * \n       * You can also store the balance of an account in the `System` pallet.\n       * \n       * # Example\n       * \n       * ```nocompile\n       * impl pallet_balances::Config for Runtime {\n       * type AccountStore = System\n       * }\n       * ```\n       * \n       * But this comes with tradeoffs, storing account balances in the system pallet stores\n       * `frame_system` data alongside the account data contrary to storing account balances in the\n       * `Balances` pallet, which uses a `StorageMap` to store balances data only.\n       * NOTE: This is only used in the case that this pallet is used to store balances.\n       **/\n      account: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletBalancesAccountData>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Any liquidity locks on some account balances.\n       * NOTE: Should only be accessed when setting, changing and freeing a lock.\n       **/\n      locks: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Vec<PalletBalancesBalanceLock>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Named reserves on some account balances.\n       **/\n      reserves: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Vec<PalletBalancesReserveData>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Storage version of the pallet.\n       * \n       * This is set to v2.0.0 for new networks.\n       **/\n      storageVersion: AugmentedQuery<ApiType, () => Observable<PalletBalancesReleases>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The total units issued in the system.\n       **/\n      totalIssuance: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    dex: {\n      liquidityPool: AugmentedQuery<ApiType, (arg: PalletDexTradingPair) => Observable<ITuple<[u128, u128]>>, [PalletDexTradingPair]> & QueryableStorageEntry<ApiType, [PalletDexTradingPair]>;\n      tradingPairLPToken: AugmentedQuery<ApiType, (arg: PalletDexTradingPair) => Observable<Option<u32>>, [PalletDexTradingPair]> & QueryableStorageEntry<ApiType, [PalletDexTradingPair]>;\n      tradingPairStatuses: AugmentedQuery<ApiType, (arg: PalletDexTradingPair) => Observable<PalletDexTradingPairStatus>, [PalletDexTradingPair]> & QueryableStorageEntry<ApiType, [PalletDexTradingPair]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    echo: {\n      /**\n       * The next available offer_id\n       **/\n      nextSessionId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    electionProviderMultiPhase: {\n      /**\n       * Current phase.\n       **/\n      currentPhase: AugmentedQuery<ApiType, () => Observable<PalletElectionProviderMultiPhasePhase>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Desired number of targets to elect for this round.\n       * \n       * Only exists when [`Snapshot`] is present.\n       **/\n      desiredTargets: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum score that each 'untrusted' solution must attain in order to be considered\n       * feasible.\n       * \n       * Can be set via `set_minimum_untrusted_score`.\n       **/\n      minimumUntrustedScore: AugmentedQuery<ApiType, () => Observable<Option<SpNposElectionsElectionScore>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current best solution, signed or unsigned, queued to be returned upon `elect`.\n       **/\n      queuedSolution: AugmentedQuery<ApiType, () => Observable<Option<PalletElectionProviderMultiPhaseReadySolution>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Internal counter for the number of rounds.\n       * \n       * This is useful for de-duplication of transactions submitted to the pool, and general\n       * diagnostics of the pallet.\n       * \n       * This is merely incremented once per every time that an upstream `elect` is called.\n       **/\n      round: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * A sorted, bounded set of `(score, index)`, where each `index` points to a value in\n       * `SignedSubmissions`.\n       * \n       * We never need to process more than a single signed submission at a time. Signed submissions\n       * can be quite large, so we're willing to pay the cost of multiple database accesses to access\n       * them one at a time instead of reading and decoding all of them at once.\n       **/\n      signedSubmissionIndices: AugmentedQuery<ApiType, () => Observable<BTreeMap<SpNposElectionsElectionScore, u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next index to be assigned to an incoming signed submission.\n       * \n       * Every accepted submission is assigned a unique index; that index is bound to that particular\n       * submission for the duration of the election. On election finalization, the next index is\n       * reset to 0.\n       * \n       * We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its\n       * capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,\n       * because iteration is slow. Instead, we store the value here.\n       **/\n      signedSubmissionNextIndex: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Unchecked, signed solutions.\n       * \n       * Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while\n       * allowing us to keep only a single one in memory at a time.\n       * \n       * Twox note: the key of the map is an auto-incrementing index which users cannot inspect or\n       * affect; we shouldn't need a cryptographically secure hasher.\n       **/\n      signedSubmissionsMap: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<PalletElectionProviderMultiPhaseSignedSignedSubmission>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Snapshot data of the round.\n       * \n       * This is created at the beginning of the signed phase and cleared upon calling `elect`.\n       **/\n      snapshot: AugmentedQuery<ApiType, () => Observable<Option<PalletElectionProviderMultiPhaseRoundSnapshot>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The metadata of the [`RoundSnapshot`]\n       * \n       * Only exists when [`Snapshot`] is present.\n       **/\n      snapshotMetadata: AugmentedQuery<ApiType, () => Observable<Option<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    erc20Peg: {\n      /**\n       * Map GA asset Id to ERC20 address\n       **/\n      assetIdToErc20: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<H160>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The peg contract address on Ethereum\n       **/\n      contractAddress: AugmentedQuery<ApiType, () => Observable<H160>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from DelayedPaymentId to PendingPayment\n       **/\n      delayedPayments: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletErc20PegPendingPayment>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Map from block number to DelayedPaymentIds scheduled for that block\n       **/\n      delayedPaymentSchedule: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<u64>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Whether deposit are active\n       **/\n      depositsActive: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Metadata for well-known erc20 tokens (symbol, decimals)\n       **/\n      erc20Meta: AugmentedQuery<ApiType, (arg: H160 | string | Uint8Array) => Observable<Option<ITuple<[Bytes, u8]>>>, [H160]> & QueryableStorageEntry<ApiType, [H160]>;\n      /**\n       * Map ERC20 address to GA asset Id\n       **/\n      erc20ToAssetId: AugmentedQuery<ApiType, (arg: H160 | string | Uint8Array) => Observable<Option<u32>>, [H160]> & QueryableStorageEntry<ApiType, [H160]>;\n      /**\n       * The next available payment id for withdrawals and deposits\n       **/\n      nextDelayedPaymentId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from asset_id to minimum amount and delay\n       **/\n      paymentDelay: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<ITuple<[u128, u32]>>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The blocks with payments that are ready to be processed\n       **/\n      readyBlocks: AugmentedQuery<ApiType, () => Observable<Vec<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Whether withdrawals are active\n       **/\n      withdrawalsActive: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    ethBridge: {\n      /**\n       * Flag to indicate whether authorities have been changed during the current era\n       **/\n      authoritiesChangedThisEra: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Whether the bridge is paused (e.g. during validator transitions or by governance)\n       **/\n      bridgePaused: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The (optimistic) challenge period after which a submitted event is considered valid\n       **/\n      challengePeriod: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Maps from event claim id to challenger and bond amount paid\n       **/\n      challengerAccount: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<ITuple<[SeedPrimitivesSignatureAccountId20, u128]>>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * The bridge contract address on Ethereum\n       **/\n      contractAddress: AugmentedQuery<ApiType, () => Observable<H160>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The maximum number of delayed events that can be processed in on_initialize()\n       **/\n      delayedEventProofsPerBlock: AugmentedQuery<ApiType, () => Observable<u8>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * EthCallOracle notarizations keyed by (Id, Notary)\n       **/\n      ethCallNotarizations: AugmentedQuery<ApiType, (arg1: u64 | AnyNumber | Uint8Array, arg2: SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array) => Observable<Option<PalletEthyCheckedEthCallResult>>, [u64, SeedPrimitivesEthyCryptoAppCryptoPublic]> & QueryableStorageEntry<ApiType, [u64, SeedPrimitivesEthyCryptoAppCryptoPublic]>;\n      /**\n       * map from EthCallOracle notarizations to an aggregated count\n       **/\n      ethCallNotarizationsAggregated: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<BTreeMap<PalletEthyCheckedEthCallResult, u32>>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * EthCallOracle request info\n       **/\n      ethCallRequestInfo: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletEthyCheckedEthCallRequest>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Queue of pending EthCallOracle requests\n       **/\n      ethCallRequests: AugmentedQuery<ApiType, () => Observable<Vec<u64>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum number of block confirmations needed to notarize an Ethereum event\n       **/\n      eventBlockConfirmations: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Notarizations for queued events\n       * Either: None = no notarization exists OR Some(yay/nay)\n       **/\n      eventNotarizations: AugmentedQuery<ApiType, (arg1: u64 | AnyNumber | Uint8Array, arg2: SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array) => Observable<Option<PalletEthyEventClaimResult>>, [u64, SeedPrimitivesEthyCryptoAppCryptoPublic]> & QueryableStorageEntry<ApiType, [u64, SeedPrimitivesEthyCryptoAppCryptoPublic]>;\n      /**\n       * Map from block number to list of EventClaims that will be considered valid and should be forwarded to handlers (i.e after the optimistic challenge period has passed without issue)\n       **/\n      messagesValidAt: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<u64>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The block in which we process the next authority change\n       **/\n      nextAuthorityChange: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Subscription Id for EthCall requests\n       **/\n      nextEthCallId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Id of the next event proof\n       **/\n      nextEventProofId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Scheduled notary (validator) public keys for the next session\n       **/\n      nextNotaryKeys: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Active notary (validator) public keys\n       **/\n      notaryKeys: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current validator set id\n       **/\n      notarySetId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The event proof Id generated by the previous validator set to notarize the current set.\n       * Useful for syncing the latest proof to Ethereum\n       **/\n      notarySetProofId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Active xrpl notary (validator) public keys\n       **/\n      notaryXrplKeys: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * List of all event ids that are currently being challenged\n       **/\n      pendingClaimChallenges: AugmentedQuery<ApiType, () => Observable<Vec<u64>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Status of pending event claims\n       **/\n      pendingClaimStatus: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletEthyEventClaimStatus>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Queued event claims, can be challenged within challenge period\n       **/\n      pendingEventClaims: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletEthyEventClaim>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Queued event proofs to be processed once bridge has been re-enabled\n       **/\n      pendingEventProofs: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletEthyEthySigningRequest>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Tracks processed message Ids (prevent replay)\n       **/\n      processedMessageIds: AugmentedQuery<ApiType, () => Observable<Vec<u64>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The permissioned relayer\n       **/\n      relayer: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Maps from relayer account to their paid bond amount\n       **/\n      relayerPaidBond: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<u128>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Door Signers set by sudo (white list)\n       **/\n      xrplDoorSigners: AugmentedQuery<ApiType, (arg: SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array) => Observable<bool>, [SeedPrimitivesEthyCryptoAppCryptoPublic]> & QueryableStorageEntry<ApiType, [SeedPrimitivesEthyCryptoAppCryptoPublic]>;\n      /**\n       * The event proof Id generated by the previous validator set to notarize the current set.\n       * Useful for syncing the latest proof to Xrpl\n       **/\n      xrplNotarySetProofId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    ethereum: {\n      blockHash: AugmentedQuery<ApiType, (arg: U256 | AnyNumber | Uint8Array) => Observable<H256>, [U256]> & QueryableStorageEntry<ApiType, [U256]>;\n      /**\n       * The current Ethereum block.\n       **/\n      currentBlock: AugmentedQuery<ApiType, () => Observable<Option<EthereumBlock>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current Ethereum receipts.\n       **/\n      currentReceipts: AugmentedQuery<ApiType, () => Observable<Option<Vec<EthereumReceiptReceiptV3>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current transaction statuses.\n       **/\n      currentTransactionStatuses: AugmentedQuery<ApiType, () => Observable<Option<Vec<FpRpcTransactionStatus>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current building block's transactions and receipts.\n       **/\n      pending: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[EthereumTransactionTransactionV2, FpRpcTransactionStatus, EthereumReceiptReceiptV3]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    evm: {\n      accountCodes: AugmentedQuery<ApiType, (arg: H160 | string | Uint8Array) => Observable<Bytes>, [H160]> & QueryableStorageEntry<ApiType, [H160]>;\n      accountStorages: AugmentedQuery<ApiType, (arg1: H160 | string | Uint8Array, arg2: H256 | string | Uint8Array) => Observable<H256>, [H160, H256]> & QueryableStorageEntry<ApiType, [H160, H256]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    evmChainId: {\n      /**\n       * The EVM chain ID.\n       **/\n      chainId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    feeControl: {\n      data: AugmentedQuery<ApiType, () => Observable<PalletFeeControlFeeConfig>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    futurepass: {\n      /**\n       * Accounts which have set futurepass as default proxied on-chain account (delegate ->\n       * futurepass)\n       **/\n      defaultProxy: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Futurepass holders (account -> futurepass)\n       **/\n      holders: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Migration data for user (root) and collections they can migrate\n       **/\n      migrationAdmin: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next available incrementing futurepass id\n       **/\n      nextFuturepassId: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    grandpa: {\n      /**\n       * The number of changes (both in terms of keys and underlying economic responsibilities)\n       * in the \"set\" of Grandpa validators from genesis.\n       **/\n      currentSetId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * next block number where we can force a change.\n       **/\n      nextForced: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Pending change: (signaled at, scheduled change).\n       **/\n      pendingChange: AugmentedQuery<ApiType, () => Observable<Option<PalletGrandpaStoredPendingChange>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * A mapping from grandpa set ID to the index of the *most recent* session for which its\n       * members were responsible.\n       * \n       * TWOX-NOTE: `SetId` is not under user control.\n       **/\n      setIdSession: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<u32>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * `true` if we are currently stalled.\n       **/\n      stalled: AugmentedQuery<ApiType, () => Observable<Option<ITuple<[u32, u32]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * State of the current authority set.\n       **/\n      state: AugmentedQuery<ApiType, () => Observable<PalletGrandpaStoredState>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    imOnline: {\n      /**\n       * For each session index, we keep a mapping of `ValidatorId<T>` to the\n       * number of blocks authored by the given authority.\n       **/\n      authoredBlocks: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<u32>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The block number after which it's ok to send heartbeats in the current\n       * session.\n       * \n       * At the beginning of each session we set this to a value that should fall\n       * roughly in the middle of the session duration. The idea is to first wait for\n       * the validators to produce a block in the current session, so that the\n       * heartbeat later on will not be necessary.\n       * \n       * This value will only be used as a fallback if we fail to get a proper session\n       * progress estimate from `NextSessionRotation`, as those estimates should be\n       * more accurate then the value we calculate for `HeartbeatAfter`.\n       **/\n      heartbeatAfter: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current set of keys that may issue a heartbeat.\n       **/\n      keys: AugmentedQuery<ApiType, () => Observable<Vec<PalletImOnlineSr25519AppSr25519Public>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to\n       * `WrapperOpaque<BoundedOpaqueNetworkState>`.\n       **/\n      receivedHeartbeats: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: u32 | AnyNumber | Uint8Array) => Observable<Option<WrapperOpaque<PalletImOnlineBoundedOpaqueNetworkState>>>, [u32, u32]> & QueryableStorageEntry<ApiType, [u32, u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    nft: {\n      /**\n       * Map from collection to its information\n       **/\n      collectionInfo: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<PalletNftCollectionInformation>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Block numbers where listings will close. Value is `true` if at block number `listing_id` is\n       * scheduled to close.\n       **/\n      listingEndSchedule: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: u128 | AnyNumber | Uint8Array) => Observable<Option<bool>>, [u32, u128]> & QueryableStorageEntry<ApiType, [u32, u128]>;\n      /**\n       * NFT sale/auction listings keyed by listing id\n       **/\n      listings: AugmentedQuery<ApiType, (arg: u128 | AnyNumber | Uint8Array) => Observable<Option<PalletNftListing>>, [u128]> & QueryableStorageEntry<ApiType, [u128]>;\n      /**\n       * Winning bids on open listings.\n       **/\n      listingWinningBid: AugmentedQuery<ApiType, (arg: u128 | AnyNumber | Uint8Array) => Observable<Option<ITuple<[SeedPrimitivesSignatureAccountId20, u128]>>>, [u128]> & QueryableStorageEntry<ApiType, [u128]>;\n      /**\n       * The next available incrementing collection id\n       **/\n      nextCollectionId: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next available listing Id\n       **/\n      nextListingId: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next available marketplace id\n       **/\n      nextMarketplaceId: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The next available offer_id\n       **/\n      nextOfferId: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from offer_id to the information related to the offer\n       **/\n      offers: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletNftOfferType>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * Map from collection to any open listings\n       **/\n      openCollectionListings: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: u128 | AnyNumber | Uint8Array) => Observable<Option<bool>>, [u32, u128]> & QueryableStorageEntry<ApiType, [u32, u128]>;\n      /**\n       * Map from marketplace account_id to royalties schedule\n       **/\n      registeredMarketplaces: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<PalletNftMarketplace>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Map from a token to lock status if any\n       **/\n      tokenLocks: AugmentedQuery<ApiType, (arg: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => Observable<Option<PalletNftTokenLockReason>>, [ITuple<[u32, u32]>]> & QueryableStorageEntry<ApiType, [ITuple<[u32, u32]>]>;\n      /**\n       * Maps from token_id to a vector of offer_ids on that token\n       **/\n      tokenOffers: AugmentedQuery<ApiType, (arg: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => Observable<Option<Vec<u64>>>, [ITuple<[u32, u32]>]> & QueryableStorageEntry<ApiType, [ITuple<[u32, u32]>]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    nftPeg: {\n      contractAddress: AugmentedQuery<ApiType, () => Observable<H160>, []> & QueryableStorageEntry<ApiType, []>;\n      ethToRootNft: AugmentedQuery<ApiType, (arg: H160 | string | Uint8Array) => Observable<Option<u32>>, [H160]> & QueryableStorageEntry<ApiType, [H160]>;\n      rootNftToErc721: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<H160>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    offences: {\n      /**\n       * A vector of reports of the same kind that happened at the same time slot.\n       **/\n      concurrentReportsIndex: AugmentedQuery<ApiType, (arg1: U8aFixed | string | Uint8Array, arg2: Bytes | string | Uint8Array) => Observable<Vec<H256>>, [U8aFixed, Bytes]> & QueryableStorageEntry<ApiType, [U8aFixed, Bytes]>;\n      /**\n       * The primary structure that holds all offence records keyed by report identifiers.\n       **/\n      reports: AugmentedQuery<ApiType, (arg: H256 | string | Uint8Array) => Observable<Option<SpStakingOffenceOffenceDetails>>, [H256]> & QueryableStorageEntry<ApiType, [H256]>;\n      /**\n       * Enumerates all reports of a kind along with the time they happened.\n       * \n       * All reports are sorted by the time of offence.\n       * \n       * Note that the actual type of this mapping is `Vec<u8>`, this is because values of\n       * different types are not supported at the moment so we are doing the manual serialization.\n       **/\n      reportsByKindIndex: AugmentedQuery<ApiType, (arg: U8aFixed | string | Uint8Array) => Observable<Bytes>, [U8aFixed]> & QueryableStorageEntry<ApiType, [U8aFixed]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    proxy: {\n      /**\n       * The announcements made by the proxy (key).\n       **/\n      announcements: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<ITuple<[Vec<PalletProxyAnnouncement>, u128]>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The set of account proxies. Maps the account which has delegated to the accounts\n       * which are being delegated to, together with the amount held on deposit.\n       **/\n      proxies: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<ITuple<[Vec<PalletProxyProxyDefinition>, u128]>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    recovery: {\n      /**\n       * Active recovery attempts.\n       * \n       * First account is the account to be recovered, and the second account\n       * is the user trying to recover the account.\n       **/\n      activeRecoveries: AugmentedQuery<ApiType, (arg1: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletRecoveryActiveRecovery>>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The list of allowed proxy accounts.\n       * \n       * Map from the user who can access it to the recovered account.\n       **/\n      proxy: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The set of recoverable accounts and their recovery configuration.\n       **/\n      recoverable: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletRecoveryRecoveryConfig>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    scheduler: {\n      /**\n       * Items to be executed, indexed by the block number that they should be executed on.\n       **/\n      agenda: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<Option<PalletSchedulerScheduledV3>>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Lookup from identity to the block number and index of the task.\n       **/\n      lookup: AugmentedQuery<ApiType, (arg: Bytes | string | Uint8Array) => Observable<Option<ITuple<[u32, u32]>>>, [Bytes]> & QueryableStorageEntry<ApiType, [Bytes]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    session: {\n      /**\n       * Current index of the session.\n       **/\n      currentIndex: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Indices of disabled validators.\n       * \n       * The vec is always kept sorted so that we can find whether a given validator is\n       * disabled using binary search. It gets cleared when `on_session_ending` returns\n       * a new set of identities.\n       **/\n      disabledValidators: AugmentedQuery<ApiType, () => Observable<Vec<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The owner of a key. The key is the `KeyTypeId` + the encoded key.\n       **/\n      keyOwner: AugmentedQuery<ApiType, (arg: ITuple<[SpCoreCryptoKeyTypeId, Bytes]> | [SpCoreCryptoKeyTypeId | string | Uint8Array, Bytes | string | Uint8Array]) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [ITuple<[SpCoreCryptoKeyTypeId, Bytes]>]> & QueryableStorageEntry<ApiType, [ITuple<[SpCoreCryptoKeyTypeId, Bytes]>]>;\n      /**\n       * The next session keys for a validator.\n       **/\n      nextKeys: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedRuntimeSessionKeys>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * True if the underlying economic identities or weighting behind the validators\n       * has changed in the queued validator set.\n       **/\n      queuedChanged: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The queued keys for the next session. When the next session begins, these keys\n       * will be used to determine the validator's session keys.\n       **/\n      queuedKeys: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[SeedPrimitivesSignatureAccountId20, SeedRuntimeSessionKeys]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current set of validators.\n       **/\n      validators: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesSignatureAccountId20>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    staking: {\n      /**\n       * The active era information, it holds index and start.\n       * \n       * The active era is the era being currently rewarded. Validator set of this era must be\n       * equal to [`SessionInterface::validators`].\n       **/\n      activeEra: AugmentedQuery<ApiType, () => Observable<Option<PalletStakingActiveEraInfo>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from all locked \"stash\" accounts to the controller account.\n       **/\n      bonded: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * A mapping from still-bonded eras to the first session index of that era.\n       * \n       * Must contains information for eras for the range:\n       * `[active_era - bounding_duration; active_era]`\n       **/\n      bondedEras: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[u32, u32]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The amount of currency given to reporters of a slash event which was\n       * canceled by extraordinary circumstances (e.g. governance).\n       **/\n      canceledSlashPayout: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The threshold for when users can start calling `chill_other` for other validators /\n       * nominators. The threshold is compared to the actual number of validators / nominators\n       * (`CountFor*`) in the system compared to the configured max (`Max*Count`).\n       **/\n      chillThreshold: AugmentedQuery<ApiType, () => Observable<Option<Percent>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Counter for the related counted storage map\n       **/\n      counterForNominators: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Counter for the related counted storage map\n       **/\n      counterForValidators: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current era index.\n       * \n       * This is the latest planned era, depending on how the Session pallet queues the validator\n       * set, it might be active or not.\n       **/\n      currentEra: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The last planned session scheduled by the session pallet.\n       * \n       * This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].\n       **/\n      currentPlannedSession: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Rewards for the last `HISTORY_DEPTH` eras.\n       * If reward hasn't been set or has been removed then 0 reward is returned.\n       **/\n      erasRewardPoints: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<PalletStakingEraRewardPoints>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Exposure of validator at era.\n       * \n       * This is keyed first by the era index to allow bulk deletion and then the stash account.\n       * \n       * Is it removed after `HISTORY_DEPTH` eras.\n       * If stakers hasn't been set or has been removed then empty exposure is returned.\n       **/\n      erasStakers: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingExposure>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Clipped Exposure of validator at era.\n       * \n       * This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the\n       * `T::MaxNominatorRewardedPerValidator` biggest stakers.\n       * (Note: the field `total` and `own` of the exposure remains unchanged).\n       * This is used to limit the i/o cost for the nominator payout.\n       * \n       * This is keyed fist by the era index to allow bulk deletion and then the stash account.\n       * \n       * Is it removed after `HISTORY_DEPTH` eras.\n       * If stakers hasn't been set or has been removed then empty exposure is returned.\n       **/\n      erasStakersClipped: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingExposure>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The session index at which the era start for the last `HISTORY_DEPTH` eras.\n       * \n       * Note: This tracks the starting session (i.e. session index when era start being active)\n       * for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.\n       **/\n      erasStartSessionIndex: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<u32>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The total amount staked for the last `HISTORY_DEPTH` eras.\n       * If total hasn't been set or has been removed then 0 stake is returned.\n       **/\n      erasTotalStake: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<u128>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Similar to `ErasStakers`, this holds the preferences of validators.\n       * \n       * This is keyed first by the era index to allow bulk deletion and then the stash account.\n       * \n       * Is it removed after `HISTORY_DEPTH` eras.\n       **/\n      erasValidatorPrefs: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingValidatorPrefs>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The total validator era payout for the last `HISTORY_DEPTH` eras.\n       * \n       * Eras that haven't finished yet or has been removed doesn't have reward.\n       **/\n      erasValidatorReward: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<u128>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Mode of era forcing.\n       **/\n      forceEra: AugmentedQuery<ApiType, () => Observable<PalletStakingForcing>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Number of eras to keep in history.\n       * \n       * Information is kept for eras in `[current_era - history_depth; current_era]`.\n       * \n       * Must be more than the number of eras delayed by session otherwise. I.e. active era must\n       * always be in history. I.e. `active_era > current_era - history_depth` must be\n       * guaranteed.\n       **/\n      historyDepth: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Any validators that may never be slashed or forcibly kicked. It's a Vec since they're\n       * easy to initialize and the performance hit is minimal (we expect no more than four\n       * invulnerables) and restricted to testnets.\n       **/\n      invulnerables: AugmentedQuery<ApiType, () => Observable<Vec<SeedPrimitivesSignatureAccountId20>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map from all (unlocked) \"controller\" accounts to the info regarding the staking.\n       **/\n      ledger: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletStakingStakingLedger>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The maximum nominator count before we stop allowing new validators to join.\n       * \n       * When this value is not set, no limits are enforced.\n       **/\n      maxNominatorsCount: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The maximum validator count before we stop allowing new validators to join.\n       * \n       * When this value is not set, no limits are enforced.\n       **/\n      maxValidatorsCount: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum amount of commission that validators can set.\n       * \n       * If set to `0`, no limit exists.\n       **/\n      minCommission: AugmentedQuery<ApiType, () => Observable<Perbill>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Minimum number of staking participants before emergency conditions are imposed.\n       **/\n      minimumValidatorCount: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum active bond to become and maintain the role of a nominator.\n       **/\n      minNominatorBond: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The minimum active bond to become and maintain the role of a validator.\n       **/\n      minValidatorBond: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The map from nominator stash key to their nomination preferences, namely the validators that\n       * they wish to support.\n       * \n       * Note that the keys of this storage map might become non-decodable in case the\n       * [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators\n       * are still existent in storage, their key is correct and retrievable (i.e. `contains_key`\n       * indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable\n       * nominators will effectively not-exist, until they re-submit their preferences such that it\n       * is within the bounds of the newly set `Config::MaxNominations`.\n       * \n       * This implies that `::iter_keys().count()` and `::iter().count()` might return different\n       * values for this map. Moreover, the main `::count()` is aligned with the former, namely the\n       * number of keys that exist.\n       * \n       * Lastly, if any of the nominators become non-decodable, they can be chilled immediately via\n       * [`Call::chill_other`] dispatchable by anyone.\n       **/\n      nominators: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletStakingNominations>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * All slashing events on nominators, mapped by era to the highest slash value of the era.\n       **/\n      nominatorSlashInEra: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<u128>>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Indices of validators that have offended in the active era and whether they are currently\n       * disabled.\n       * \n       * This value should be a superset of disabled validators since not all offences lead to the\n       * validator being disabled (if there was no slash). This is needed to track the percentage of\n       * validators that have offended in the current era, ensuring a new era is forced if\n       * `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find\n       * whether a given validator has previously offended using binary search. It gets cleared when\n       * the era ends.\n       **/\n      offendingValidators: AugmentedQuery<ApiType, () => Observable<Vec<ITuple<[u32, bool]>>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Where the reward payment should be made. Keyed by stash.\n       **/\n      payee: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingRewardDestination>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Slashing spans for stash accounts.\n       **/\n      slashingSpans: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletStakingSlashingSlashingSpans>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * The percentage of the slash that is distributed to reporters.\n       * \n       * The rest of the slashed value is handled by the `Slash`.\n       **/\n      slashRewardFraction: AugmentedQuery<ApiType, () => Observable<Perbill>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Records information about the maximum slash of a stash within a slashing span,\n       * as well as how much reward has been paid out.\n       **/\n      spanSlash: AugmentedQuery<ApiType, (arg: ITuple<[SeedPrimitivesSignatureAccountId20, u32]> | [SeedPrimitivesSignatureAccountId20 | string | Uint8Array, u32 | AnyNumber | Uint8Array]) => Observable<PalletStakingSlashingSpanRecord>, [ITuple<[SeedPrimitivesSignatureAccountId20, u32]>]> & QueryableStorageEntry<ApiType, [ITuple<[SeedPrimitivesSignatureAccountId20, u32]>]>;\n      /**\n       * True if network has been upgraded to this version.\n       * Storage version of the pallet.\n       * \n       * This is set to v7.0.0 for new networks.\n       **/\n      storageVersion: AugmentedQuery<ApiType, () => Observable<PalletStakingReleases>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * All unapplied slashes that are queued for later.\n       **/\n      unappliedSlashes: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Vec<PalletStakingUnappliedSlash>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The ideal number of staking participants.\n       **/\n      validatorCount: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The map from (wannabe) validator stash key to the preferences of that validator.\n       **/\n      validators: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<PalletStakingValidatorPrefs>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * All slashing events on validators, mapped by era to the highest slash proportion\n       * and slash value of the era.\n       **/\n      validatorSlashInEra: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<ITuple<[Perbill, u128]>>>, [u32, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    sudo: {\n      /**\n       * The `AccountId` of the sudo key.\n       **/\n      key: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    system: {\n      /**\n       * The full account information for a particular account ID.\n       **/\n      account: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<FrameSystemAccountInfo>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Total length (in bytes) for all extrinsics put together, for the current block.\n       **/\n      allExtrinsicsLen: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Map of block numbers to block hashes.\n       **/\n      blockHash: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<H256>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * The current weight for the block.\n       **/\n      blockWeight: AugmentedQuery<ApiType, () => Observable<FrameSupportWeightsPerDispatchClassU64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Digest of the current block, also part of the block header.\n       **/\n      digest: AugmentedQuery<ApiType, () => Observable<SpRuntimeDigest>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The number of events in the `Events<T>` list.\n       **/\n      eventCount: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Events deposited for the current block.\n       * \n       * NOTE: The item is unbound and should therefore never be read on chain.\n       * It could otherwise inflate the PoV size of a block.\n       * \n       * Events have a large in-memory size. Box the events to not go out-of-memory\n       * just in case someone still reads them from within the runtime.\n       **/\n      events: AugmentedQuery<ApiType, () => Observable<Vec<FrameSystemEventRecord>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Mapping between a topic (represented by T::Hash) and a vector of indexes\n       * of events in the `<Events<T>>` list.\n       * \n       * All topic vectors have deterministic storage locations depending on the topic. This\n       * allows light-clients to leverage the changes trie storage tracking mechanism and\n       * in case of changes fetch the list of events of interest.\n       * \n       * The value has the type `(T::BlockNumber, EventIndex)` because if we used only just\n       * the `EventIndex` then in case if the topic has the same contents on the next block\n       * no notification will be triggered thus the event might be lost.\n       **/\n      eventTopics: AugmentedQuery<ApiType, (arg: H256 | string | Uint8Array) => Observable<Vec<ITuple<[u32, u32]>>>, [H256]> & QueryableStorageEntry<ApiType, [H256]>;\n      /**\n       * The execution phase of the block.\n       **/\n      executionPhase: AugmentedQuery<ApiType, () => Observable<Option<FrameSystemPhase>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Total extrinsics count for the current block.\n       **/\n      extrinsicCount: AugmentedQuery<ApiType, () => Observable<Option<u32>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Extrinsics data for the current block (maps an extrinsic's index to its data).\n       **/\n      extrinsicData: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Bytes>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.\n       **/\n      lastRuntimeUpgrade: AugmentedQuery<ApiType, () => Observable<Option<FrameSystemLastRuntimeUpgradeInfo>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current block number being processed. Set by `execute_block`.\n       **/\n      number: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Hash of the previous block.\n       **/\n      parentHash: AugmentedQuery<ApiType, () => Observable<H256>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False\n       * (default) if not.\n       **/\n      upgradedToTripleRefCount: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.\n       **/\n      upgradedToU32RefCount: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    timestamp: {\n      /**\n       * Did the timestamp get updated in this block?\n       **/\n      didUpdate: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Current time for the current block.\n       **/\n      now: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    tokenApprovals: {\n      erc20Approvals: AugmentedQuery<ApiType, (arg1: ITuple<[SeedPrimitivesSignatureAccountId20, u32]> | [SeedPrimitivesSignatureAccountId20 | string | Uint8Array, u32 | AnyNumber | Uint8Array], arg2: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<u128>>, [ITuple<[SeedPrimitivesSignatureAccountId20, u32]>, SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [ITuple<[SeedPrimitivesSignatureAccountId20, u32]>, SeedPrimitivesSignatureAccountId20]>;\n      erc721Approvals: AugmentedQuery<ApiType, (arg: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [ITuple<[u32, u32]>]> & QueryableStorageEntry<ApiType, [ITuple<[u32, u32]>]>;\n      erc721ApprovalsForAll: AugmentedQuery<ApiType, (arg1: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, arg2: ITuple<[u32, SeedPrimitivesSignatureAccountId20]> | [u32 | AnyNumber | Uint8Array, SeedPrimitivesSignatureAccountId20 | string | Uint8Array]) => Observable<Option<bool>>, [SeedPrimitivesSignatureAccountId20, ITuple<[u32, SeedPrimitivesSignatureAccountId20]>]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20, ITuple<[u32, SeedPrimitivesSignatureAccountId20]>]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    transactionPayment: {\n      nextFeeMultiplier: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      storageVersion: AugmentedQuery<ApiType, () => Observable<PalletTransactionPaymentReleases>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    txFeePot: {\n      /**\n       * Accrued transaction fees in the current staking Era\n       **/\n      eraTxFees: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    voterList: {\n      /**\n       * Counter for the related counted storage map\n       **/\n      counterForListNodes: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * A bag stored in storage.\n       * \n       * Stores a `Bag` struct, which stores head and tail pointers to itself.\n       **/\n      listBags: AugmentedQuery<ApiType, (arg: u64 | AnyNumber | Uint8Array) => Observable<Option<PalletBagsListListBag>>, [u64]> & QueryableStorageEntry<ApiType, [u64]>;\n      /**\n       * A single node, within some bag.\n       * \n       * Nodes store links forward and back within their respective bags.\n       **/\n      listNodes: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<PalletBagsListListNode>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    xls20: {\n      /**\n       * The permissioned relayer\n       **/\n      relayer: AugmentedQuery<ApiType, () => Observable<Option<U8aFixed>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The extra cost of minting an XLS-20 compatible NFT\n       **/\n      xls20MintFee: AugmentedQuery<ApiType, () => Observable<u128>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Maps from TRN native token_id to XLS-20 TokenId\n       **/\n      xls20TokenMap: AugmentedQuery<ApiType, (arg1: u32 | AnyNumber | Uint8Array, arg2: u32 | AnyNumber | Uint8Array) => Observable<Option<U8aFixed>>, [u32, u32]> & QueryableStorageEntry<ApiType, [u32, u32]>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n    xrplBridge: {\n      /**\n       * Challenge received for a transaction mapped by hash, will be cleared when validator\n       * validates\n       **/\n      challengeXRPTransactionList: AugmentedQuery<ApiType, (arg: H512 | string | Uint8Array) => Observable<Option<SeedPrimitivesSignatureAccountId20>>, [H512]> & QueryableStorageEntry<ApiType, [H512]>;\n      /**\n       * The door address on XRPL\n       **/\n      doorAddress: AugmentedQuery<ApiType, () => Observable<Option<H160>>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The current ticket sequence of the XRPL door account\n       **/\n      doorTicketSequence: AugmentedQuery<ApiType, () => Observable<u32>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The Ticket sequence params of the XRPL door account for the current allocation\n       **/\n      doorTicketSequenceParams: AugmentedQuery<ApiType, () => Observable<PalletXrplBridgeHelpersXrplTicketSequenceParams>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The Ticket sequence params of the XRPL door account for the next allocation\n       **/\n      doorTicketSequenceParamsNext: AugmentedQuery<ApiType, () => Observable<PalletXrplBridgeHelpersXrplTicketSequenceParams>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * The flat fee for XRPL door txs\n       **/\n      doorTxFee: AugmentedQuery<ApiType, () => Observable<u64>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Temporary storage to set the transactions ready to be processed at specified block number\n       **/\n      processXRPTransaction: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<Vec<H512>>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Stores submitted transactions from XRPL waiting to be processed\n       * Transactions will be cleared `ClearTxPeriod` blocks after processing\n       **/\n      processXRPTransactionDetails: AugmentedQuery<ApiType, (arg: H512 | string | Uint8Array) => Observable<Option<ITuple<[u64, PalletXrplBridgeHelpersXrpTransaction, SeedPrimitivesSignatureAccountId20]>>>, [H512]> & QueryableStorageEntry<ApiType, [H512]>;\n      /**\n       * List of all XRP transaction relayers\n       **/\n      relayer: AugmentedQuery<ApiType, (arg: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => Observable<Option<bool>>, [SeedPrimitivesSignatureAccountId20]> & QueryableStorageEntry<ApiType, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Settled xrp transactions stored as history for a specific period\n       **/\n      settledXRPTransactionDetails: AugmentedQuery<ApiType, (arg: u32 | AnyNumber | Uint8Array) => Observable<Option<Vec<H512>>>, [u32]> & QueryableStorageEntry<ApiType, [u32]>;\n      /**\n       * Keeps track whether the TicketSequenceThresholdReached event is emitted\n       **/\n      ticketSequenceThresholdReachedEmitted: AugmentedQuery<ApiType, () => Observable<bool>, []> & QueryableStorageEntry<ApiType, []>;\n      /**\n       * Generic query\n       **/\n      [key: string]: QueryableStorageEntry<ApiType>;\n    };\n  } // AugmentedQueries\n} // declare module\n"],"version":3}