{"file":"/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/cennzx.e2e.ts","mappings":"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","names":[],"sources":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/cennzx.e2e.ts"],"sourcesContent":["// // Copyright 2019-2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n// import { Api } from '@cennznet/api';\n// import {SignerOptions} from \"@polkadot/api/types\";\n// import { Keyring } from '@polkadot/keyring';\n// import {BN} from \"@polkadot/util\";\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n// import initApiPromise from '../../../../jest/initApiPromise';\n// import {Balance, LiquidityPriceResponse, LiquidityValueResponse} from '@cennznet/types';\n// const CENNZ = '16000';\n// const CENTRAPAY = '16001';\n// const PLUG = '16003';\n//\n// describe('CENNZX RPC calls testing', () => {\n//   let api: Api;\n//   let alice, bob;\n//   beforeAll(async () => {\n//     await cryptoWaitReady();\n//     // api = await initApiPromise();\n//     // const keyring = new Keyring({ type: 'sr25519' });\n//     // alice = keyring.addFromUri('//Alice');\n//     // bob = keyring.addFromUri('//Bob');\n//   });\n//\n//   afterAll(async () => {\n//     // api.disconnect();\n//   });\n//\n//   describe('Queries()', () => {\n//\n//     it(\"Deposit liquidity in CENNZ asset's pool\", async done => {\n//         const amount = 3_000_000;\n//         const coreAmount = amount;\n//         const minLiquidity = 1;\n//       // Add Liquidity for the first time in the pool.\n//         await api.tx.cennzx\n//           .addLiquidity(CENNZ, minLiquidity, amount, coreAmount)\n//           .signAndSend(alice, async ({events, status}) => {\n//             if (status.isInBlock) {\n//               for (const {event} of events) {\n//                 if (event.method === 'AddLiquidity') {\n//                   let amount = 2000;\n//                   const liquidityPrice: LiquidityPriceResponse = await api.rpc.cennzx.liquidityPrice(CENNZ, amount);\n//                   // Deposit liquidity in existing pool\n//                   await api.tx.cennzx\n//                       .addLiquidity(CENNZ, minLiquidity, liquidityPrice.asset, liquidityPrice.core)\n//                       .signAndSend(alice, async ({events, status}) => {\n//                         if (status.isFinalized) {\n//                           for (const {event} of events) {\n//                             if (event.method === 'AddLiquidity') {\n//                               done();\n//                             }\n//                           }\n//                         }\n//                       });\n//                 }\n//               }\n//             }\n//           });\n//     });\n//\n//     it(\"Get the liquidity value for CENNZ asset in Alice's account\", async done => {\n//       const liquidityValue: LiquidityValueResponse = await api.rpc.cennzx.liquidityValue(alice.address, CENNZ);\n//       expect(liquidityValue.liquidity.isZero()).toBe(false);\n//       expect(liquidityValue.core.isZero()).toBe(false);\n//       expect(liquidityValue.asset.isZero()).toBe(false);\n//       done();\n//     });\n//\n//     describe('Positive flow with liquidity in pool', () => {\n//       it(\"Calculate the buy price when buying CENTRAPAY for CENNZ\", async done => {\n//         const amount = 100;\n//         const poolAssetBalance = await api.derive.cennzx.poolAssetBalance(CENNZ);\n//         const poolCoreAssetBalance = await api.derive.cennzx.poolCoreAssetBalance(CENNZ);\n//         console.log('Amount of asset in CENNZ pool:', poolAssetBalance.toString());\n//         console.log('Amount of core in CENNZ pool:', poolCoreAssetBalance.toString());\n//         // How much CENTRAPAY will it cost to buy 100 (amount) CENNZ\n//         const buyPrice = await api.rpc.cennzx.buyPrice(CENTRAPAY, amount, CENNZ);\n//         console.log('Buy price:', buyPrice.toString());\n//         expect(buyPrice.price.toNumber()).toBeGreaterThan(0);\n//         done();\n//       });\n//\n//       it(\"Calculate the sell price when selling CENNZ for CENTRAPAY \", async done => {\n//         const amount = 1000;\n//         // when I sell 1000(amount) CENNZ, how much of CENTRAPAY will I get in return\n//         const sellPrice = await api.rpc.cennzx\n//           .sellPrice(CENNZ, amount, CENTRAPAY);\n//         expect(sellPrice.price.toNumber()).toBeGreaterThan(0);\n//         done();\n//       });\n//\n//       describe('feeExchange derive queries with positive flow', () => {\n//         it('Query estimated fee in CENTRAPAY(default fee currency)', async done => {\n//           const assetBalanceBefore = await api.query.genericAsset.freeBalance(CENTRAPAY, alice.address);\n//           const extrinsic = api.tx.genericAsset\n//             .transfer(CENNZ, bob.address, 10000);\n//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId:CENTRAPAY});\n//\n//           await extrinsic.signAndSend(alice,  async ({events, status}) => {\n//             if (status.isFinalized) {\n//               events.forEach(({phase, event: {data, method, section}}) => {\n//                 console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//               });\n//               const assetBalanceAfter = await api.query.genericAsset.freeBalance(CENTRAPAY, alice.address);\n//               expect((assetBalanceBefore as Balance).toBn().sub((assetBalanceAfter as Balance).toBn()).toString()).toEqual(feeFromQuery.toString());\n//               done();\n//             }\n//           });\n//         });\n//\n//         it('Query estimated fee in different currency (CENNZ)', async done => {\n//           const maxPayment = '50000000000000000';\n//           const assetId = api.registry.createType('AssetId', CENNZ);\n//           const feeExchange = api.registry.createType('FeeExchange', {assetId, maxPayment}, 0);\n//           const transactionPayment = api.registry.createType('ChargeTransactionPayment', {tip: 0, feeExchange});\n//           const royaltiesSchedule = null;\n//           const extrinsic = api.tx.nft.createCollection(\n//             'collectionName',\n//             royaltiesSchedule\n//           );\n//\n//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId: CENNZ, maxPayment});\n//           await extrinsic.signAndSend(alice,  {transactionPayment} as Partial<SignerOptions>, async ({events, status}) => {\n//             if (status.isFinalized) {\n//               events.forEach(({phase, event: {data, method, section}}) => {\n//                 if (method === 'AssetBought') {\n//                   const price = data[3];\n//                   console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//                   expect(feeFromQuery.toString()).toEqual(price.toString());\n//                   done();\n//                 }\n//               });\n//             }\n//           });\n//         });\n//       });\n//     });\n//\n//     describe('Negative flow with no liquidity in pool', () => {\n//       it(\"Calculate the buy price when buying CENTRAPAY for PLUG\", async done => {\n//         const amount = 100;\n//         const poolAssetBalance = await api.derive.cennzx.poolAssetBalance(PLUG);\n//         const poolCoreAssetBalance = await api.derive.cennzx.poolCoreAssetBalance(PLUG);\n//         console.log('Amount of asset in PLUG pool:', poolAssetBalance.toString());\n//         console.log('Amount of core in PLUG pool:', poolCoreAssetBalance.toString());\n//         // How much CENTRAPAY will it cost to buy 100 (amount) PLUG\n//         await expect(api.rpc.cennzx.buyPrice(CENTRAPAY, amount, PLUG)).rejects.toThrow(\n//           '2: Cannot exchange for requested amount.:'\n//         );\n//         done();\n//       });\n//\n//       it(\"Calculate the sell price when selling PLUG for CENTRAPAY when no liquidity exist \", async done => {\n//         const amount = 1000;\n//         // when I sell 1000(amount) PLUG, how much of CENTRAPAY will I get in return\n//         await expect(api.rpc.cennzx\n//           .sellPrice(PLUG, amount, CENTRAPAY)).rejects.toThrow(\n//           '2: Cannot exchange by requested amount.'\n//         );\n//         done();\n//       });\n//\n//       describe('feeExchange derive queries with negative flow', () => {\n//\n//         it('Query estimated fee in different currency (PLUG)', async done => {\n//           const maxPayment = '50000000000000000';\n//           const extrinsic = api.tx.genericAsset\n//             .transfer(CENNZ, bob.address, 10000);\n//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId:PLUG, maxPayment});\n//           expect(feeFromQuery).toEqual(new Error('2: Cannot exchange for requested amount.: '));\n//           done();\n//         });\n//       });\n//     });\n//\n//   });\n// });\n"],"version":3}