{"file":"/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/staking.e2e.ts","mappings":"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","names":[],"sources":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/staking.e2e.ts"],"sourcesContent":["// // Copyright 2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import {Api} from \"@cennznet/api\";\n// import { AccountId, Forcing, RewardDestination, StakingLedger, ValidatorPrefs, Option } from '@cennznet/types';\n// import { Keyring } from '@polkadot/keyring';\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n//\n// import initApiPromise from '../../../../jest/initApiPromise';\n//\n// let api;\n// const keyring = new Keyring({ type: 'sr25519' });\n// let alice, bob;\n//\n// beforeAll(async () => {\n//   await cryptoWaitReady();\n//   api = await initApiPromise();\n//   alice = keyring.addFromUri('//Alice');\n//   bob = keyring.addFromUri('//Bob');\n// });\n//\n// afterAll(async () => {\n//   await api.disconnect();\n// });\n//\n// describe('Staking derived queries', () => {\n//\n//   test('test elected validators info for local chain', async done =>{\n//     const electedValidatorInfo = await api.derive.stakingCennznet.electedInfo();\n//     const {info, nextElected, validators} = electedValidatorInfo;\n//     expect(info).toBeDefined();\n//     expect(info[0].accountId.toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     expect(info[0].controllerId.toString()).toEqual('5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY');\n//     expect(info[0].exposure.total.toNumber()).toEqual(1000000);\n//     expect(info[0].exposure.own.toNumber()).toEqual(1000000);\n//     expect(info[0].exposure.others.length).toEqual(0);\n//     expect(info[0].nominators.length).toEqual(0);\n//     expect(info[0].rewardDestination.toString()).toEqual('Stash');\n//     expect(info[0].stashId.toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     expect(nextElected.length).toBeGreaterThanOrEqual(1);\n//     expect(validators.length).toBeGreaterThanOrEqual(1);\n//     done();\n//   })\n//\n//   test('test waiting validators info query', async done =>{\n//     const waitingValidatorsToBeElected = await api.derive.stakingCennznet.waitingInfo();\n//     const {info, waiting} = waitingValidatorsToBeElected;\n//     expect(info.length).toEqual(0);\n//     expect(waiting.length).toEqual(0);\n//     done();\n//   })\n//\n//   test('validators info', async done => {\n//     const validatorDetails = await api.derive.stakingCennznet.validators();\n//     expect(validatorDetails.nextElected[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     expect(validatorDetails.validators[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     done();\n//   })\n//\n//   test('get all validators', async done => {\n//     const validatorList = await api.derive.stakingCennznet.stashes();\n//     expect(validatorList[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     done();\n//   })\n//\n//   test('test staking overview query', async done => {\n//     const validatorOverview = await api.derive.stakingCennznet.overview();\n//     expect(validatorOverview.activeEra.toString()).toEqual('0');\n//     expect(validatorOverview.activeEraStart.unwrap().toNumber()).toBeGreaterThanOrEqual(0);\n//     expect(validatorOverview.currentEra.toString()).toEqual('0');\n//     expect(validatorOverview.currentIndex.toNumber()).toBeGreaterThanOrEqual(0);\n//     expect(validatorOverview.validatorCount.toString()).toEqual('2');\n//     expect(validatorOverview.nextElected[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     expect(validatorOverview.validators[0].toString()).toEqual('5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY');\n//     done();\n//   })\n// });\n//\n// describe('Staking Operations', () => {\n//   // Note: order of test execution matters here\n//   let stash, controller;\n//\n//   beforeAll(async done => {\n//     stash = keyring.addFromUri('//Test//Stash');\n//     controller = keyring.addFromUri('//Test//Controller');\n//\n//     // Fund stash and controller\n//     const stakingId = await api.query.genericAsset.stakingAssetId();\n//     const spendingId = await api.query.genericAsset.spendingAssetId();\n//     let nonce = await api.rpc.system.accountNextIndex(alice.address);\n//\n//     // How much to fund stash and controller with\n//     const initialEndowment = 100_000_000;\n//\n//     // controller needs CPAY\n//     await api.tx.genericAsset\n//       .mint(spendingId, controller.address, initialEndowment)\n//       .signAndSend(alice, { nonce: nonce++ });\n//     // stash needs CENNZ and CPAY\n//     await api.tx.genericAsset\n//       .mint(spendingId, stash.address, initialEndowment)\n//       .signAndSend(alice, { nonce: nonce++ });\n//     await api.tx.genericAsset\n//       .mint(stakingId, stash.address, initialEndowment)\n//       .signAndSend(alice, { nonce }, ({ status }) => status.isInBlock ? done() : null);\n//\n//   });\n//\n//   test('Bond locks caller funds and assigns a controller account', async done => {\n//     const bond = (await api.query.staking.minimumBond()) + 12_345;\n//\n//     await api.tx.staking.bond(controller.address, bond, 'controller').signAndSend(stash, async ({ status }) => {\n//       if (status.isInBlock) {\n//         expect((await api.query.staking.bonded(stash.address)).toString()).toEqual(controller.address);\n//         const payee = await api.query.rewards.payee(stash.address);\n//         expect(payee.toString()).toEqual(controller.address);\n//         const ledger = ((await api.query.staking.ledger(controller.address)) as Option<StakingLedger>).unwrap();\n//         expect(ledger.active.toString()).toEqual(bond);\n//         expect(ledger.total.toString()).toEqual(bond);\n//\n//         done();\n//       }\n//     });\n//\n//   });\n//\n//   test('Bond extra locks additional funds', async done => {\n//\n//     const additionalBond = 333;\n//     const previousLedger = ((await api.query.staking.ledger(controller.address)) as Option<StakingLedger>).unwrap();\n//\n//     // Subscribe to ledger value changes\n//     await api.query.staking.ledger(controller.address, (ledgerOpt: Option<StakingLedger>) => {\n//       const ledger = ledgerOpt.unwrapOr(null);\n//       if (ledger?.active.toNumber() === (previousLedger.active.toNumber() + additionalBond)) {\n//         done();\n//       }\n//     });\n//\n//     await api.tx.staking.bondExtra(additionalBond).signAndSend(stash);\n//   });\n//\n//   test('Unbond schedules some funds to unlock', async done => {\n//     const unbondAmount = 500;\n//     const previousLedger = ((await api.query.staking.ledger(controller.address)) as Option<StakingLedger>).unwrap();\n//\n//     // Subscribe to ledger value changes\n//     await api.query.staking.ledger(controller.address, (ledgerOpt: Option<StakingLedger>) => {\n//       const ledger = ledgerOpt.unwrapOr(null);\n//       if (ledger?.active.toNumber() === (previousLedger.active.toNumber() - unbondAmount)) {\n//         done();\n//       }\n//     });\n//\n//     await api.tx.staking.unbond(unbondAmount).signAndSend(controller);\n//   });\n//\n//   /// Rebond a portion of the stash scheduled to be unlocked.\n//   test('Rebond locks funds again', async done => {\n//     const rebondAmount = 300;\n//     const previousLedger = ((await api.query.staking.ledger(controller.address)) as Option<StakingLedger>).unwrap();\n//\n//     // Subscribe to ledger value changes\n//     await api.query.staking.ledger(controller.address, (ledgerOpt: Option<StakingLedger>) => {\n//       const ledger = ledgerOpt.unwrapOr(null);\n//       if (ledger?.active.toNumber() === (previousLedger.active.toNumber() + rebondAmount)) {\n//         done();\n//       }\n//     });\n//\n//     await api.tx.staking.rebond(rebondAmount).signAndSend(controller);\n//   });\n//\n//   test('Withdraw unbonded', async done => {\n//     await api.tx.staking.withdrawUnbonded().signAndSend(controller, ({ status, events }) => {\n//       if (status.isInBlock) {\n//         expect(\n//           events.find(wrapper => wrapper.event.method === 'ExtrinsicSuccess')\n//         ).toBeDefined();\n//         done();\n//       }\n//     });\n//   });\n//\n//   test('Validate adds stash as a validator candidate', async done => {\n//     // parts per billion\n//     // 100,000,000 / 1,000,000,000 == 0.1%\n//     const commission = 1_000_000_000;\n//\n//     const checkCommission = async ({ status }) => {\n//       if (status.isInBlock) {\n//         const prefs = ((await api.query.staking.validators(stash.address)) as ValidatorPrefs);\n//         expect(prefs.commission.toNumber()).toEqual(commission);\n//         done();\n//       };\n//     };\n//\n//     await api.tx.staking.validate({ commission }).signAndSend(controller, checkCommission);\n//   });\n//\n//   test('Chill removes stash from validator candidacy', async done => {\n//\n//     const checkCommission = async ({ status }) => {\n//       if (status.isInBlock) {\n//         const prefs = ((await api.query.staking.validators(stash.address)) as ValidatorPrefs);\n//         expect(prefs.commission.toNumber()).toEqual(0);\n//         done();\n//       };\n//     };\n//\n//     await api.tx.staking.chill().signAndSend(controller, checkCommission);\n//   });\n//\n//   test('setPayee changes reward destination', async done => {\n//     // Payee account should be set to controller after prior bond() test.\n//     const payee = await api.query.rewards.payee(stash.address);\n//     expect(payee.toString()).toEqual(controller.address);\n//\n//     // Subscribe to payee changes\n//     await api.query.rewards.payee(stash.address, (payee) => {\n//       payee.toString() === stash.address ? done() : null\n//     });\n//\n//     await api.tx.staking.setPayee('stash').signAndSend(controller);\n//   });\n//\n//   test('Payout to any account', async done => {\n//     const rewardDestinationAddress = '5FEe8Ht1ZTzNjQcvrxbLxnykA2EXfqN5LMog2gaNPus4tfZR';\n//     // Payee account set to any account\n//     await api.tx.staking.setPayee({ account: rewardDestinationAddress }).signAndSend(controller);\n//     // Subscribe to payee changes\n//     await api.query.rewards.payee(stash.address, (payee: RewardDestination) => {\n//       (payee.toString() === rewardDestinationAddress) ? done() : null\n//     });\n//   });\n//\n//   test('setController changes controller account', async done => {\n//     // NB: ensure to run this test last as it changes the controller account.\n//     const newController = keyring.addFromUri('//NewController');\n//\n//     // Subscribe to controller account value changes\n//     await api.query.staking.bonded(stash.address, (controllerOpt: Option<AccountId>) => {\n//       const controllerAddress = keyring.encodeAddress(controllerOpt.unwrap());\n//       if (controllerAddress === newController.address) {\n//         done();\n//       }\n//     });\n//\n//     await api.tx.staking.setController(newController.address).signAndSend(stash);\n//   });\n//\n//   test('Calculate accruedPayout via RPC', async done => {\n//     const aliceStash = keyring.addFromUri('//Alice//stash');\n//     const accruedPayout = await api.rpc.staking.accruedPayout(aliceStash.address);\n//     expect(accruedPayout.toNumber()).toBe(0);\n//     done();\n//   });\n//\n//   test('check received heat beat on azalea', async done => {\n//     const apiAzalea = await Api.create({ network: 'azalea' });\n//     const recentlyOnline = await apiAzalea.derive.stakingCennznet.receivedHeartbeats();\n//     for (const [key] of Object.entries(recentlyOnline)) {\n//       const validator = recentlyOnline[key];\n//       expect(validator.blockCount.toNumber()).toBeGreaterThanOrEqual(0);\n//     }\n//     await apiAzalea.disconnect();\n//     done();\n//   });\n//\n// });\n//\n// describe('Staking Governance (Sudo Required)', () => {\n//\n//   afterAll(async done => {\n//     // Ensure era forcing is disabled\n//     await api.tx.sudo.sudo(api.tx.staking.forceNewEra())\n//       .signAndSend(alice, ({ status }) => status.isInBlock ? done() : null);\n//   });\n//\n//   test('Set target validator count', async done => {\n//     const validatorCount = 15;\n//     const setValidatorTx = api.tx.staking.setValidatorCount(validatorCount);\n//\n//     await api.tx.sudo.sudo(setValidatorTx).signAndSend(alice, async ({ status }) => {\n//       if (status.isInBlock) {\n//         expect((await api.query.staking.validatorCount()).toString()).toEqual(validatorCount.toString());\n//         done();\n//       }\n//     });\n//   });\n//\n//   test('Set minimum bond', async done => {\n//     const minimumBond = 1_234;\n//     const setMinimumBondTx = api.tx.staking.setMinimumBond(minimumBond);\n//\n//     await api.tx.sudo.sudo(setMinimumBondTx).signAndSend(alice, async ({ status }) => {\n//       if (status.isInBlock) {\n//         expect((await api.query.staking.minimumBond()).toString()).toEqual(minimumBond.toString());\n//         done();\n//       }\n//     });\n//   });\n//\n//\n//   test('Set invulnerable validators', async done => {\n//     const invulnerables: AccountId[] = keyring.getPairs().map(p => p.publicKey as AccountId);\n//     const setInvulnerablesTx = api.tx.staking.setInvulnerables(invulnerables);\n//\n//     await api.tx.sudo.sudo(setInvulnerablesTx).signAndSend(alice, async ({ status }) => {\n//       if (status.isInBlock) {\n//         expect(\n//           (await api.query.staking.invulnerables()).map(k => keyring.encodeAddress(k))\n//         ).toEqual(\n//           invulnerables.map(k => keyring.encodeAddress(k))\n//         );\n//         done();\n//       }\n//     });\n//   });\n//\n//   test('Force no eras', async done => {\n//     await api.query.staking.forceEra(\n//       (forcing: Forcing) => {\n//         if (forcing.isForceNone) done();\n//       }\n//     );\n//     await api.tx.sudo.sudo(api.tx.staking.forceNoEras()).signAndSend(alice);\n//   });\n//\n//   test('Force new era', async done => {\n//     const transactionFeePot = await api.query.rewards.transactionFeePotHistory();\n//     expect(transactionFeePot).toBeDefined();\n//     expect(transactionFeePot.length).toEqual(0); // Transaction fee pot is empty [] without call to noteFeePayout/makeRewardPayout\n//     await api.query.staking.forceEra(\n//       (forcing: Forcing) => {\n//         if (forcing.isForceNew) done();\n//       }\n//     );\n//     await api.tx.sudo.sudo(api.tx.staking.forceNewEra()).signAndSend(alice);\n//   });\n//\n//   test('Force new era always', async done => {\n//     await api.query.staking.forceEra(\n//       (forcing: Forcing) => {\n//         if (forcing.isForceAlways) done();\n//       }\n//     );\n//     await api.tx.sudo.sudo(api.tx.staking.forceNewEraAlways()).signAndSend(alice);\n//   });\n//\n//   test('Force unstake', async done => {\n//     const bobStash = keyring.addFromUri('//Bob//stash');\n//     new Promise<void>(async (resolve) => {\n//       // bond bob's stash account.\n//       await api.tx.staking.bond(bob.address, 10_000, 'controller')\n//           .signAndSend( bobStash, async ({ status }) => {\n//             if (status.isInBlock) {\n//                   const controller = (await api.query.staking.bonded(bobStash.address)) as Option<AccountId>;\n//                   expect(controller.unwrapOr(null)).toBeDefined();\n//                   resolve();\n//             }\n//           });\n//     }).then(async () => {\n//       const unstake = api.tx.staking.forceUnstake(bobStash.address);\n//       await api.tx.sudo.sudo(unstake).signAndSend(alice);\n//         // bob stash is removed / unbonded\n//       await api.query.staking.bonded(bobStash.address, (controller: Option<AccountId>) =>\n//         (controller.unwrapOr(null) === null) ? done() : null);\n//     });\n//   });\n//\n//   test('test azalea nominators', async done =>{\n//     const apiAzalea: Api = await Api.create({network: 'azalea'});\n//     const accountId = '5HnB5MbbAcbVvGQqvoHVDa5r9L1tyCChSGjKQ1awNojRGxb8';\n//     const nominators = await apiAzalea.query.staking.nominators(accountId);\n//     const nominatorList = nominators.unwrap();\n//     expect(nominatorList.targets.length).toBeGreaterThanOrEqual(0);\n//     expect(nominatorList.submittedIn.toNumber()).toBeGreaterThan(0);\n//     const validatorDetails = await apiAzalea.query.staking.validators(accountId);\n//     expect(validatorDetails.commission).toBeDefined();\n//     await apiAzalea.disconnect();\n//     done();\n//   });\n//\n// });\n"],"version":3}