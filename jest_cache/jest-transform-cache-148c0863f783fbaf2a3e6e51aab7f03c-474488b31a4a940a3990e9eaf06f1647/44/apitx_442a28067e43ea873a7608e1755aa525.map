{"file":"/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-tx.ts","mappings":";AAAA,mEAAmE;AACnE,oBAAoB;;AAEpB,8DAA8D;AAC9D,6DAA6D;AAC7D,gDAA8C","names":[],"sources":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-tx.ts"],"sourcesContent":["// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/api-base/types/submittable';\n\nimport type { ApiTypes, AugmentedSubmittable, SubmittableExtrinsic, SubmittableExtrinsicFunction } from '@polkadot/api-base/types';\nimport type { Bytes, Compact, Option, U256, U8aFixed, Vec, bool, u128, u16, u32, u64, u8 } from '@polkadot/types-codec';\nimport type { AnyNumber, IMethod, ITuple } from '@polkadot/types-codec/types';\nimport type { EthereumTransactionTransactionV2, FrameSupportScheduleMaybeHashed, PalletAssetsDestroyWitness, PalletElectionProviderMultiPhaseRawSolution, PalletElectionProviderMultiPhaseSolutionOrSnapshotSize, PalletEthyNotarizationPayload, PalletImOnlineHeartbeat, PalletImOnlineSr25519AppSr25519Signature, PalletNftCrossChainCompatibility, PalletNftRoyaltiesSchedule, PalletStakingPalletConfigOpPerbill, PalletStakingPalletConfigOpPercent, PalletStakingPalletConfigOpU128, PalletStakingPalletConfigOpU32, PalletStakingRewardDestination, PalletStakingValidatorPrefs, PalletXrplBridgeHelpersXrplTxData, SeedPrimitivesEthyCryptoAppCryptoPublic, SeedPrimitivesEthyCryptoAppCryptoSignature, SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, SeedRuntimeOriginCaller, SeedRuntimeSessionKeys, SpConsensusBabeDigestsNextConfigDescriptor, SpConsensusSlotsEquivocationProof, SpCoreVoid, SpFinalityGrandpaEquivocationProof, SpNposElectionsElectionScore, SpNposElectionsSupport, SpRuntimeHeader, SpSessionMembershipProof } from '@polkadot/types/lookup';\nimport type { Call, H160, H256, H512, Perbill, Percent, Permill } from '@therootnetwork/types/interfaces/runtime';\n\nexport type __AugmentedSubmittable = AugmentedSubmittable<() => unknown>;\nexport type __SubmittableExtrinsic<ApiType extends ApiTypes> = SubmittableExtrinsic<ApiType>;\nexport type __SubmittableExtrinsicFunction<ApiType extends ApiTypes> = SubmittableExtrinsicFunction<ApiType>;\n\ndeclare module '@polkadot/api-base/types/submittable' {\n  interface AugmentedSubmittables<ApiType extends ApiTypes> {\n    assets: {\n      /**\n       * Approve an amount of asset for transfer by a delegated third-party account.\n       * \n       * Origin must be Signed.\n       * \n       * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account\n       * for the purpose of holding the approval. If some non-zero amount of assets is already\n       * approved from signing account to `delegate`, then it is topped up or unreserved to\n       * meet the right value.\n       * \n       * NOTE: The signing account does not need to own `amount` of assets at the point of\n       * making this call.\n       * \n       * - `id`: The identifier of the asset.\n       * - `delegate`: The account to delegate permission to transfer asset.\n       * - `amount`: The amount of asset that may be transferred by `delegate`. If there is\n       * already an approval in place, then this acts additively.\n       * \n       * Emits `ApprovedTransfer` on success.\n       * \n       * Weight: `O(1)`\n       **/\n      approveTransfer: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.\n       * \n       * Origin must be Signed and the sender should be the Manager of the asset `id`.\n       * \n       * Bails with `NoAccount` if the `who` is already dead.\n       * \n       * - `id`: The identifier of the asset to have some amount burned.\n       * - `who`: The account to be debited from.\n       * - `amount`: The maximum amount by which `who`'s balance should be reduced.\n       * \n       * Emits `Burned` with the actual amount burned. If this takes the balance to below the\n       * minimum for the asset, then the amount burned is increased to take it to zero.\n       * \n       * Weight: `O(1)`\n       * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.\n       **/\n      burn: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Cancel all of some asset approved for delegated transfer by a third-party account.\n       * \n       * Origin must be Signed and there must be an approval in place between signer and\n       * `delegate`.\n       * \n       * Unreserves any deposit previously reserved by `approve_transfer` for the approval.\n       * \n       * - `id`: The identifier of the asset.\n       * - `delegate`: The account delegated permission to transfer asset.\n       * \n       * Emits `ApprovalCancelled` on success.\n       * \n       * Weight: `O(1)`\n       **/\n      cancelApproval: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Clear the metadata for an asset.\n       * \n       * Origin must be Signed and the sender should be the Owner of the asset `id`.\n       * \n       * Any deposit is freed for the asset owner.\n       * \n       * - `id`: The identifier of the asset to clear.\n       * \n       * Emits `MetadataCleared`.\n       * \n       * Weight: `O(1)`\n       **/\n      clearMetadata: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Issue a new class of fungible assets from a public origin.\n       * \n       * This new asset class has no assets initially and its owner is the origin.\n       * \n       * The origin must be Signed and the sender must have sufficient funds free.\n       * \n       * Funds of sender are reserved by `AssetDeposit`.\n       * \n       * Parameters:\n       * - `id`: The identifier of the new asset. This must not be currently in use to identify\n       * an existing asset.\n       * - `admin`: The admin of this class of assets. The admin is the initial address of each\n       * member of the asset class's admin team.\n       * - `min_balance`: The minimum balance of this new asset that any single account must\n       * have. If an account's balance is reduced below this, then it collapses to zero.\n       * \n       * Emits `Created` event when successful.\n       * \n       * Weight: `O(1)`\n       **/\n      create: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, admin: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, minBalance: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * Destroy a class of fungible assets.\n       * \n       * The origin must conform to `ForceOrigin` or must be Signed and the sender must be the\n       * owner of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be destroyed. This must identify an existing\n       * asset.\n       * \n       * Emits `Destroyed` event when successful.\n       * \n       * NOTE: It can be helpful to first freeze an asset before destroying it so that you\n       * can provide accurate witness information and prevent users from manipulating state\n       * in a way that can make it harder to destroy.\n       * \n       * Weight: `O(c + p + a)` where:\n       * - `c = (witness.accounts - witness.sufficients)`\n       * - `s = witness.sufficients`\n       * - `a = witness.approvals`\n       **/\n      destroy: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, witness: PalletAssetsDestroyWitness | { accounts?: any; sufficients?: any; approvals?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, PalletAssetsDestroyWitness]>;\n      /**\n       * Alter the attributes of a given asset.\n       * \n       * Origin must be `ForceOrigin`.\n       * \n       * - `id`: The identifier of the asset.\n       * - `owner`: The new Owner of this asset.\n       * - `issuer`: The new Issuer of this asset.\n       * - `admin`: The new Admin of this asset.\n       * - `freezer`: The new Freezer of this asset.\n       * - `min_balance`: The minimum balance of this new asset that any single account must\n       * have. If an account's balance is reduced below this, then it collapses to zero.\n       * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient\n       * value to account for the state bloat associated with its balance storage. If set to\n       * `true`, then non-zero balances may be stored without a `consumer` reference (and thus\n       * an ED in the Balances pallet or whatever else is used to control user-account state\n       * growth).\n       * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin\n       * instructions.\n       * \n       * Emits `AssetStatusChanged` with the identity of the asset.\n       * \n       * Weight: `O(1)`\n       **/\n      forceAssetStatus: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, issuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, admin: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, freezer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, minBalance: Compact<u128> | AnyNumber | Uint8Array, isSufficient: bool | boolean | Uint8Array, isFrozen: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Compact<u128>, bool, bool]>;\n      /**\n       * Cancel all of some asset approved for delegated transfer by a third-party account.\n       * \n       * Origin must be either ForceOrigin or Signed origin with the signer being the Admin\n       * account of the asset `id`.\n       * \n       * Unreserves any deposit previously reserved by `approve_transfer` for the approval.\n       * \n       * - `id`: The identifier of the asset.\n       * - `delegate`: The account delegated permission to transfer asset.\n       * \n       * Emits `ApprovalCancelled` on success.\n       * \n       * Weight: `O(1)`\n       **/\n      forceCancelApproval: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Clear the metadata for an asset.\n       * \n       * Origin must be ForceOrigin.\n       * \n       * Any deposit is returned.\n       * \n       * - `id`: The identifier of the asset to clear.\n       * \n       * Emits `MetadataCleared`.\n       * \n       * Weight: `O(1)`\n       **/\n      forceClearMetadata: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Issue a new class of fungible assets from a privileged origin.\n       * \n       * This new asset class has no assets initially.\n       * \n       * The origin must conform to `ForceOrigin`.\n       * \n       * Unlike `create`, no funds are reserved.\n       * \n       * - `id`: The identifier of the new asset. This must not be currently in use to identify\n       * an existing asset.\n       * - `owner`: The owner of this class of assets. The owner has full superuser permissions\n       * over this asset, but may later change and configure the permissions using\n       * `transfer_ownership` and `set_team`.\n       * - `min_balance`: The minimum balance of this new asset that any single account must\n       * have. If an account's balance is reduced below this, then it collapses to zero.\n       * \n       * Emits `ForceCreated` event when successful.\n       * \n       * Weight: `O(1)`\n       **/\n      forceCreate: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, isSufficient: bool | boolean | Uint8Array, minBalance: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, bool, Compact<u128>]>;\n      /**\n       * Force the metadata for an asset to some value.\n       * \n       * Origin must be ForceOrigin.\n       * \n       * Any deposit is left alone.\n       * \n       * - `id`: The identifier of the asset to update.\n       * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.\n       * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.\n       * - `decimals`: The number of decimals this asset uses to represent one unit.\n       * \n       * Emits `MetadataSet`.\n       * \n       * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.\n       **/\n      forceSetMetadata: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, name: Bytes | string | Uint8Array, symbol: Bytes | string | Uint8Array, decimals: u8 | AnyNumber | Uint8Array, isFrozen: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, Bytes, Bytes, u8, bool]>;\n      /**\n       * Move some assets from one account to another.\n       * \n       * Origin must be Signed and the sender should be the Admin of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to have some amount transferred.\n       * - `source`: The account to be debited.\n       * - `dest`: The account to be credited.\n       * - `amount`: The amount by which the `source`'s balance of assets should be reduced and\n       * `dest`'s balance increased. The amount actually transferred may be slightly greater in\n       * the case that the transfer would otherwise take the `source` balance above zero but\n       * below the minimum balance. Must be greater than zero.\n       * \n       * Emits `Transferred` with the actual amount transferred. If this takes the source balance\n       * to below the minimum for the asset, then the amount transferred is increased to take it\n       * to zero.\n       * \n       * Weight: `O(1)`\n       * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of\n       * `dest`.\n       **/\n      forceTransfer: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, source: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Disallow further unprivileged transfers from an account.\n       * \n       * Origin must be Signed and the sender should be the Freezer of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be frozen.\n       * - `who`: The account to be frozen.\n       * \n       * Emits `Frozen`.\n       * \n       * Weight: `O(1)`\n       **/\n      freeze: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Disallow further unprivileged transfers for the asset class.\n       * \n       * Origin must be Signed and the sender should be the Freezer of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be frozen.\n       * \n       * Emits `Frozen`.\n       * \n       * Weight: `O(1)`\n       **/\n      freezeAsset: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Mint assets of a particular class.\n       * \n       * The origin must be Signed and the sender must be the Issuer of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to have some amount minted.\n       * - `beneficiary`: The account to be credited with the minted assets.\n       * - `amount`: The amount of the asset to be minted.\n       * \n       * Emits `Issued` event when successful.\n       * \n       * Weight: `O(1)`\n       * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.\n       **/\n      mint: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, beneficiary: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Return the deposit (if any) of an asset account.\n       * \n       * The origin must be Signed.\n       * \n       * - `id`: The identifier of the asset for the account to be created.\n       * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.\n       * \n       * Emits `Refunded` event when successful.\n       **/\n      refund: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, allowBurn: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, bool]>;\n      /**\n       * Set the metadata for an asset.\n       * \n       * Origin must be Signed and the sender should be the Owner of the asset `id`.\n       * \n       * Funds of sender are reserved according to the formula:\n       * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into\n       * account any already reserved funds.\n       * \n       * - `id`: The identifier of the asset to update.\n       * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.\n       * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.\n       * - `decimals`: The number of decimals this asset uses to represent one unit.\n       * \n       * Emits `MetadataSet`.\n       * \n       * Weight: `O(1)`\n       **/\n      setMetadata: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, name: Bytes | string | Uint8Array, symbol: Bytes | string | Uint8Array, decimals: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, Bytes, Bytes, u8]>;\n      /**\n       * Change the Issuer, Admin and Freezer of an asset.\n       * \n       * Origin must be Signed and the sender should be the Owner of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be frozen.\n       * - `issuer`: The new Issuer of this asset.\n       * - `admin`: The new Admin of this asset.\n       * - `freezer`: The new Freezer of this asset.\n       * \n       * Emits `TeamChanged`.\n       * \n       * Weight: `O(1)`\n       **/\n      setTeam: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, issuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, admin: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, freezer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Allow unprivileged transfers from an account again.\n       * \n       * Origin must be Signed and the sender should be the Admin of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be frozen.\n       * - `who`: The account to be unfrozen.\n       * \n       * Emits `Thawed`.\n       * \n       * Weight: `O(1)`\n       **/\n      thaw: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Allow unprivileged transfers for the asset again.\n       * \n       * Origin must be Signed and the sender should be the Admin of the asset `id`.\n       * \n       * - `id`: The identifier of the asset to be thawed.\n       * \n       * Emits `Thawed`.\n       * \n       * Weight: `O(1)`\n       **/\n      thawAsset: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Create an asset account for non-provider assets.\n       * \n       * A deposit will be taken from the signer account.\n       * \n       * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit\n       * to be taken.\n       * - `id`: The identifier of the asset for the account to be created.\n       * \n       * Emits `Touched` event when successful.\n       **/\n      touch: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Move some assets from the sender account to another.\n       * \n       * Origin must be Signed.\n       * \n       * - `id`: The identifier of the asset to have some amount transferred.\n       * - `target`: The account to be credited.\n       * - `amount`: The amount by which the sender's balance of assets should be reduced and\n       * `target`'s balance increased. The amount actually transferred may be slightly greater in\n       * the case that the transfer would otherwise take the sender balance above zero but below\n       * the minimum balance. Must be greater than zero.\n       * \n       * Emits `Transferred` with the actual amount transferred. If this takes the source balance\n       * to below the minimum for the asset, then the amount transferred is increased to take it\n       * to zero.\n       * \n       * Weight: `O(1)`\n       * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of\n       * `target`.\n       **/\n      transfer: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, target: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Transfer some asset balance from a previously delegated account to some third-party\n       * account.\n       * \n       * Origin must be Signed and there must be an approval in place by the `owner` to the\n       * signer.\n       * \n       * If the entire amount approved for transfer is transferred, then any deposit previously\n       * reserved by `approve_transfer` is unreserved.\n       * \n       * - `id`: The identifier of the asset.\n       * - `owner`: The account which previously approved for a transfer of at least `amount` and\n       * from which the asset balance will be withdrawn.\n       * - `destination`: The account to which the asset balance of `amount` will be transferred.\n       * - `amount`: The amount of assets to transfer.\n       * \n       * Emits `TransferredApproved` on success.\n       * \n       * Weight: `O(1)`\n       **/\n      transferApproved: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, destination: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Move some assets from the sender account to another, keeping the sender account alive.\n       * \n       * Origin must be Signed.\n       * \n       * - `id`: The identifier of the asset to have some amount transferred.\n       * - `target`: The account to be credited.\n       * - `amount`: The amount by which the sender's balance of assets should be reduced and\n       * `target`'s balance increased. The amount actually transferred may be slightly greater in\n       * the case that the transfer would otherwise take the sender balance above zero but below\n       * the minimum balance. Must be greater than zero.\n       * \n       * Emits `Transferred` with the actual amount transferred. If this takes the source balance\n       * to below the minimum for the asset, then the amount transferred is increased to take it\n       * to zero.\n       * \n       * Weight: `O(1)`\n       * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of\n       * `target`.\n       **/\n      transferKeepAlive: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, target: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Change the Owner of an asset.\n       * \n       * Origin must be Signed and the sender should be the Owner of the asset `id`.\n       * \n       * - `id`: The identifier of the asset.\n       * - `owner`: The new Owner of this asset.\n       * \n       * Emits `OwnerChanged`.\n       * \n       * Weight: `O(1)`\n       **/\n      transferOwnership: AugmentedSubmittable<(id: Compact<u32> | AnyNumber | Uint8Array, owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    assetsExt: {\n      /**\n       * Creates a new asset with unique ID according to the network asset id scheme.\n       **/\n      createAsset: AugmentedSubmittable<(name: Bytes | string | Uint8Array, symbol: Bytes | string | Uint8Array, decimals: u8 | AnyNumber | Uint8Array, minBalance: Option<u128> | null | Uint8Array | u128 | AnyNumber, owner: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string) => SubmittableExtrinsic<ApiType>, [Bytes, Bytes, u8, Option<u128>, Option<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    authorship: {\n      /**\n       * Provide a set of uncles.\n       **/\n      setUncles: AugmentedSubmittable<(newUncles: Vec<SpRuntimeHeader> | (SpRuntimeHeader | { parentHash?: any; number?: any; stateRoot?: any; extrinsicsRoot?: any; digest?: any } | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SpRuntimeHeader>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    babe: {\n      /**\n       * Plan an epoch config change. The epoch config change is recorded and will be enacted on\n       * the next call to `enact_epoch_change`. The config will be activated one epoch after.\n       * Multiple calls to this method will replace any existing planned config change that had\n       * not been enacted yet.\n       **/\n      planConfigChange: AugmentedSubmittable<(config: SpConsensusBabeDigestsNextConfigDescriptor | { V1: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SpConsensusBabeDigestsNextConfigDescriptor]>;\n      /**\n       * Report authority equivocation/misbehavior. This method will verify\n       * the equivocation proof and validate the given key ownership proof\n       * against the extracted offender. If both are valid, the offence will\n       * be reported.\n       **/\n      reportEquivocation: AugmentedSubmittable<(equivocationProof: SpConsensusSlotsEquivocationProof | { offender?: any; slot?: any; firstHeader?: any; secondHeader?: any } | string | Uint8Array, keyOwnerProof: SpSessionMembershipProof | { session?: any; trieNodes?: any; validatorCount?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SpConsensusSlotsEquivocationProof, SpSessionMembershipProof]>;\n      /**\n       * Report authority equivocation/misbehavior. This method will verify\n       * the equivocation proof and validate the given key ownership proof\n       * against the extracted offender. If both are valid, the offence will\n       * be reported.\n       * This extrinsic must be called unsigned and it is expected that only\n       * block authors will call it (validated in `ValidateUnsigned`), as such\n       * if the block author is defined it will be defined as the equivocation\n       * reporter.\n       **/\n      reportEquivocationUnsigned: AugmentedSubmittable<(equivocationProof: SpConsensusSlotsEquivocationProof | { offender?: any; slot?: any; firstHeader?: any; secondHeader?: any } | string | Uint8Array, keyOwnerProof: SpSessionMembershipProof | { session?: any; trieNodes?: any; validatorCount?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SpConsensusSlotsEquivocationProof, SpSessionMembershipProof]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    balances: {\n      /**\n       * Exactly as `transfer`, except the origin must be root and the source account may be\n       * specified.\n       * # <weight>\n       * - Same as transfer, but additional read and write because the source account is not\n       * assumed to be in the overlay.\n       * # </weight>\n       **/\n      forceTransfer: AugmentedSubmittable<(source: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Unreserve some balance from a user by force.\n       * \n       * Can only be called by ROOT.\n       **/\n      forceUnreserve: AugmentedSubmittable<(who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, u128]>;\n      /**\n       * Set the balances of a given account.\n       * \n       * This will alter `FreeBalance` and `ReservedBalance` in storage. it will\n       * also alter the total issuance of the system (`TotalIssuance`) appropriately.\n       * If the new free or reserved balance is below the existential deposit,\n       * it will reset the account nonce (`frame_system::AccountNonce`).\n       * \n       * The dispatch origin for this call is `root`.\n       **/\n      setBalance: AugmentedSubmittable<(who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, newFree: Compact<u128> | AnyNumber | Uint8Array, newReserved: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Compact<u128>, Compact<u128>]>;\n      /**\n       * Transfer some liquid free balance to another account.\n       * \n       * `transfer` will set the `FreeBalance` of the sender and receiver.\n       * If the sender's account is below the existential deposit as a result\n       * of the transfer, the account will be reaped.\n       * \n       * The dispatch origin for this call must be `Signed` by the transactor.\n       * \n       * # <weight>\n       * - Dependent on arguments but not critical, given proper implementations for input config\n       * types. See related functions below.\n       * - It contains a limited number of reads and writes internally and no complex\n       * computation.\n       * \n       * Related functions:\n       * \n       * - `ensure_can_withdraw` is always called internally but has a bounded complexity.\n       * - Transferring balances to accounts that did not exist before will cause\n       * `T::OnNewAccount::on_new_account` to be called.\n       * - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.\n       * - `transfer_keep_alive` works the same way as `transfer`, but has an additional check\n       * that the transfer will not kill the origin account.\n       * ---------------------------------\n       * - Origin account is already in memory, so no DB operations for them.\n       * # </weight>\n       **/\n      transfer: AugmentedSubmittable<(dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Transfer the entire transferable balance from the caller account.\n       * \n       * NOTE: This function only attempts to transfer _transferable_ balances. This means that\n       * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be\n       * transferred by this function. To ensure that this function results in a killed account,\n       * you might need to prepare the account by removing any reference counters, storage\n       * deposits, etc...\n       * \n       * The dispatch origin of this call must be Signed.\n       * \n       * - `dest`: The recipient of the transfer.\n       * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all\n       * of the funds the account has, causing the sender account to be killed (false), or\n       * transfer everything except at least the existential deposit, which will guarantee to\n       * keep the sender account alive (true). # <weight>\n       * - O(1). Just like transfer, but reading the user's transferable balance first.\n       * #</weight>\n       **/\n      transferAll: AugmentedSubmittable<(dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, keepAlive: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, bool]>;\n      /**\n       * Same as the [`transfer`] call, but with a check that the transfer will not kill the\n       * origin account.\n       * \n       * 99% of the time you want [`transfer`] instead.\n       * \n       * [`transfer`]: struct.Pallet.html#method.transfer\n       **/\n      transferKeepAlive: AugmentedSubmittable<(dest: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Compact<u128>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    dex: {\n      /**\n       * Add liquidity to Enabled trading pair, or add provision to Provisioning trading pair.\n       * - Add liquidity success will issue shares in current price which decided by the\n       * liquidity scale. Shares are temporarily not\n       * allowed to transfer and trade, it represents the proportion of\n       * assets in liquidity pool.\n       * - Add provision success will record the provision, issue shares to caller in the initial\n       * price when trading pair convert to Enabled.\n       * - Creates and enables TradingPair LP token if it does not exist for trading pair.\n       * - Fails to add liquidity for `NotEnabled` trading pair.\n       * \n       * - `asset_id_a`: Asset id A.\n       * - `asset_id_b`: Asset id B.\n       * - `amount_a_desired`: amount a desired to add.\n       * - `amount_b_desired`: amount b desired to add.\n       * - `amount_a_min`: amount a minimum willing to add.\n       * - `amount_b_min`: amount b minimum willing to add.\n       * - `min_share_increment`: minimum expected lp token shares to be recieved.\n       **/\n      addLiquidity: AugmentedSubmittable<(assetIdA: u32 | AnyNumber | Uint8Array, assetIdB: u32 | AnyNumber | Uint8Array, amountADesired: Compact<u128> | AnyNumber | Uint8Array, amountBDesired: Compact<u128> | AnyNumber | Uint8Array, amountAMin: Compact<u128> | AnyNumber | Uint8Array, amountBMin: Compact<u128> | AnyNumber | Uint8Array, minShareIncrement: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32, Compact<u128>, Compact<u128>, Compact<u128>, Compact<u128>, Compact<u128>]>;\n      /**\n       * Disable an `Enabled` trading pair.\n       * - Requires LP token to be created and in the `Enabled` status\n       * - Only root can disable trading pair\n       * \n       * - `asset_id_a`: Asset id A.\n       * - `asset_id_b`: Asset id B.\n       **/\n      disableTradingPair: AugmentedSubmittable<(assetIdA: u32 | AnyNumber | Uint8Array, assetIdB: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Re enable a `NotEnabled` trading pair.\n       * - Requires LP token to be created and in the `NotEnabled` status\n       * - Only root can enable a disabled trading pair\n       * \n       * - `asset_id_a`: Asset id A.\n       * - `asset_id_b`: Asset id B.\n       **/\n      reenableTradingPair: AugmentedSubmittable<(assetIdA: u32 | AnyNumber | Uint8Array, assetIdB: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Remove liquidity from specific liquidity pool in the form of burning\n       * shares, and withdrawing currencies in trading pairs from liquidity\n       * pool in proportion, and withdraw liquidity incentive interest.\n       * - note: liquidity can still be withdrawn for `NotEnabled` trading pairs.\n       * \n       * - `asset_id_a`: Asset id A.\n       * - `asset_id_b`: Asset id B.\n       * - `remove_liquidity`: liquidity amount to remove.\n       * - `min_withdrawn_a`: minimum amount of asset A to be withdrawn from LP token.\n       * - `min_withdrawn_b`: minimum amount of asset B to be withdrawn from LP token.\n       **/\n      removeLiquidity: AugmentedSubmittable<(assetIdA: u32 | AnyNumber | Uint8Array, assetIdB: u32 | AnyNumber | Uint8Array, removeLiquidity: Compact<u128> | AnyNumber | Uint8Array, minWithdrawnA: Compact<u128> | AnyNumber | Uint8Array, minWithdrawnB: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32, Compact<u128>, Compact<u128>, Compact<u128>]>;\n      /**\n       * Trading with DEX, swap with exact supply amount. Specify your input; retrieve variable\n       * output.\n       * - note: analogous to Uniswapv2 `swapExactTokensForTokens`\n       * \n       * - `path`: trading path.\n       * - `amount_in`: exact supply amount.\n       * - `amount_out_min`: acceptable minimum target amount.\n       **/\n      swapWithExactSupply: AugmentedSubmittable<(amountIn: Compact<u128> | AnyNumber | Uint8Array, amountOutMin: Compact<u128> | AnyNumber | Uint8Array, path: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Compact<u128>, Compact<u128>, Vec<u32>]>;\n      /**\n       * Trading with DEX, swap with exact target amount. Specify your output; supply variable\n       * input.\n       * - note: analogous to Uniswapv2 `swapTokensForExactTokens`\n       * \n       * - `amount_out`: exact target amount.\n       * - `amount_in_max`: acceptable maximum supply amount.\n       * - `path`: trading path.\n       **/\n      swapWithExactTarget: AugmentedSubmittable<(amountOut: Compact<u128> | AnyNumber | Uint8Array, amountInMax: Compact<u128> | AnyNumber | Uint8Array, path: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Compact<u128>, Compact<u128>, Vec<u32>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    echo: {\n      /**\n       * Ping extrinsic sends an event to the bridge containing a message\n       **/\n      ping: AugmentedSubmittable<(destination: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    electionProviderMultiPhase: {\n      /**\n       * Trigger the governance fallback.\n       * \n       * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to\n       * calling [`Call::set_emergency_election_result`].\n       **/\n      governanceFallback: AugmentedSubmittable<(maybeMaxVoters: Option<u32> | null | Uint8Array | u32 | AnyNumber, maybeMaxTargets: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [Option<u32>, Option<u32>]>;\n      /**\n       * Set a solution in the queue, to be handed out to the client of this pallet in the next\n       * call to `ElectionProvider::elect`.\n       * \n       * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.\n       * \n       * The solution is not checked for any feasibility and is assumed to be trustworthy, as any\n       * feasibility check itself can in principle cause the election process to fail (due to\n       * memory/weight constrains).\n       **/\n      setEmergencyElectionResult: AugmentedSubmittable<(supports: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, SpNposElectionsSupport]>> | ([SeedPrimitivesSignatureAccountId20 | string | Uint8Array, SpNposElectionsSupport | { total?: any; voters?: any } | string | Uint8Array])[]) => SubmittableExtrinsic<ApiType>, [Vec<ITuple<[SeedPrimitivesSignatureAccountId20, SpNposElectionsSupport]>>]>;\n      /**\n       * Set a new value for `MinimumUntrustedScore`.\n       * \n       * Dispatch origin must be aligned with `T::ForceOrigin`.\n       * \n       * This check can be turned off by setting the value to `None`.\n       **/\n      setMinimumUntrustedScore: AugmentedSubmittable<(maybeNextScore: Option<SpNposElectionsElectionScore> | null | Uint8Array | SpNposElectionsElectionScore | { minimalStake?: any; sumStake?: any; sumStakeSquared?: any } | string) => SubmittableExtrinsic<ApiType>, [Option<SpNposElectionsElectionScore>]>;\n      /**\n       * Submit a solution for the signed phase.\n       * \n       * The dispatch origin fo this call must be __signed__.\n       * \n       * The solution is potentially queued, based on the claimed score and processed at the end\n       * of the signed phase.\n       * \n       * A deposit is reserved and recorded for the solution. Based on the outcome, the solution\n       * might be rewarded, slashed, or get all or a part of the deposit back.\n       **/\n      submit: AugmentedSubmittable<(rawSolution: PalletElectionProviderMultiPhaseRawSolution | { solution?: any; score?: any; round?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletElectionProviderMultiPhaseRawSolution]>;\n      /**\n       * Submit a solution for the unsigned phase.\n       * \n       * The dispatch origin fo this call must be __none__.\n       * \n       * This submission is checked on the fly. Moreover, this unsigned solution is only\n       * validated when submitted to the pool from the **local** node. Effectively, this means\n       * that only active validators can submit this transaction when authoring a block (similar\n       * to an inherent).\n       * \n       * To prevent any incorrect solution (and thus wasted time/weight), this transaction will\n       * panic if the solution submitted by the validator is invalid in any way, effectively\n       * putting their authoring reward at risk.\n       * \n       * No deposit or reward is associated with this submission.\n       **/\n      submitUnsigned: AugmentedSubmittable<(rawSolution: PalletElectionProviderMultiPhaseRawSolution | { solution?: any; score?: any; round?: any } | string | Uint8Array, witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize | { voters?: any; targets?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletElectionProviderMultiPhaseRawSolution, PalletElectionProviderMultiPhaseSolutionOrSnapshotSize]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    erc20Peg: {\n      /**\n       * Activate/deactivate deposits (root only)\n       **/\n      activateDeposits: AugmentedSubmittable<(activate: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [bool]>;\n      /**\n       * Activate/deactivate withdrawals (root only)\n       **/\n      activateWithdrawals: AugmentedSubmittable<(activate: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [bool]>;\n      setContractAddress: AugmentedSubmittable<(ethAddress: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      setErc20Meta: AugmentedSubmittable<(details: Vec<ITuple<[H160, Bytes, u8]>> | ([H160 | string | Uint8Array, Bytes | string | Uint8Array, u8 | AnyNumber | Uint8Array])[]) => SubmittableExtrinsic<ApiType>, [Vec<ITuple<[H160, Bytes, u8]>>]>;\n      setPaymentDelay: AugmentedSubmittable<(assetId: u32 | AnyNumber | Uint8Array, minBalance: u128 | AnyNumber | Uint8Array, delay: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u128, u32]>;\n      withdraw: AugmentedSubmittable<(assetId: u32 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array, beneficiary: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u128, H160]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    ethBridge: {\n      depositRelayerBond: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      finaliseAuthoritiesChange: AugmentedSubmittable<(nextNotaryKeys: Vec<SeedPrimitivesEthyCryptoAppCryptoPublic> | (SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>]>;\n      setBridgePaused: AugmentedSubmittable<(paused: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [bool]>;\n      setChallengePeriod: AugmentedSubmittable<(blocks: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32]>;\n      setContractAddress: AugmentedSubmittable<(contractAddress: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      setDelayedEventProofsPerBlock: AugmentedSubmittable<(count: u8 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u8]>;\n      setEventBlockConfirmations: AugmentedSubmittable<(confirmations: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      setRelayer: AugmentedSubmittable<(relayer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      setXrplDoorSigners: AugmentedSubmittable<(newSigners: Vec<SeedPrimitivesEthyCryptoAppCryptoPublic> | (SeedPrimitivesEthyCryptoAppCryptoPublic | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesEthyCryptoAppCryptoPublic>]>;\n      submitChallenge: AugmentedSubmittable<(eventClaimId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      submitEvent: AugmentedSubmittable<(txHash: H256 | string | Uint8Array, event: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H256, Bytes]>;\n      submitNotarization: AugmentedSubmittable<(payload: PalletEthyNotarizationPayload | { Call: any } | { Event: any } | string | Uint8Array, signature: SeedPrimitivesEthyCryptoAppCryptoSignature | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletEthyNotarizationPayload, SeedPrimitivesEthyCryptoAppCryptoSignature]>;\n      withdrawRelayerBond: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    ethereum: {\n      /**\n       * Transact an Ethereum transaction.\n       **/\n      transact: AugmentedSubmittable<(transaction: EthereumTransactionTransactionV2 | { Legacy: any } | { EIP2930: any } | { EIP1559: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [EthereumTransactionTransactionV2]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    evm: {\n      /**\n       * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.\n       **/\n      call: AugmentedSubmittable<(source: H160 | string | Uint8Array, target: H160 | string | Uint8Array, input: Bytes | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, maxFeePerGas: U256 | AnyNumber | Uint8Array, maxPriorityFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, nonce: Option<U256> | null | Uint8Array | U256 | AnyNumber, accessList: Vec<ITuple<[H160, Vec<H256>]>> | ([H160 | string | Uint8Array, Vec<H256> | (H256 | string | Uint8Array)[]])[]) => SubmittableExtrinsic<ApiType>, [H160, H160, Bytes, U256, u64, U256, Option<U256>, Option<U256>, Vec<ITuple<[H160, Vec<H256>]>>]>;\n      /**\n       * Issue an EVM create operation. This is similar to a contract creation transaction in\n       * Ethereum.\n       **/\n      create: AugmentedSubmittable<(source: H160 | string | Uint8Array, init: Bytes | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, maxFeePerGas: U256 | AnyNumber | Uint8Array, maxPriorityFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, nonce: Option<U256> | null | Uint8Array | U256 | AnyNumber, accessList: Vec<ITuple<[H160, Vec<H256>]>> | ([H160 | string | Uint8Array, Vec<H256> | (H256 | string | Uint8Array)[]])[]) => SubmittableExtrinsic<ApiType>, [H160, Bytes, U256, u64, U256, Option<U256>, Option<U256>, Vec<ITuple<[H160, Vec<H256>]>>]>;\n      /**\n       * Issue an EVM create2 operation.\n       **/\n      create2: AugmentedSubmittable<(source: H160 | string | Uint8Array, init: Bytes | string | Uint8Array, salt: H256 | string | Uint8Array, value: U256 | AnyNumber | Uint8Array, gasLimit: u64 | AnyNumber | Uint8Array, maxFeePerGas: U256 | AnyNumber | Uint8Array, maxPriorityFeePerGas: Option<U256> | null | Uint8Array | U256 | AnyNumber, nonce: Option<U256> | null | Uint8Array | U256 | AnyNumber, accessList: Vec<ITuple<[H160, Vec<H256>]>> | ([H160 | string | Uint8Array, Vec<H256> | (H256 | string | Uint8Array)[]])[]) => SubmittableExtrinsic<ApiType>, [H160, Bytes, H256, U256, u64, U256, Option<U256>, Option<U256>, Vec<ITuple<[H160, Vec<H256>]>>]>;\n      /**\n       * Withdraw balance from EVM into currency/balances pallet.\n       **/\n      withdraw: AugmentedSubmittable<(address: H160 | string | Uint8Array, value: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160, u128]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    evmChainId: {\n      setChainId: AugmentedSubmittable<(chainId: Compact<u64> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u64>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    feeControl: {\n      setEvmBaseFee: AugmentedSubmittable<(value: U256 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [U256]>;\n      setWeightMultiplier: AugmentedSubmittable<(value: Perbill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Perbill]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    feeProxy: {\n      /**\n       * Call an internal call with specified gas token\n       * payment_asset: The token to be used for paying gas fees. This is exchanged in\n       * OnChargeTransaction::withdraw_fee()\n       * max_payment: The limit of how many tokens will be used to perform the exchange\n       * call: The inner call to be performed after the exchange\n       **/\n      callWithFeePreferences: AugmentedSubmittable<(paymentAsset: u32 | AnyNumber | Uint8Array, maxPayment: u128 | AnyNumber | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u128, Call]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    futurepass: {\n      /**\n       * Create a futurepass account for the delegator that is able to make calls on behalf of\n       * futurepass.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `account`: The delegated account for the futurepass.\n       **/\n      create: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * This extrinsic migrates EVM-based Futurepass assets to the Substrate-based Futurepass\n       * (native).\n       * \n       * Parameters:\n       * - `owner` - The account ID of the owner of the EVM-based Futurepass.\n       * - `evm_futurepass` - The account ID of the EVM-based Futurepass.\n       * - `collection_ids` - A vector of collection IDs representing the NFTs collections to be\n       * migrated.\n       * \n       * # <weight>\n       * Weight is a function of the number of collections migrated; not the tokens migrated.\n       * # </weight>\n       **/\n      migrateEvmFuturepass: AugmentedSubmittable<(owner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, evmFuturepass: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, collectionIds: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Vec<u32>]>;\n      /**\n       * Dispatch the given call through Futurepass account. Transaction fees will be paid by the\n       * Futurepass The dispatch origin for this call must be _Signed_\n       * \n       * Parameters:\n       * - `futurepass`: The Futurepass account though which the call is dispatched\n       * - `call`: The Call that needs to be dispatched through the Futurepass account\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has.\n       * # </weight>\n       **/\n      proxyExtrinsic: AugmentedSubmittable<(futurepass: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Call]>;\n      /**\n       * Register a delegator to an existing futurepass account.\n       * Note: Only futurepass owner account can add more delegates.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `futurepass`: Futurepass account to register the account as delegate.\n       * - `proxy_type`: Delegate permission level\n       * - `delegate`: The delegated account for the futurepass.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has.\n       * # </weight>\n       **/\n      registerDelegate: AugmentedSubmittable<(futurepass: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType]>;\n      /**\n       * Update futurepass native assets migrator admin account.\n       * \n       * The dispatch origin for this call must be sudo/root origin.\n       * \n       * Parameters:\n       * - `migrator`: The new account that will become the futurepass asset migrator.\n       **/\n      setFuturepassMigrator: AugmentedSubmittable<(migrator: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Transfer ownership of a futurepass to a new account.\n       * The new owner must not already own a futurepass.\n       * This removes all delegates from the futurepass.\n       * The new owner will be the only delegate; they can add more delegates.\n       * \n       * The dispatch origin for this call must be _Signed_ and must be the current owner of the\n       * futurepass.\n       * \n       * Parameters:\n       * - `new_owner`: The new account that will become the owner of the futurepass.\n       **/\n      transferFuturepass: AugmentedSubmittable<(newOwner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Unregister a delegate from a futurepass account.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `futurepass`: Futurepass account to unregister the delegate from.\n       * - `delegate`: The delegated account for the futurepass. Note: if caller is futurepass\n       * holder onwer,\n       * they can remove any delegate (including themselves); otherwise the caller must be the\n       * delegate (can only remove themself).\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has.\n       * # </weight>\n       **/\n      unregisterDelegate: AugmentedSubmittable<(futurepass: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    grandpa: {\n      /**\n       * Note that the current authority set of the GRANDPA finality gadget has stalled.\n       * \n       * This will trigger a forced authority set change at the beginning of the next session, to\n       * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume\n       * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.\n       * The block production rate (which may be slowed down because of finality lagging) should\n       * be taken into account when choosing the `delay`. The GRANDPA voters based on the new\n       * authority will start voting on top of `best_finalized_block_number` for new finalized\n       * blocks. `best_finalized_block_number` should be the highest of the latest finalized\n       * block of all validators of the new authority set.\n       * \n       * Only callable by root.\n       **/\n      noteStalled: AugmentedSubmittable<(delay: u32 | AnyNumber | Uint8Array, bestFinalizedBlockNumber: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Report voter equivocation/misbehavior. This method will verify the\n       * equivocation proof and validate the given key ownership proof\n       * against the extracted offender. If both are valid, the offence\n       * will be reported.\n       **/\n      reportEquivocation: AugmentedSubmittable<(equivocationProof: SpFinalityGrandpaEquivocationProof | { setId?: any; equivocation?: any } | string | Uint8Array, keyOwnerProof: SpCoreVoid | null) => SubmittableExtrinsic<ApiType>, [SpFinalityGrandpaEquivocationProof, SpCoreVoid]>;\n      /**\n       * Report voter equivocation/misbehavior. This method will verify the\n       * equivocation proof and validate the given key ownership proof\n       * against the extracted offender. If both are valid, the offence\n       * will be reported.\n       * \n       * This extrinsic must be called unsigned and it is expected that only\n       * block authors will call it (validated in `ValidateUnsigned`), as such\n       * if the block author is defined it will be defined as the equivocation\n       * reporter.\n       **/\n      reportEquivocationUnsigned: AugmentedSubmittable<(equivocationProof: SpFinalityGrandpaEquivocationProof | { setId?: any; equivocation?: any } | string | Uint8Array, keyOwnerProof: SpCoreVoid | null) => SubmittableExtrinsic<ApiType>, [SpFinalityGrandpaEquivocationProof, SpCoreVoid]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    imOnline: {\n      /**\n       * # <weight>\n       * - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is\n       * length of `heartbeat.network_state.external_address`\n       * - `O(K)`: decoding of length `K`\n       * - `O(E)`: decoding/encoding of length `E`\n       * - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,\n       * `ReceivedHeartbeats`\n       * - DbWrites: `ReceivedHeartbeats`\n       * # </weight>\n       **/\n      heartbeat: AugmentedSubmittable<(heartbeat: PalletImOnlineHeartbeat | { blockNumber?: any; networkState?: any; sessionIndex?: any; authorityIndex?: any; validatorsLen?: any } | string | Uint8Array, signature: PalletImOnlineSr25519AppSr25519Signature | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletImOnlineHeartbeat, PalletImOnlineSr25519AppSr25519Signature]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    marketplace: {\n      /**\n       * Accepts an offer on a token\n       * Caller must be token owner\n       **/\n      acceptOffer: AugmentedSubmittable<(offerId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Auction a bundle of tokens on the open market to the highest bidder\n       * - Tokens must be from the same collection\n       * - Tokens with individual royalties schedules cannot be sold in bundles\n       * \n       * Caller must be the token owner\n       * - `payment_asset` fungible asset Id to receive payment with\n       * - `reserve_price` winning bid must be over this threshold\n       * - `duration` length of the auction (in blocks), uses default duration if unspecified\n       **/\n      auctionNft: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], paymentAsset: u32 | AnyNumber | Uint8Array, reservePrice: u128 | AnyNumber | Uint8Array, duration: Option<u32> | null | Uint8Array | u32 | AnyNumber, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, u32, u128, Option<u32>, Option<u32>]>;\n      /**\n       * Place a bid on an open auction\n       * - `amount` to bid (in the seller's requested payment asset)\n       **/\n      bid: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, u128]>;\n      /**\n       * Buy a token listing for its specified price\n       **/\n      buy: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Cancels an offer on a token\n       * Caller must be the offer buyer\n       **/\n      cancelOffer: AugmentedSubmittable<(offerId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Close a sale or auction returning tokens\n       * Requires no successful bids have been made for an auction.\n       * Caller must be the listed seller\n       **/\n      cancelSale: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Create an offer on a token\n       * Locks funds until offer is accepted, rejected or cancelled\n       * An offer can't be made on a token currently in an auction\n       * (This follows the behaviour of Opensea and forces the buyer to bid rather than create an\n       * offer)\n       **/\n      makeSimpleOffer: AugmentedSubmittable<(tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], amount: u128 | AnyNumber | Uint8Array, assetId: u32 | AnyNumber | Uint8Array, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [ITuple<[u32, u32]>, u128, u32, Option<u32>]>;\n      /**\n       * Flag an account as a marketplace\n       * \n       * `marketplace_account` - if specified, this account will be registered\n       * `entitlement` - Permill, percentage of sales to go to the marketplace\n       * If no marketplace is specified the caller will be registered\n       **/\n      registerMarketplace: AugmentedSubmittable<(marketplaceAccount: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, entitlement: Permill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Option<SeedPrimitivesSignatureAccountId20>, Permill]>;\n      /**\n       * Sell a bundle of tokens at a fixed price\n       * - Tokens must be from the same collection\n       * - Tokens with individual royalties schedules cannot be sold with this method\n       * \n       * `buyer` optionally, the account to receive the NFT. If unspecified, then any account may\n       * purchase `asset_id` fungible asset Id to receive as payment for the NFT\n       * `fixed_price` ask price\n       * `duration` listing duration time in blocks from now\n       * Caller must be the token owner\n       **/\n      sellNft: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], buyer: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, paymentAsset: u32 | AnyNumber | Uint8Array, fixedPrice: u128 | AnyNumber | Uint8Array, duration: Option<u32> | null | Uint8Array | u32 | AnyNumber, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, Option<SeedPrimitivesSignatureAccountId20>, u32, u128, Option<u32>, Option<u32>]>;\n      /**\n       * Update fixed price for a single token sale\n       * \n       * `listing_id` id of the fixed price listing\n       * `new_price` new fixed price\n       * Caller must be the token owner\n       **/\n      updateFixedPrice: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array, newPrice: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, u128]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    nft: {\n      /**\n       * Accepts an offer on a token\n       * Caller must be token owner\n       **/\n      acceptOffer: AugmentedSubmittable<(offerId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Auction a bundle of tokens on the open market to the highest bidder\n       * - Tokens must be from the same collection\n       * - Tokens with individual royalties schedules cannot be sold in bundles\n       * \n       * Caller must be the token owner\n       * - `payment_asset` fungible asset Id to receive payment with\n       * - `reserve_price` winning bid must be over this threshold\n       * - `duration` length of the auction (in blocks), uses default duration if unspecified\n       **/\n      auction: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], paymentAsset: u32 | AnyNumber | Uint8Array, reservePrice: u128 | AnyNumber | Uint8Array, duration: Option<u32> | null | Uint8Array | u32 | AnyNumber, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, u32, u128, Option<u32>, Option<u32>]>;\n      /**\n       * Place a bid on an open auction\n       * - `amount` to bid (in the seller's requested payment asset)\n       **/\n      bid: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, u128]>;\n      /**\n       * Burn a token \n       * \n       * Caller must be the token owner\n       **/\n      burn: AugmentedSubmittable<(tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => SubmittableExtrinsic<ApiType>, [ITuple<[u32, u32]>]>;\n      /**\n       * Buy a token listing for its specified price\n       **/\n      buy: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Cancels an offer on a token\n       * Caller must be the offer buyer\n       **/\n      cancelOffer: AugmentedSubmittable<(offerId: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Close a sale or auction returning tokens\n       * Requires no successful bids have been made for an auction.\n       * Caller must be the listed seller\n       **/\n      cancelSale: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Bridged collections from Ethereum will initially lack an owner. These collections will\n       * be assigned to the pallet. This allows for claiming those collections assuming they were\n       * assigned to the pallet\n       **/\n      claimUnownedCollection: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, newOwner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Create a new collection\n       * Additional tokens can be minted via `mint_additional`\n       * \n       * `name` - the name of the collection\n       * `initial_issuance` - number of tokens to mint now\n       * `max_issuance` - maximum number of tokens allowed in collection\n       * `token_owner` - the token owner, defaults to the caller\n       * `metadata_scheme` - The off-chain metadata referencing scheme for tokens in this\n       * `royalties_schedule` - defacto royalties plan for secondary sales, this will\n       * apply to all tokens in the collection by default.\n       **/\n      createCollection: AugmentedSubmittable<(name: Bytes | string | Uint8Array, initialIssuance: u32 | AnyNumber | Uint8Array, maxIssuance: Option<u32> | null | Uint8Array | u32 | AnyNumber, tokenOwner: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, metadataScheme: Bytes | string | Uint8Array, royaltiesSchedule: Option<PalletNftRoyaltiesSchedule> | null | Uint8Array | PalletNftRoyaltiesSchedule | { entitlements?: any } | string, crossChainCompatibility: PalletNftCrossChainCompatibility | { xrpl?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, u32, Option<u32>, Option<SeedPrimitivesSignatureAccountId20>, Bytes, Option<PalletNftRoyaltiesSchedule>, PalletNftCrossChainCompatibility]>;\n      /**\n       * Create an offer on a token\n       * Locks funds until offer is accepted, rejected or cancelled\n       * An offer can't be made on a token currently in an auction\n       * (This follows the behaviour of Opensea and forces the buyer to bid rather than create an\n       * offer)\n       **/\n      makeSimpleOffer: AugmentedSubmittable<(tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], amount: u128 | AnyNumber | Uint8Array, assetId: u32 | AnyNumber | Uint8Array, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [ITuple<[u32, u32]>, u128, u32, Option<u32>]>;\n      /**\n       * Mint tokens for an existing collection\n       * \n       * `collection_id` - the collection to mint tokens in\n       * `quantity` - how many tokens to mint\n       * `token_owner` - the token owner, defaults to the caller if unspecified\n       * Caller must be the collection owner\n       * -----------\n       * Weight is O(N) where N is `quantity`\n       **/\n      mint: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, quantity: u32 | AnyNumber | Uint8Array, tokenOwner: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string) => SubmittableExtrinsic<ApiType>, [u32, u32, Option<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * Flag an account as a marketplace\n       * \n       * `marketplace_account` - if specified, this account will be registered\n       * `entitlement` - Permill, percentage of sales to go to the marketplace\n       * If no marketplace is specified the caller will be registered\n       **/\n      registerMarketplace: AugmentedSubmittable<(marketplaceAccount: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, entitlement: Permill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Option<SeedPrimitivesSignatureAccountId20>, Permill]>;\n      /**\n       * Sell a bundle of tokens at a fixed price\n       * - Tokens must be from the same collection\n       * - Tokens with individual royalties schedules cannot be sold with this method\n       * \n       * `buyer` optionally, the account to receive the NFT. If unspecified, then any account may\n       * purchase `asset_id` fungible asset Id to receive as payment for the NFT\n       * `fixed_price` ask price\n       * `duration` listing duration time in blocks from now\n       * Caller must be the token owner\n       **/\n      sell: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], buyer: Option<SeedPrimitivesSignatureAccountId20> | null | Uint8Array | SeedPrimitivesSignatureAccountId20 | string, paymentAsset: u32 | AnyNumber | Uint8Array, fixedPrice: u128 | AnyNumber | Uint8Array, duration: Option<u32> | null | Uint8Array | u32 | AnyNumber, marketplaceId: Option<u32> | null | Uint8Array | u32 | AnyNumber) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, Option<SeedPrimitivesSignatureAccountId20>, u32, u128, Option<u32>, Option<u32>]>;\n      /**\n       * Set the base URI of a collection\n       * Caller must be the current collection owner\n       **/\n      setBaseUri: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, baseUri: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, Bytes]>;\n      /**\n       * Set the max issuance of a collection\n       * Caller must be the current collection owner\n       **/\n      setMaxIssuance: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, maxIssuance: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Set the owner of a collection\n       * Caller must be the current collection owner\n       **/\n      setOwner: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, newOwner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Transfer ownership of an NFT\n       * Caller must be the token owner\n       **/\n      transfer: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], newOwner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Update fixed price for a single token sale\n       * \n       * `listing_id` id of the fixed price listing\n       * `new_price` new fixed price\n       * Caller must be the token owner\n       **/\n      updateFixedPrice: AugmentedSubmittable<(listingId: u128 | AnyNumber | Uint8Array, newPrice: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, u128]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    nftPeg: {\n      setContractAddress: AugmentedSubmittable<(contract: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      withdraw: AugmentedSubmittable<(collectionIds: Vec<u32> | (u32 | AnyNumber | Uint8Array)[], serialNumbers: Vec<Vec<u32>>, destination: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<u32>, Vec<Vec<u32>>, H160]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    proxy: {\n      /**\n       * Register a proxy account for the sender that is able to make calls on its behalf.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `proxy`: The account that the `caller` would like to make a proxy.\n       * - `proxy_type`: The permissions allowed for this proxy account.\n       * - `delay`: The announcement period required of the initial proxy. Will generally be\n       * zero.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      addProxy: AugmentedSubmittable<(delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array, delay: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, u32]>;\n      /**\n       * Publish the hash of a proxy-call that will be made in the future.\n       * \n       * This must be called some number of blocks before the corresponding `proxy` is attempted\n       * if the delay associated with the proxy relationship is greater than zero.\n       * \n       * No more than `MaxPending` announcements may be made at any one time.\n       * \n       * This will take a deposit of `AnnouncementDepositFactor` as well as\n       * `AnnouncementDepositBase` if there are no other pending announcements.\n       * \n       * The dispatch origin for this call must be _Signed_ and a proxy of `real`.\n       * \n       * Parameters:\n       * - `real`: The account that the proxy will make a call on behalf of.\n       * - `call_hash`: The hash of the call to be made by the `real` account.\n       * \n       * # <weight>\n       * Weight is a function of:\n       * - A: the number of announcements made.\n       * - P: the number of proxies the user has.\n       * # </weight>\n       **/\n      announce: AugmentedSubmittable<(real: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, callHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, H256]>;\n      /**\n       * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and\n       * initialize it with a proxy of `proxy_type` for `origin` sender.\n       * \n       * Requires a `Signed` origin.\n       * \n       * - `proxy_type`: The type of the proxy that the sender will be registered as over the\n       * new account. This will almost always be the most permissive `ProxyType` possible to\n       * allow for maximum flexibility.\n       * - `index`: A disambiguation index, in case this is called multiple times in the same\n       * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just\n       * want to use `0`.\n       * - `delay`: The announcement period required of the initial proxy. Will generally be\n       * zero.\n       * \n       * Fails with `Duplicate` if this has already been called in this transaction, from the\n       * same sender, with the same parameters.\n       * \n       * Fails if there are insufficient funds to pay for deposit.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       * TODO: Might be over counting 1 read\n       **/\n      anonymous: AugmentedSubmittable<(proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array, delay: u32 | AnyNumber | Uint8Array, index: u16 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedRuntimeImplsProxyType, u32, u16]>;\n      /**\n       * Removes a previously spawned anonymous proxy.\n       * \n       * WARNING: **All access to this account will be lost.** Any funds held in it will be\n       * inaccessible.\n       * \n       * Requires a `Signed` origin, and the sender account must have been created by a call to\n       * `anonymous` with corresponding parameters.\n       * \n       * - `spawner`: The account that originally called `anonymous` to create this account.\n       * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.\n       * - `proxy_type`: The proxy type originally passed to `anonymous`.\n       * - `height`: The height of the chain when the call to `anonymous` was processed.\n       * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.\n       * \n       * Fails with `NoPermission` in case the caller is not a previously created anonymous\n       * account whose `anonymous` call has corresponding parameters.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      killAnonymous: AugmentedSubmittable<(spawner: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array, index: u16 | AnyNumber | Uint8Array, height: Compact<u32> | AnyNumber | Uint8Array, extIndex: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, u16, Compact<u32>, Compact<u32>]>;\n      /**\n       * Dispatch the given `call` from an account that the sender is authorised for through\n       * `add_proxy`.\n       * \n       * Removes any corresponding announcement(s).\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `real`: The account that the proxy will make a call on behalf of.\n       * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.\n       * - `call`: The call to be made by the `real` account.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      proxy: AugmentedSubmittable<(real: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, forceProxyType: Option<SeedRuntimeImplsProxyType> | null | Uint8Array | SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Option<SeedRuntimeImplsProxyType>, Call]>;\n      /**\n       * Dispatch the given `call` from an account that the sender is authorized for through\n       * `add_proxy`.\n       * \n       * Removes any corresponding announcement(s).\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `real`: The account that the proxy will make a call on behalf of.\n       * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.\n       * - `call`: The call to be made by the `real` account.\n       * \n       * # <weight>\n       * Weight is a function of:\n       * - A: the number of announcements made.\n       * - P: the number of proxies the user has.\n       * # </weight>\n       **/\n      proxyAnnounced: AugmentedSubmittable<(delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, real: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, forceProxyType: Option<SeedRuntimeImplsProxyType> | null | Uint8Array | SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, Option<SeedRuntimeImplsProxyType>, Call]>;\n      /**\n       * Remove the given announcement of a delegate.\n       * \n       * May be called by a target (proxied) account to remove a call that one of their delegates\n       * (`delegate`) has announced they want to execute. The deposit is returned.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `delegate`: The account that previously announced the call.\n       * - `call_hash`: The hash of the call to be made.\n       * \n       * # <weight>\n       * Weight is a function of:\n       * - A: the number of announcements made.\n       * - P: the number of proxies the user has.\n       * # </weight>\n       **/\n      rejectAnnouncement: AugmentedSubmittable<(delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, callHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, H256]>;\n      /**\n       * Remove a given announcement.\n       * \n       * May be called by a proxy account to remove a call they previously announced and return\n       * the deposit.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `real`: The account that the proxy will make a call on behalf of.\n       * - `call_hash`: The hash of the call to be made by the `real` account.\n       * \n       * # <weight>\n       * Weight is a function of:\n       * - A: the number of announcements made.\n       * - P: the number of proxies the user has.\n       * # </weight>\n       **/\n      removeAnnouncement: AugmentedSubmittable<(real: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, callHash: H256 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, H256]>;\n      /**\n       * Unregister all proxy accounts for the sender.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * WARNING: This may be called on accounts created by `anonymous`, however if done, then\n       * the unreserved fees will be inaccessible. **All access to this account will be lost.**\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      removeProxies: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Unregister a proxy account for the sender.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `proxy`: The account that the `caller` would like to remove as a proxy.\n       * - `proxy_type`: The permissions currently enabled for the removed proxy account.\n       * \n       * # <weight>\n       * Weight is a function of the number of proxies the user has (P).\n       * # </weight>\n       **/\n      removeProxy: AugmentedSubmittable<(delegate: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, proxyType: SeedRuntimeImplsProxyType | 'NoPermission' | 'Any' | 'NonTransfer' | 'Governance' | 'Staking' | number | Uint8Array, delay: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedRuntimeImplsProxyType, u32]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    recovery: {\n      /**\n       * Send a call through a recovered account.\n       * \n       * The dispatch origin for this call must be _Signed_ and registered to\n       * be able to make calls on behalf of the recovered account.\n       * \n       * Parameters:\n       * - `account`: The recovered account you want to make a call on-behalf-of.\n       * - `call`: The call you want to make with the recovered account.\n       **/\n      asRecovered: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Call]>;\n      /**\n       * Cancel the ability to use `as_recovered` for `account`.\n       * \n       * The dispatch origin for this call must be _Signed_ and registered to\n       * be able to make calls on behalf of the recovered account.\n       * \n       * Parameters:\n       * - `account`: The recovered account you are able to call on-behalf-of.\n       **/\n      cancelRecovered: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Allow a successful rescuer to claim their recovered account.\n       * \n       * The dispatch origin for this call must be _Signed_ and must be a \"rescuer\"\n       * who has successfully completed the account recovery process: collected\n       * `threshold` or more vouches, waited `delay_period` blocks since initiation.\n       * \n       * Parameters:\n       * - `account`: The lost account that you want to claim has been successfully recovered by\n       * you.\n       **/\n      claimRecovery: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * As the controller of a recoverable account, close an active recovery\n       * process for your account.\n       * \n       * Payment: By calling this function, the recoverable account will receive\n       * the recovery deposit `RecoveryDeposit` placed by the rescuer.\n       * \n       * The dispatch origin for this call must be _Signed_ and must be a\n       * recoverable account with an active recovery process for it.\n       * \n       * Parameters:\n       * - `rescuer`: The account trying to rescue this recoverable account.\n       **/\n      closeRecovery: AugmentedSubmittable<(rescuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Create a recovery configuration for your account. This makes your account recoverable.\n       * \n       * Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance\n       * will be reserved for storing the recovery configuration. This deposit is returned\n       * in full when the user calls `remove_recovery`.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `friends`: A list of friends you trust to vouch for recovery attempts. Should be\n       * ordered and contain no duplicate values.\n       * - `threshold`: The number of friends that must vouch for a recovery attempt before the\n       * account can be recovered. Should be less than or equal to the length of the list of\n       * friends.\n       * - `delay_period`: The number of blocks after a recovery attempt is initialized that\n       * needs to pass before the account can be recovered.\n       **/\n      createRecovery: AugmentedSubmittable<(friends: Vec<SeedPrimitivesSignatureAccountId20> | (SeedPrimitivesSignatureAccountId20 | string | Uint8Array)[], threshold: u16 | AnyNumber | Uint8Array, delayPeriod: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesSignatureAccountId20>, u16, u32]>;\n      /**\n       * Initiate the process for recovering a recoverable account.\n       * \n       * Payment: `RecoveryDeposit` balance will be reserved for initiating the\n       * recovery process. This deposit will always be repatriated to the account\n       * trying to be recovered. See `close_recovery`.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * Parameters:\n       * - `account`: The lost account that you want to recover. This account needs to be\n       * recoverable (i.e. have a recovery configuration).\n       **/\n      initiateRecovery: AugmentedSubmittable<(account: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Remove the recovery process for your account. Recovered accounts are still accessible.\n       * \n       * NOTE: The user must make sure to call `close_recovery` on all active\n       * recovery attempts before calling this function else it will fail.\n       * \n       * Payment: By calling this function the recoverable account will unreserve\n       * their recovery configuration deposit.\n       * (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)\n       * \n       * The dispatch origin for this call must be _Signed_ and must be a\n       * recoverable account (i.e. has a recovery configuration).\n       **/\n      removeRecovery: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Allow ROOT to bypass the recovery process and set an a rescuer account\n       * for a lost account directly.\n       * \n       * The dispatch origin for this call must be _ROOT_.\n       * \n       * Parameters:\n       * - `lost`: The \"lost account\" to be recovered.\n       * - `rescuer`: The \"rescuer account\" which can call as the lost account.\n       **/\n      setRecovered: AugmentedSubmittable<(lost: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, rescuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Allow a \"friend\" of a recoverable account to vouch for an active recovery\n       * process for that account.\n       * \n       * The dispatch origin for this call must be _Signed_ and must be a \"friend\"\n       * for the recoverable account.\n       * \n       * Parameters:\n       * - `lost`: The lost account that you want to recover.\n       * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.\n       * \n       * The combination of these two parameters must point to an active recovery\n       * process.\n       **/\n      vouchRecovery: AugmentedSubmittable<(lost: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, rescuer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    scheduler: {\n      /**\n       * Cancel an anonymously scheduled task.\n       **/\n      cancel: AugmentedSubmittable<(when: u32 | AnyNumber | Uint8Array, index: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Cancel a named scheduled task.\n       **/\n      cancelNamed: AugmentedSubmittable<(id: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Anonymously schedule a task.\n       **/\n      schedule: AugmentedSubmittable<(when: u32 | AnyNumber | Uint8Array, maybePeriodic: Option<ITuple<[u32, u32]>> | null | Uint8Array | ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], priority: u8 | AnyNumber | Uint8Array, call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]>;\n      /**\n       * Anonymously schedule a task after a delay.\n       * \n       * # <weight>\n       * Same as [`schedule`].\n       * # </weight>\n       **/\n      scheduleAfter: AugmentedSubmittable<(after: u32 | AnyNumber | Uint8Array, maybePeriodic: Option<ITuple<[u32, u32]>> | null | Uint8Array | ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], priority: u8 | AnyNumber | Uint8Array, call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]>;\n      /**\n       * Schedule a named task.\n       **/\n      scheduleNamed: AugmentedSubmittable<(id: Bytes | string | Uint8Array, when: u32 | AnyNumber | Uint8Array, maybePeriodic: Option<ITuple<[u32, u32]>> | null | Uint8Array | ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], priority: u8 | AnyNumber | Uint8Array, call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]>;\n      /**\n       * Schedule a named task after a delay.\n       * \n       * # <weight>\n       * Same as [`schedule_named`](Self::schedule_named).\n       * # </weight>\n       **/\n      scheduleNamedAfter: AugmentedSubmittable<(id: Bytes | string | Uint8Array, after: u32 | AnyNumber | Uint8Array, maybePeriodic: Option<ITuple<[u32, u32]>> | null | Uint8Array | ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array], priority: u8 | AnyNumber | Uint8Array, call: FrameSupportScheduleMaybeHashed | { Value: any } | { Hash: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, u32, Option<ITuple<[u32, u32]>>, u8, FrameSupportScheduleMaybeHashed]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    session: {\n      /**\n       * Removes any session key(s) of the function caller.\n       * \n       * This doesn't take effect until the next session.\n       * \n       * The dispatch origin of this function must be Signed and the account must be either be\n       * convertible to a validator ID using the chain's typical addressing system (this usually\n       * means being a controller account) or directly convertible into a validator ID (which\n       * usually means being a stash account).\n       * \n       * # <weight>\n       * - Complexity: `O(1)` in number of key types. Actual cost depends on the number of length\n       * of `T::Keys::key_ids()` which is fixed.\n       * - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`\n       * - DbWrites: `NextKeys`, `origin account`\n       * - DbWrites per key id: `KeyOwner`\n       * # </weight>\n       **/\n      purgeKeys: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Sets the session key(s) of the function caller to `keys`.\n       * Allows an account to set its session key prior to becoming a validator.\n       * This doesn't take effect until the next session.\n       * \n       * The dispatch origin of this function must be signed.\n       * \n       * # <weight>\n       * - Complexity: `O(1)`. Actual cost depends on the number of length of\n       * `T::Keys::key_ids()` which is fixed.\n       * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`\n       * - DbWrites: `origin account`, `NextKeys`\n       * - DbReads per key id: `KeyOwner`\n       * - DbWrites per key id: `KeyOwner`\n       * # </weight>\n       **/\n      setKeys: AugmentedSubmittable<(keys: SeedRuntimeSessionKeys | { babe?: any; imOnline?: any; grandpa?: any; ethy?: any } | string | Uint8Array, proof: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedRuntimeSessionKeys, Bytes]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    staking: {\n      /**\n       * Take the origin account as a stash and lock up `value` of its balance. `controller` will\n       * be the account that controls it.\n       * \n       * `value` must be more than the `minimum_balance` specified by `T::Currency`.\n       * \n       * The dispatch origin for this call must be _Signed_ by the stash account.\n       * \n       * Emits `Bonded`.\n       * # <weight>\n       * - Independent of the arguments. Moderate complexity.\n       * - O(1).\n       * - Three extra DB entries.\n       * \n       * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned\n       * unless the `origin` falls below _existential deposit_ and gets removed as dust.\n       * ------------------\n       * # </weight>\n       **/\n      bond: AugmentedSubmittable<(controller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, value: Compact<u128> | AnyNumber | Uint8Array, payee: PalletStakingRewardDestination | { Staked: any } | { Stash: any } | { Controller: any } | { Account: any } | { None: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Compact<u128>, PalletStakingRewardDestination]>;\n      /**\n       * Add some extra amount that have appeared in the stash `free_balance` into the balance up\n       * for staking.\n       * \n       * The dispatch origin for this call must be _Signed_ by the stash, not the controller.\n       * \n       * Use this if there are additional funds in your stash account that you wish to bond.\n       * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose\n       * any limitation on the amount that can be added.\n       * \n       * Emits `Bonded`.\n       * \n       * # <weight>\n       * - Independent of the arguments. Insignificant complexity.\n       * - O(1).\n       * # </weight>\n       **/\n      bondExtra: AugmentedSubmittable<(maxAdditional: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u128>]>;\n      /**\n       * Cancel enactment of a deferred slash.\n       * \n       * Can be called by the `T::SlashCancelOrigin`.\n       * \n       * Parameters: era and indices of the slashes for that era to kill.\n       **/\n      cancelDeferredSlash: AugmentedSubmittable<(era: u32 | AnyNumber | Uint8Array, slashIndices: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>]>;\n      /**\n       * Declare no desire to either validate or nominate.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * # <weight>\n       * - Independent of the arguments. Insignificant complexity.\n       * - Contains one read.\n       * - Writes are limited to the `origin` account key.\n       * # </weight>\n       **/\n      chill: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Declare a `controller` to stop participating as either a validator or nominator.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_, but can be called by anyone.\n       * \n       * If the caller is the same as the controller being targeted, then no further checks are\n       * enforced, and this function behaves just like `chill`.\n       * \n       * If the caller is different than the controller being targeted, the following conditions\n       * must be met:\n       * \n       * * `controller` must belong to a nominator who has become non-decodable,\n       * \n       * Or:\n       * \n       * * A `ChillThreshold` must be set and checked which defines how close to the max\n       * nominators or validators we must reach before users can start chilling one-another.\n       * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine\n       * how close we are to the threshold.\n       * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines\n       * if this is a person that should be chilled because they have not met the threshold\n       * bond required.\n       * \n       * This can be helpful if bond requirements are updated, and we need to remove old users\n       * who do not satisfy these requirements.\n       **/\n      chillOther: AugmentedSubmittable<(controller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Force a validator to have at least the minimum commission. This will not affect a\n       * validator who already has a commission greater than or equal to the minimum. Any account\n       * can call this.\n       **/\n      forceApplyMinCommission: AugmentedSubmittable<(validatorStash: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Force there to be a new era at the end of the next session. After this, it will be\n       * reset to normal (non-forced) behaviour.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # Warning\n       * \n       * The election process starts multiple blocks before the end of the era.\n       * If this is called just before a new era is triggered, the election process may not\n       * have enough blocks to get a result.\n       * \n       * # <weight>\n       * - No arguments.\n       * - Weight: O(1)\n       * - Write ForceEra\n       * # </weight>\n       **/\n      forceNewEra: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Force there to be a new era at the end of sessions indefinitely.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # Warning\n       * \n       * The election process starts multiple blocks before the end of the era.\n       * If this is called just before a new era is triggered, the election process may not\n       * have enough blocks to get a result.\n       **/\n      forceNewEraAlways: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Force there to be no new eras indefinitely.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # Warning\n       * \n       * The election process starts multiple blocks before the end of the era.\n       * Thus the election process may be ongoing when this is called. In this case the\n       * election will continue until the next era is triggered.\n       * \n       * # <weight>\n       * - No arguments.\n       * - Weight: O(1)\n       * - Write: ForceEra\n       * # </weight>\n       **/\n      forceNoEras: AugmentedSubmittable<() => SubmittableExtrinsic<ApiType>, []>;\n      /**\n       * Force a current staker to become completely unstaked, immediately.\n       * \n       * The dispatch origin must be Root.\n       **/\n      forceUnstake: AugmentedSubmittable<(stash: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, u32]>;\n      /**\n       * Increments the ideal number of validators.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # <weight>\n       * Same as [`Self::set_validator_count`].\n       * # </weight>\n       **/\n      increaseValidatorCount: AugmentedSubmittable<(additional: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Remove the given nominations from the calling validator.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * - `who`: A list of nominator stash accounts who are nominating this validator which\n       * should no longer be nominating this validator.\n       * \n       * Note: Making this call only makes sense if you first set the validator preferences to\n       * block any further nominations.\n       **/\n      kick: AugmentedSubmittable<(who: Vec<SeedPrimitivesSignatureAccountId20> | (SeedPrimitivesSignatureAccountId20 | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * Declare the desire to nominate `targets` for the origin controller.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * # <weight>\n       * - The transaction's complexity is proportional to the size of `targets` (N)\n       * which is capped at CompactAssignments::LIMIT (T::MaxNominations).\n       * - Both the reads and writes follow a similar pattern.\n       * # </weight>\n       **/\n      nominate: AugmentedSubmittable<(targets: Vec<SeedPrimitivesSignatureAccountId20> | (SeedPrimitivesSignatureAccountId20 | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * Pay out all the stakers behind a single validator for a single era.\n       * \n       * - `validator_stash` is the stash account of the validator. Their nominators, up to\n       * `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.\n       * - `era` may be any era between `[current_era - history_depth; current_era]`.\n       * \n       * The origin of this call must be _Signed_. Any account can call this function, even if\n       * it is not one of the stakers.\n       * \n       * # <weight>\n       * - Time complexity: at most O(MaxNominatorRewardedPerValidator).\n       * - Contains a limited number of reads and writes.\n       * -----------\n       * N is the Number of payouts for the validator (including the validator)\n       * Weight:\n       * - Reward Destination Staked: O(N)\n       * - Reward Destination Controller (Creating): O(N)\n       * \n       * NOTE: weights are assuming that payouts are made to alive stash account (Staked).\n       * Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.\n       * # </weight>\n       **/\n      payoutStakers: AugmentedSubmittable<(validatorStash: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, era: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, u32]>;\n      /**\n       * Remove all data structures concerning a staker/stash once it is at a state where it can\n       * be considered `dust` in the staking system. The requirements are:\n       * \n       * 1. the `total_balance` of the stash is below existential deposit.\n       * 2. or, the `ledger.total` of the stash is below existential deposit.\n       * \n       * The former can happen in cases like a slash; the latter when a fully unbonded account\n       * is still receiving staking rewards in `RewardDestination::Staked`.\n       * \n       * It can be called by anyone, as long as `stash` meets the above requirements.\n       * \n       * Refunds the transaction fees upon successful execution.\n       **/\n      reapStash: AugmentedSubmittable<(stash: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, u32]>;\n      /**\n       * Rebond a portion of the stash scheduled to be unlocked.\n       * \n       * The dispatch origin must be signed by the controller.\n       * \n       * # <weight>\n       * - Time complexity: O(L), where L is unlocking chunks\n       * - Bounded by `MaxUnlockingChunks`.\n       * - Storage changes: Can't increase storage, only decrease it.\n       * # </weight>\n       **/\n      rebond: AugmentedSubmittable<(value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u128>]>;\n      /**\n       * Scale up the ideal number of validators by a factor.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # <weight>\n       * Same as [`Self::set_validator_count`].\n       * # </weight>\n       **/\n      scaleValidatorCount: AugmentedSubmittable<(factor: Percent | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Percent]>;\n      /**\n       * (Re-)set the controller of a stash.\n       * \n       * Effects will be felt instantly (as soon as this function is completed successfully).\n       * \n       * The dispatch origin for this call must be _Signed_ by the stash, not the controller.\n       * \n       * # <weight>\n       * - Independent of the arguments. Insignificant complexity.\n       * - Contains a limited number of reads.\n       * - Writes are limited to the `origin` account key.\n       * ----------\n       * Weight: O(1)\n       * DB Weight:\n       * - Read: Bonded, Ledger New Controller, Ledger Old Controller\n       * - Write: Bonded, Ledger New Controller, Ledger Old Controller\n       * # </weight>\n       **/\n      setController: AugmentedSubmittable<(controller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Set `HistoryDepth` value. This function will delete any history information\n       * when `HistoryDepth` is reduced.\n       * \n       * Parameters:\n       * - `new_history_depth`: The new history depth you would like to set.\n       * - `era_items_deleted`: The number of items that will be deleted by this dispatch. This\n       * should report all the storage items that will be deleted by clearing old era history.\n       * Needed to report an accurate weight for the dispatch. Trusted by `Root` to report an\n       * accurate number.\n       * \n       * Origin must be root.\n       * \n       * # <weight>\n       * - E: Number of history depths removed, i.e. 10 -> 7 = 3\n       * - Weight: O(E)\n       * - DB Weight:\n       * - Reads: Current Era, History Depth\n       * - Writes: History Depth\n       * - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs\n       * - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake,\n       * ErasStartSessionIndex\n       * # </weight>\n       **/\n      setHistoryDepth: AugmentedSubmittable<(newHistoryDepth: Compact<u32> | AnyNumber | Uint8Array, eraItemsDeleted: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>, Compact<u32>]>;\n      /**\n       * Set the validators who cannot be slashed (if any).\n       * \n       * The dispatch origin must be Root.\n       **/\n      setInvulnerables: AugmentedSubmittable<(invulnerables: Vec<SeedPrimitivesSignatureAccountId20> | (SeedPrimitivesSignatureAccountId20 | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<SeedPrimitivesSignatureAccountId20>]>;\n      /**\n       * (Re-)set the payment target for a controller.\n       * \n       * Effects will be felt instantly (as soon as this function is completed successfully).\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * # <weight>\n       * - Independent of the arguments. Insignificant complexity.\n       * - Contains a limited number of reads.\n       * - Writes are limited to the `origin` account key.\n       * ---------\n       * - Weight: O(1)\n       * - DB Weight:\n       * - Read: Ledger\n       * - Write: Payee\n       * # </weight>\n       **/\n      setPayee: AugmentedSubmittable<(payee: PalletStakingRewardDestination | { Staked: any } | { Stash: any } | { Controller: any } | { Account: any } | { None: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletStakingRewardDestination]>;\n      /**\n       * Update the various staking configurations .\n       * \n       * * `min_nominator_bond`: The minimum active bond needed to be a nominator.\n       * * `min_validator_bond`: The minimum active bond needed to be a validator.\n       * * `max_nominator_count`: The max number of users who can be a nominator at once. When\n       * set to `None`, no limit is enforced.\n       * * `max_validator_count`: The max number of users who can be a validator at once. When\n       * set to `None`, no limit is enforced.\n       * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which\n       * should be filled in order for the `chill_other` transaction to work.\n       * * `min_commission`: The minimum amount of commission that each validators must maintain.\n       * This is checked only upon calling `validate`. Existing validators are not affected.\n       * \n       * Origin must be Root to call this function.\n       * \n       * NOTE: Existing nominators and validators will not be affected by this update.\n       * to kick people under the new limits, `chill_other` should be called.\n       **/\n      setStakingConfigs: AugmentedSubmittable<(minNominatorBond: PalletStakingPalletConfigOpU128 | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, minValidatorBond: PalletStakingPalletConfigOpU128 | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, maxNominatorCount: PalletStakingPalletConfigOpU32 | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, maxValidatorCount: PalletStakingPalletConfigOpU32 | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, chillThreshold: PalletStakingPalletConfigOpPercent | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array, minCommission: PalletStakingPalletConfigOpPerbill | { Noop: any } | { Set: any } | { Remove: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletStakingPalletConfigOpU128, PalletStakingPalletConfigOpU128, PalletStakingPalletConfigOpU32, PalletStakingPalletConfigOpU32, PalletStakingPalletConfigOpPercent, PalletStakingPalletConfigOpPerbill]>;\n      /**\n       * Sets the ideal number of validators.\n       * \n       * The dispatch origin must be Root.\n       * \n       * # <weight>\n       * Weight: O(1)\n       * Write: Validator Count\n       * # </weight>\n       **/\n      setValidatorCount: AugmentedSubmittable<(updated: Compact<u32> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u32>]>;\n      /**\n       * Schedule a portion of the stash to be unlocked ready for transfer out after the bond\n       * period ends. If this leaves an amount actively bonded less than\n       * T::Currency::minimum_balance(), then it is increased to the full amount.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       * \n       * Once the unlock period is done, you can call `withdraw_unbonded` to actually move\n       * the funds out of management ready for transfer.\n       * \n       * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)\n       * can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need\n       * to be called first to remove some of the chunks (if possible).\n       * \n       * If a user encounters the `InsufficientBond` error when calling this extrinsic,\n       * they should call `chill` first in order to free up their bonded funds.\n       * \n       * Emits `Unbonded`.\n       * \n       * See also [`Call::withdraw_unbonded`].\n       **/\n      unbond: AugmentedSubmittable<(value: Compact<u128> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u128>]>;\n      /**\n       * Declare the desire to validate for the origin controller.\n       * \n       * Effects will be felt at the beginning of the next era.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller, not the stash.\n       **/\n      validate: AugmentedSubmittable<(prefs: PalletStakingValidatorPrefs | { commission?: any; blocked?: any } | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [PalletStakingValidatorPrefs]>;\n      /**\n       * Remove any unlocked chunks from the `unlocking` queue from our management.\n       * \n       * This essentially frees up that balance to be used by the stash account to do\n       * whatever it wants.\n       * \n       * The dispatch origin for this call must be _Signed_ by the controller.\n       * \n       * Emits `Withdrawn`.\n       * \n       * See also [`Call::unbond`].\n       * \n       * # <weight>\n       * Complexity O(S) where S is the number of slashing spans to remove\n       * NOTE: Weight annotation is the kill scenario, we refund otherwise.\n       * # </weight>\n       **/\n      withdrawUnbonded: AugmentedSubmittable<(numSlashingSpans: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    sudo: {\n      /**\n       * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo\n       * key.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * # <weight>\n       * - O(1).\n       * - Limited storage reads.\n       * - One DB change.\n       * # </weight>\n       **/\n      setKey: AugmentedSubmittable<(updated: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Authenticates the sudo key and dispatches a function call with `Root` origin.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * # <weight>\n       * - O(1).\n       * - Limited storage reads.\n       * - One DB write (event).\n       * - Weight of derivative `call` execution + 10,000.\n       * # </weight>\n       **/\n      sudo: AugmentedSubmittable<(call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Call]>;\n      /**\n       * Authenticates the sudo key and dispatches a function call with `Signed` origin from\n       * a given account.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * # <weight>\n       * - O(1).\n       * - Limited storage reads.\n       * - One DB write (event).\n       * - Weight of derivative `call` execution + 10,000.\n       * # </weight>\n       **/\n      sudoAs: AugmentedSubmittable<(who: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, Call]>;\n      /**\n       * Authenticates the sudo key and dispatches a function call with `Root` origin.\n       * This function does not check the weight of the call, and instead allows the\n       * Sudo user to specify the weight of the call.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       * \n       * # <weight>\n       * - O(1).\n       * - The weight of this call is defined by the caller.\n       * # </weight>\n       **/\n      sudoUncheckedWeight: AugmentedSubmittable<(call: Call | IMethod | string | Uint8Array, weight: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Call, u64]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    system: {\n      /**\n       * A dispatch that will fill the block weight up to the given ratio.\n       **/\n      fillBlock: AugmentedSubmittable<(ratio: Perbill | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Perbill]>;\n      /**\n       * Kill all storage items with a key that starts with the given prefix.\n       * \n       * **NOTE:** We rely on the Root origin to provide us the number of subkeys under\n       * the prefix we are removing to accurately calculate the weight of this function.\n       **/\n      killPrefix: AugmentedSubmittable<(prefix: Bytes | string | Uint8Array, subkeys: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes, u32]>;\n      /**\n       * Kill some items from storage.\n       **/\n      killStorage: AugmentedSubmittable<(keys: Vec<Bytes> | (Bytes | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Bytes>]>;\n      /**\n       * Make some on-chain remark.\n       * \n       * # <weight>\n       * - `O(1)`\n       * # </weight>\n       **/\n      remark: AugmentedSubmittable<(remark: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Make some on-chain remark and emit event.\n       **/\n      remarkWithEvent: AugmentedSubmittable<(remark: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Set the new runtime code.\n       * \n       * # <weight>\n       * - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`\n       * - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is\n       * expensive).\n       * - 1 storage write (codec `O(C)`).\n       * - 1 digest item.\n       * - 1 event.\n       * The weight of this function is dependent on the runtime, but generally this is very\n       * expensive. We will treat this as a full block.\n       * # </weight>\n       **/\n      setCode: AugmentedSubmittable<(code: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Set the new runtime code without doing any checks of the given `code`.\n       * \n       * # <weight>\n       * - `O(C)` where `C` length of `code`\n       * - 1 storage write (codec `O(C)`).\n       * - 1 digest item.\n       * - 1 event.\n       * The weight of this function is dependent on the runtime. We will treat this as a full\n       * block. # </weight>\n       **/\n      setCodeWithoutChecks: AugmentedSubmittable<(code: Bytes | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [Bytes]>;\n      /**\n       * Set the number of pages in the WebAssembly environment's heap.\n       **/\n      setHeapPages: AugmentedSubmittable<(pages: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Set some items of storage.\n       **/\n      setStorage: AugmentedSubmittable<(items: Vec<ITuple<[Bytes, Bytes]>> | ([Bytes | string | Uint8Array, Bytes | string | Uint8Array])[]) => SubmittableExtrinsic<ApiType>, [Vec<ITuple<[Bytes, Bytes]>>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    timestamp: {\n      /**\n       * Set the current time.\n       * \n       * This call should be invoked exactly once per block. It will panic at the finalization\n       * phase, if this call hasn't been invoked by that time.\n       * \n       * The timestamp should be greater than the previous one by the amount specified by\n       * `MinimumPeriod`.\n       * \n       * The dispatch origin for this call must be `Inherent`.\n       * \n       * # <weight>\n       * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)\n       * - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in\n       * `on_finalize`)\n       * - 1 event handler `on_timestamp_set`. Must be `O(1)`.\n       * # </weight>\n       **/\n      set: AugmentedSubmittable<(now: Compact<u64> | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [Compact<u64>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    tokenApprovals: {\n      /**\n       * Set approval for an account to transfer an amount of tokens on behalf of the caller\n       * Mapping from caller to spender and amount\n       * mapping(address => mapping(address => uint256)) private _allowances;\n       **/\n      erc20Approval: AugmentedSubmittable<(caller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, spender: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, assetId: u32 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, u32, u128]>;\n      /**\n       * Removes an approval over an account and asset_id\n       * mapping(address => mapping(address => uint256)) private _allowances;\n       **/\n      erc20UpdateApproval: AugmentedSubmittable<(caller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, spender: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, assetId: u32 | AnyNumber | Uint8Array, amount: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, u32, u128]>;\n      /**\n       * Set approval for a single NFT\n       * Mapping from token_id to operator\n       * clears approval on transfer\n       * mapping(uint256 => address) private _tokenApprovals;\n       **/\n      erc721Approval: AugmentedSubmittable<(caller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, operatorAccount: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, ITuple<[u32, u32]>]>;\n      /**\n       * Set approval for an account (or contract) to transfer any tokens from a collection\n       * mapping(address => mapping(address => bool)) private _operatorApprovals;\n       **/\n      erc721ApprovalForAll: AugmentedSubmittable<(caller: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, operatorAccount: SeedPrimitivesSignatureAccountId20 | string | Uint8Array, collectionUuid: u32 | AnyNumber | Uint8Array, approved: bool | boolean | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20, SeedPrimitivesSignatureAccountId20, u32, bool]>;\n      /**\n       * Public method which allows users to remove approvals on a token they own\n       **/\n      erc721RemoveApproval: AugmentedSubmittable<(tokenId: ITuple<[u32, u32]> | [u32 | AnyNumber | Uint8Array, u32 | AnyNumber | Uint8Array]) => SubmittableExtrinsic<ApiType>, [ITuple<[u32, u32]>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    utility: {\n      /**\n       * Send a call through an indexed pseudonym of the sender.\n       * \n       * Filter from origin are passed along. The call will be dispatched with an origin which\n       * use the same filter as the origin of this call.\n       * \n       * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.\n       * because you expect `proxy` to have been used prior in the call stack and you do not want\n       * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`\n       * in the Multisig pallet instead.\n       * \n       * NOTE: Prior to version *12, this was called `as_limited_sub`.\n       * \n       * The dispatch origin for this call must be _Signed_.\n       **/\n      asDerivative: AugmentedSubmittable<(index: u16 | AnyNumber | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u16, Call]>;\n      /**\n       * Send a batch of dispatch calls.\n       * \n       * May be called from any origin.\n       * \n       * - `calls`: The calls to be dispatched from the same origin. The number of call must not\n       * exceed the constant: `batched_calls_limit` (available in constant metadata).\n       * \n       * If origin is root then call are dispatch without checking origin filter. (This includes\n       * bypassing `frame_system::Config::BaseCallFilter`).\n       * \n       * # <weight>\n       * - Complexity: O(C) where C is the number of calls to be batched.\n       * # </weight>\n       * \n       * This will return `Ok` in all circumstances. To determine the success of the batch, an\n       * event is deposited. If a call failed and the batch was interrupted, then the\n       * `BatchInterrupted` event is deposited, along with the number of successful calls made\n       * and the error of the failed call. If all were successful, then the `BatchCompleted`\n       * event is deposited.\n       **/\n      batch: AugmentedSubmittable<(calls: Vec<Call> | (Call | IMethod | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Call>]>;\n      /**\n       * Send a batch of dispatch calls and atomically execute them.\n       * The whole transaction will rollback and fail if any of the calls failed.\n       * \n       * May be called from any origin.\n       * \n       * - `calls`: The calls to be dispatched from the same origin. The number of call must not\n       * exceed the constant: `batched_calls_limit` (available in constant metadata).\n       * \n       * If origin is root then call are dispatch without checking origin filter. (This includes\n       * bypassing `frame_system::Config::BaseCallFilter`).\n       * \n       * # <weight>\n       * - Complexity: O(C) where C is the number of calls to be batched.\n       * # </weight>\n       **/\n      batchAll: AugmentedSubmittable<(calls: Vec<Call> | (Call | IMethod | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Call>]>;\n      /**\n       * Dispatches a function call with a provided origin.\n       * \n       * The dispatch origin for this call must be _Root_.\n       * \n       * # <weight>\n       * - O(1).\n       * - Limited storage reads.\n       * - One DB write (event).\n       * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().\n       * # </weight>\n       **/\n      dispatchAs: AugmentedSubmittable<(asOrigin: SeedRuntimeOriginCaller | { system: any } | { Void: any } | { Ethereum: any } | string | Uint8Array, call: Call | IMethod | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedRuntimeOriginCaller, Call]>;\n      /**\n       * Send a batch of dispatch calls.\n       * Unlike `batch`, it allows errors and won't interrupt.\n       * \n       * May be called from any origin.\n       * \n       * - `calls`: The calls to be dispatched from the same origin. The number of call must not\n       * exceed the constant: `batched_calls_limit` (available in constant metadata).\n       * \n       * If origin is root then call are dispatch without checking origin filter. (This includes\n       * bypassing `frame_system::Config::BaseCallFilter`).\n       * \n       * # <weight>\n       * - Complexity: O(C) where C is the number of calls to be batched.\n       * # </weight>\n       **/\n      forceBatch: AugmentedSubmittable<(calls: Vec<Call> | (Call | IMethod | string | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [Vec<Call>]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    voterList: {\n      /**\n       * Move the caller's Id directly in front of `lighter`.\n       * \n       * The dispatch origin for this call must be _Signed_ and can only be called by the Id of\n       * the account going in front of `lighter`.\n       * \n       * Only works if\n       * - both nodes are within the same bag,\n       * - and `origin` has a greater `Score` than `lighter`.\n       **/\n      putInFrontOf: AugmentedSubmittable<(lighter: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Declare that some `dislocated` account has, through rewards or penalties, sufficiently\n       * changed its score that it should properly fall into a different bag than its current\n       * one.\n       * \n       * Anyone can call this function about any potentially dislocated account.\n       * \n       * Will always update the stored score of `dislocated` to the correct score, based on\n       * `ScoreProvider`.\n       * \n       * If `dislocated` does not exists, it returns an error.\n       **/\n      rebag: AugmentedSubmittable<(dislocated: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    xls20: {\n      /**\n       * Enables XLS-20 compatibility on a collection\n       * - Collection must not have any tokens minted\n       * - Caller must be collection owner\n       **/\n      enableXls20Compatibility: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32]>;\n      /**\n       * Submit XLS-20 token ids to The Root Network\n       * Only callable by the trusted relayer account\n       * Can apply multiple mappings from the same collection in one transaction\n       **/\n      fulfillXls20Mint: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, tokenMappings: Vec<ITuple<[u32, U8aFixed]>> | ([u32 | AnyNumber | Uint8Array, U8aFixed | string | Uint8Array])[]) => SubmittableExtrinsic<ApiType>, [u32, Vec<ITuple<[u32, U8aFixed]>>]>;\n      reRequestXls20Mint: AugmentedSubmittable<(collectionId: u32 | AnyNumber | Uint8Array, serialNumbers: Vec<u32> | (u32 | AnyNumber | Uint8Array)[]) => SubmittableExtrinsic<ApiType>, [u32, Vec<u32>]>;\n      /**\n       * Set the relayer address\n       **/\n      setRelayer: AugmentedSubmittable<(relayer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Set the xls20 mint fee which is paid per token by the collection owner\n       * This covers the additional costs incurred by the relayer for the following:\n       * - Minting the token on XRPL\n       * - Calling fulfill_xls20_mint on The Root Network\n       **/\n      setXls20Fee: AugmentedSubmittable<(newFee: u128 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n    xrplBridge: {\n      /**\n       * add a relayer\n       **/\n      addRelayer: AugmentedSubmittable<(relayer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * remove a relayer\n       **/\n      removeRelayer: AugmentedSubmittable<(relayer: SeedPrimitivesSignatureAccountId20 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [SeedPrimitivesSignatureAccountId20]>;\n      /**\n       * Set XRPL door address managed by this pallet\n       **/\n      setDoorAddress: AugmentedSubmittable<(doorAddress: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H160]>;\n      /**\n       * Set the door tx fee amount\n       **/\n      setDoorTxFee: AugmentedSubmittable<(fee: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64]>;\n      /**\n       * Set the door account current ticket sequence params for current allocation - force set\n       **/\n      setTicketSequenceCurrentAllocation: AugmentedSubmittable<(ticketSequence: u32 | AnyNumber | Uint8Array, startTicketSequence: u32 | AnyNumber | Uint8Array, ticketBucketSize: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32, u32]>;\n      /**\n       * Set the door account ticket sequence params for the next allocation\n       **/\n      setTicketSequenceNextAllocation: AugmentedSubmittable<(startTicketSequence: u32 | AnyNumber | Uint8Array, ticketBucketSize: u32 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u32, u32]>;\n      /**\n       * Submit xrp transaction challenge\n       **/\n      submitChallenge: AugmentedSubmittable<(transactionHash: H512 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [H512]>;\n      /**\n       * Submit xrp transaction\n       **/\n      submitTransaction: AugmentedSubmittable<(ledgerIndex: u64 | AnyNumber | Uint8Array, transactionHash: H512 | string | Uint8Array, transaction: PalletXrplBridgeHelpersXrplTxData | { Payment: any } | { CurrencyPayment: any } | { Xls20: any } | string | Uint8Array, timestamp: u64 | AnyNumber | Uint8Array) => SubmittableExtrinsic<ApiType>, [u64, H512, PalletXrplBridgeHelpersXrplTxData, u64]>;\n      /**\n       * Withdraw xrp transaction\n       **/\n      withdrawXrp: AugmentedSubmittable<(amount: u128 | AnyNumber | Uint8Array, destination: H160 | string | Uint8Array) => SubmittableExtrinsic<ApiType>, [u128, H160]>;\n      /**\n       * Generic tx\n       **/\n      [key: string]: SubmittableExtrinsicFunction<ApiType>;\n    };\n  } // AugmentedSubmittables\n} // declare module\n"],"version":3}