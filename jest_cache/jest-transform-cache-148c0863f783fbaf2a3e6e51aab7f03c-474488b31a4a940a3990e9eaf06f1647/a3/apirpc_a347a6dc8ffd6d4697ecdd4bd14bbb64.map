{"file":"/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-rpc.ts","mappings":";AAAA,mEAAmE;AACnE,oBAAoB;;AAEpB,8DAA8D;AAC9D,6DAA6D;AAC7D,4CAA0C","names":[],"sources":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/types/src/augment/api-rpc.ts"],"sourcesContent":["// Auto-generated via `yarn polkadot-types-from-chain`, do not edit\n/* eslint-disable */\n\n// import type lookup before we augment - in some environments\n// this is required to allow for ambient/previous definitions\nimport '@polkadot/rpc-core/types/jsonrpc';\n\nimport type { AugmentedRpc } from '@polkadot/rpc-core/types';\nimport type { Metadata, StorageKey } from '@polkadot/types';\nimport type { Bytes, HashMap, Json, Null, Option, Text, U256, U64, Vec, bool, f64, u128, u16, u32, u64 } from '@polkadot/types-codec';\nimport type { AnyNumber, Codec } from '@polkadot/types-codec/types';\nimport type { ExtrinsicOrHash, ExtrinsicStatus } from '@polkadot/types/interfaces/author';\nimport type { EpochAuthorship } from '@polkadot/types/interfaces/babe';\nimport type { BeefySignedCommitment } from '@polkadot/types/interfaces/beefy';\nimport type { BlockHash } from '@polkadot/types/interfaces/chain';\nimport type { PrefixedStorageKey } from '@polkadot/types/interfaces/childstate';\nimport type { AuthorityId } from '@polkadot/types/interfaces/consensus';\nimport type { CodeUploadRequest, CodeUploadResult, ContractCallRequest, ContractExecResult, ContractInstantiateResult, InstantiateRequestV1 } from '@polkadot/types/interfaces/contracts';\nimport type { BlockStats } from '@polkadot/types/interfaces/dev';\nimport type { CreatedBlock } from '@polkadot/types/interfaces/engine';\nimport type { EthAccount, EthCallRequest, EthFeeHistory, EthFilter, EthFilterChanges, EthLog, EthReceipt, EthRichBlock, EthSubKind, EthSubParams, EthSyncStatus, EthTransaction, EthTransactionRequest, EthWork } from '@polkadot/types/interfaces/eth';\nimport type { Extrinsic } from '@polkadot/types/interfaces/extrinsics';\nimport type { EncodedFinalityProofs, JustificationNotification, ReportedRoundStates } from '@polkadot/types/interfaces/grandpa';\nimport type { MmrHash, MmrLeafBatchProof } from '@polkadot/types/interfaces/mmr';\nimport type { StorageKind } from '@polkadot/types/interfaces/offchain';\nimport type { FeeDetails, RuntimeDispatchInfoV1 } from '@polkadot/types/interfaces/payment';\nimport type { RpcMethods } from '@polkadot/types/interfaces/rpc';\nimport type { MigrationStatusResult, ReadProof, RuntimeVersion, TraceBlockResponse } from '@polkadot/types/interfaces/state';\nimport type { ApplyExtrinsicResult, ChainProperties, ChainType, Health, NetworkState, NodeRole, PeerInfo, SyncState } from '@polkadot/types/interfaces/system';\nimport type { IExtrinsic, Observable } from '@polkadot/types/types';\nimport type { EthEventProofResponse, EventProofId } from '@therootnetwork/types/interfaces/ethy';\nimport type { CollectionUuid, SerialNumber, TokenId } from '@therootnetwork/types/interfaces/nft';\nimport type { AccountId, AssetId, Balance, BlockNumber, H160, H256, H64, Hash, Header, Index, Justification, KeyValue, SignedBlock, StorageData } from '@therootnetwork/types/interfaces/runtime';\nimport type { XrplEventProofResponse } from '@therootnetwork/types/interfaces/xrplBridge';\n\nexport type __AugmentedRpc = AugmentedRpc<() => unknown>;\n\ndeclare module '@polkadot/rpc-core/types/jsonrpc' {\n  interface RpcInterface {\n    author: {\n      /**\n       * Returns true if the keystore has private keys for the given public key and key type.\n       **/\n      hasKey: AugmentedRpc<(publicKey: Bytes | string | Uint8Array, keyType: Text | string) => Observable<bool>>;\n      /**\n       * Returns true if the keystore has private keys for the given session public keys.\n       **/\n      hasSessionKeys: AugmentedRpc<(sessionKeys: Bytes | string | Uint8Array) => Observable<bool>>;\n      /**\n       * Insert a key into the keystore.\n       **/\n      insertKey: AugmentedRpc<(keyType: Text | string, suri: Text | string, publicKey: Bytes | string | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Returns all pending extrinsics, potentially grouped by sender\n       **/\n      pendingExtrinsics: AugmentedRpc<() => Observable<Vec<Extrinsic>>>;\n      /**\n       * Remove given extrinsic from the pool and temporarily ban it to prevent reimporting\n       **/\n      removeExtrinsic: AugmentedRpc<(bytesOrHash: Vec<ExtrinsicOrHash> | (ExtrinsicOrHash | { Hash: any } | { Extrinsic: any } | string | Uint8Array)[]) => Observable<Vec<Hash>>>;\n      /**\n       * Generate new session keys and returns the corresponding public keys\n       **/\n      rotateKeys: AugmentedRpc<() => Observable<Bytes>>;\n      /**\n       * Submit and subscribe to watch an extrinsic until unsubscribed\n       **/\n      submitAndWatchExtrinsic: AugmentedRpc<(extrinsic: Extrinsic | IExtrinsic | string | Uint8Array) => Observable<ExtrinsicStatus>>;\n      /**\n       * Submit a fully formatted extrinsic for block inclusion\n       **/\n      submitExtrinsic: AugmentedRpc<(extrinsic: Extrinsic | IExtrinsic | string | Uint8Array) => Observable<Hash>>;\n    };\n    babe: {\n      /**\n       * Returns data about which slots (primary or secondary) can be claimed in the current epoch with the keys in the keystore\n       **/\n      epochAuthorship: AugmentedRpc<() => Observable<HashMap<AuthorityId, EpochAuthorship>>>;\n    };\n    beefy: {\n      /**\n       * Returns hash of the latest BEEFY finalized block as seen by this client.\n       **/\n      getFinalizedHead: AugmentedRpc<() => Observable<H256>>;\n      /**\n       * Returns the block most recently finalized by BEEFY, alongside side its justification.\n       **/\n      subscribeJustifications: AugmentedRpc<() => Observable<BeefySignedCommitment>>;\n    };\n    chain: {\n      /**\n       * Get header and body of a relay chain block\n       **/\n      getBlock: AugmentedRpc<(hash?: BlockHash | string | Uint8Array) => Observable<SignedBlock>>;\n      /**\n       * Get the block hash for a specific block\n       **/\n      getBlockHash: AugmentedRpc<(blockNumber?: BlockNumber | AnyNumber | Uint8Array) => Observable<BlockHash>>;\n      /**\n       * Get hash of the last finalized block in the canon chain\n       **/\n      getFinalizedHead: AugmentedRpc<() => Observable<BlockHash>>;\n      /**\n       * Retrieves the header for a specific block\n       **/\n      getHeader: AugmentedRpc<(hash?: BlockHash | string | Uint8Array) => Observable<Header>>;\n      /**\n       * Retrieves the newest header via subscription\n       **/\n      subscribeAllHeads: AugmentedRpc<() => Observable<Header>>;\n      /**\n       * Retrieves the best finalized header via subscription\n       **/\n      subscribeFinalizedHeads: AugmentedRpc<() => Observable<Header>>;\n      /**\n       * Retrieves the best header via subscription\n       **/\n      subscribeNewHeads: AugmentedRpc<() => Observable<Header>>;\n    };\n    childstate: {\n      /**\n       * Returns the keys with prefix from a child storage, leave empty to get all the keys\n       **/\n      getKeys: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, prefix: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns the keys with prefix from a child storage with pagination support\n       **/\n      getKeysPaged: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, prefix: StorageKey | string | Uint8Array | any, count: u32 | AnyNumber | Uint8Array, startKey?: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns a child storage entry at a specific block state\n       **/\n      getStorage: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Option<StorageData>>>;\n      /**\n       * Returns child storage entries for multiple keys at a specific block state\n       **/\n      getStorageEntries: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], at?: Hash | string | Uint8Array) => Observable<Vec<Option<StorageData>>>>;\n      /**\n       * Returns the hash of a child storage entry at a block state\n       **/\n      getStorageHash: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Option<Hash>>>;\n      /**\n       * Returns the size of a child storage entry at a block state\n       **/\n      getStorageSize: AugmentedRpc<(childKey: PrefixedStorageKey | string | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: Hash | string | Uint8Array) => Observable<Option<u64>>>;\n    };\n    contracts: {\n      /**\n       * @deprecated Use the runtime interface `api.call.contractsApi.call` instead\n       * Executes a call to a contract\n       **/\n      call: AugmentedRpc<(callRequest: ContractCallRequest | { origin?: any; dest?: any; value?: any; gasLimit?: any; storageDepositLimit?: any; inputData?: any } | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<ContractExecResult>>;\n      /**\n       * @deprecated Use the runtime interface `api.call.contractsApi.getStorage` instead\n       * Returns the value under a specified storage key in a contract\n       **/\n      getStorage: AugmentedRpc<(address: AccountId | string | Uint8Array, key: H256 | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<Option<Bytes>>>;\n      /**\n       * @deprecated Use the runtime interface `api.call.contractsApi.instantiate` instead\n       * Instantiate a new contract\n       **/\n      instantiate: AugmentedRpc<(request: InstantiateRequestV1 | { origin?: any; value?: any; gasLimit?: any; code?: any; data?: any; salt?: any } | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<ContractInstantiateResult>>;\n      /**\n       * @deprecated Not available in newer versions of the contracts interfaces\n       * Returns the projected time a given contract will be able to sustain paying its rent\n       **/\n      rentProjection: AugmentedRpc<(address: AccountId | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<Option<BlockNumber>>>;\n      /**\n       * @deprecated Use the runtime interface `api.call.contractsApi.uploadCode` instead\n       * Upload new code without instantiating a contract from it\n       **/\n      uploadCode: AugmentedRpc<(uploadRequest: CodeUploadRequest | { origin?: any; code?: any; storageDepositLimit?: any } | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<CodeUploadResult>>;\n    };\n    dev: {\n      /**\n       * Reexecute the specified `block_hash` and gather statistics while doing so\n       **/\n      getBlockStats: AugmentedRpc<(at: Hash | string | Uint8Array) => Observable<Option<BlockStats>>>;\n    };\n    dex: {\n      /**\n       * Given an array of AssetIds, return amounts in for an amount out\n       **/\n      getAmountsIn: AugmentedRpc<(amountOut: Balance | AnyNumber | Uint8Array, path: Vec<AssetId> | (AssetId | AnyNumber | Uint8Array)[]) => Observable<Json>>;\n      /**\n       * Given an array of AssetIds, return amounts out for an amount in\n       **/\n      getAmountsOut: AugmentedRpc<(amountIn: Balance | AnyNumber | Uint8Array, path: Vec<AssetId> | (AssetId | AnyNumber | Uint8Array)[]) => Observable<Json>>;\n      /**\n       * Given two AssetIds, return liquidity token created for the pair\n       **/\n      getLPTokenID: AugmentedRpc<(assetA: AssetId | AnyNumber | Uint8Array, assetB: AssetId | AnyNumber | Uint8Array) => Observable<Json>>;\n      /**\n       * Given two AssetIds, return liquidity\n       **/\n      getLiquidity: AugmentedRpc<(assetA: AssetId | AnyNumber | Uint8Array, assetB: AssetId | AnyNumber | Uint8Array) => Observable<Json>>;\n      /**\n       * Given two AssetIds, return whether trading pair is enabled or disabled\n       **/\n      getTradingPairStatus: AugmentedRpc<(assetA: AssetId | AnyNumber | Uint8Array, assetB: AssetId | AnyNumber | Uint8Array) => Observable<Json>>;\n      /**\n       * Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n       **/\n      quote: AugmentedRpc<(amountA: u128 | AnyNumber | Uint8Array, reserveA: u128 | AnyNumber | Uint8Array, reserveB: u128 | AnyNumber | Uint8Array) => Observable<Json>>;\n    };\n    engine: {\n      /**\n       * Instructs the manual-seal authorship task to create a new block\n       **/\n      createBlock: AugmentedRpc<(createEmpty: bool | boolean | Uint8Array, finalize: bool | boolean | Uint8Array, parentHash?: BlockHash | string | Uint8Array) => Observable<CreatedBlock>>;\n      /**\n       * Instructs the manual-seal authorship task to finalize a block\n       **/\n      finalizeBlock: AugmentedRpc<(hash: BlockHash | string | Uint8Array, justification?: Justification) => Observable<bool>>;\n    };\n    eth: {\n      /**\n       * Returns accounts list.\n       **/\n      accounts: AugmentedRpc<() => Observable<Vec<H160>>>;\n      /**\n       * Returns the blockNumber\n       **/\n      blockNumber: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Call contract, returning the output data.\n       **/\n      call: AugmentedRpc<(request: EthCallRequest | { from?: any; to?: any; gasPrice?: any; gas?: any; value?: any; data?: any; nonce?: any } | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Returns the chain ID used for transaction signing at the current best block. None is returned if not available.\n       **/\n      chainId: AugmentedRpc<() => Observable<U64>>;\n      /**\n       * Returns block author.\n       **/\n      coinbase: AugmentedRpc<() => Observable<H160>>;\n      /**\n       * Estimate gas needed for execution of given contract.\n       **/\n      estimateGas: AugmentedRpc<(request: EthCallRequest | { from?: any; to?: any; gasPrice?: any; gas?: any; value?: any; data?: any; nonce?: any } | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns fee history for given block count & reward percentiles\n       **/\n      feeHistory: AugmentedRpc<(blockCount: U256 | AnyNumber | Uint8Array, newestBlock: BlockNumber | AnyNumber | Uint8Array, rewardPercentiles: Option<Vec<f64>> | null | Uint8Array | Vec<f64> | (f64)[]) => Observable<EthFeeHistory>>;\n      /**\n       * Returns current gas price.\n       **/\n      gasPrice: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns balance of the given account.\n       **/\n      getBalance: AugmentedRpc<(address: H160 | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns block with given hash.\n       **/\n      getBlockByHash: AugmentedRpc<(hash: H256 | string | Uint8Array, full: bool | boolean | Uint8Array) => Observable<Option<EthRichBlock>>>;\n      /**\n       * Returns block with given number.\n       **/\n      getBlockByNumber: AugmentedRpc<(block: BlockNumber | AnyNumber | Uint8Array, full: bool | boolean | Uint8Array) => Observable<Option<EthRichBlock>>>;\n      /**\n       * Returns the number of transactions in a block with given hash.\n       **/\n      getBlockTransactionCountByHash: AugmentedRpc<(hash: H256 | string | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns the number of transactions in a block with given block number.\n       **/\n      getBlockTransactionCountByNumber: AugmentedRpc<(block: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns the code at given address at given time (block number).\n       **/\n      getCode: AugmentedRpc<(address: H160 | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Returns filter changes since last poll.\n       **/\n      getFilterChanges: AugmentedRpc<(index: U256 | AnyNumber | Uint8Array) => Observable<EthFilterChanges>>;\n      /**\n       * Returns all logs matching given filter (in a range 'from' - 'to').\n       **/\n      getFilterLogs: AugmentedRpc<(index: U256 | AnyNumber | Uint8Array) => Observable<Vec<EthLog>>>;\n      /**\n       * Returns logs matching given filter object.\n       **/\n      getLogs: AugmentedRpc<(filter: EthFilter | { fromBlock?: any; toBlock?: any; blockHash?: any; address?: any; topics?: any } | string | Uint8Array) => Observable<Vec<EthLog>>>;\n      /**\n       * Returns proof for account and storage.\n       **/\n      getProof: AugmentedRpc<(address: H160 | string | Uint8Array, storageKeys: Vec<H256> | (H256 | string | Uint8Array)[], number: BlockNumber | AnyNumber | Uint8Array) => Observable<EthAccount>>;\n      /**\n       * Returns content of the storage at given address.\n       **/\n      getStorageAt: AugmentedRpc<(address: H160 | string | Uint8Array, index: U256 | AnyNumber | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<H256>>;\n      /**\n       * Returns transaction at given block hash and index.\n       **/\n      getTransactionByBlockHashAndIndex: AugmentedRpc<(hash: H256 | string | Uint8Array, index: U256 | AnyNumber | Uint8Array) => Observable<EthTransaction>>;\n      /**\n       * Returns transaction by given block number and index.\n       **/\n      getTransactionByBlockNumberAndIndex: AugmentedRpc<(number: BlockNumber | AnyNumber | Uint8Array, index: U256 | AnyNumber | Uint8Array) => Observable<EthTransaction>>;\n      /**\n       * Get transaction by its hash.\n       **/\n      getTransactionByHash: AugmentedRpc<(hash: H256 | string | Uint8Array) => Observable<EthTransaction>>;\n      /**\n       * Returns the number of transactions sent from given address at given time (block number).\n       **/\n      getTransactionCount: AugmentedRpc<(address: H160 | string | Uint8Array, number?: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns transaction receipt by transaction hash.\n       **/\n      getTransactionReceipt: AugmentedRpc<(hash: H256 | string | Uint8Array) => Observable<EthReceipt>>;\n      /**\n       * Returns an uncles at given block and index.\n       **/\n      getUncleByBlockHashAndIndex: AugmentedRpc<(hash: H256 | string | Uint8Array, index: U256 | AnyNumber | Uint8Array) => Observable<EthRichBlock>>;\n      /**\n       * Returns an uncles at given block and index.\n       **/\n      getUncleByBlockNumberAndIndex: AugmentedRpc<(number: BlockNumber | AnyNumber | Uint8Array, index: U256 | AnyNumber | Uint8Array) => Observable<EthRichBlock>>;\n      /**\n       * Returns the number of uncles in a block with given hash.\n       **/\n      getUncleCountByBlockHash: AugmentedRpc<(hash: H256 | string | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns the number of uncles in a block with given block number.\n       **/\n      getUncleCountByBlockNumber: AugmentedRpc<(number: BlockNumber | AnyNumber | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns the hash of the current block, the seedHash, and the boundary condition to be met.\n       **/\n      getWork: AugmentedRpc<() => Observable<EthWork>>;\n      /**\n       * Returns the number of hashes per second that the node is mining with.\n       **/\n      hashrate: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns max priority fee per gas\n       **/\n      maxPriorityFeePerGas: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns true if client is actively mining new blocks.\n       **/\n      mining: AugmentedRpc<() => Observable<bool>>;\n      /**\n       * Returns id of new block filter.\n       **/\n      newBlockFilter: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns id of new filter.\n       **/\n      newFilter: AugmentedRpc<(filter: EthFilter | { fromBlock?: any; toBlock?: any; blockHash?: any; address?: any; topics?: any } | string | Uint8Array) => Observable<U256>>;\n      /**\n       * Returns id of new block filter.\n       **/\n      newPendingTransactionFilter: AugmentedRpc<() => Observable<U256>>;\n      /**\n       * Returns protocol version encoded as a string (quotes are necessary).\n       **/\n      protocolVersion: AugmentedRpc<() => Observable<u64>>;\n      /**\n       * Sends signed transaction, returning its hash.\n       **/\n      sendRawTransaction: AugmentedRpc<(bytes: Bytes | string | Uint8Array) => Observable<H256>>;\n      /**\n       * Sends transaction; will block waiting for signer to return the transaction hash\n       **/\n      sendTransaction: AugmentedRpc<(tx: EthTransactionRequest | { from?: any; to?: any; gasPrice?: any; gas?: any; value?: any; data?: any; nonce?: any } | string | Uint8Array) => Observable<H256>>;\n      /**\n       * Used for submitting mining hashrate.\n       **/\n      submitHashrate: AugmentedRpc<(index: U256 | AnyNumber | Uint8Array, hash: H256 | string | Uint8Array) => Observable<bool>>;\n      /**\n       * Used for submitting a proof-of-work solution.\n       **/\n      submitWork: AugmentedRpc<(nonce: H64 | string | Uint8Array, headerHash: H256 | string | Uint8Array, mixDigest: H256 | string | Uint8Array) => Observable<bool>>;\n      /**\n       * Subscribe to Eth subscription.\n       **/\n      subscribe: AugmentedRpc<(kind: EthSubKind | 'newHeads' | 'logs' | 'newPendingTransactions' | 'syncing' | number | Uint8Array, params?: EthSubParams | { None: any } | { Logs: any } | string | Uint8Array) => Observable<Null>>;\n      /**\n       * Returns an object with data about the sync status or false.\n       **/\n      syncing: AugmentedRpc<() => Observable<EthSyncStatus>>;\n      /**\n       * Uninstalls filter.\n       **/\n      uninstallFilter: AugmentedRpc<(index: U256 | AnyNumber | Uint8Array) => Observable<bool>>;\n    };\n    ethy: {\n      /**\n       * Get ETH event proof for event Id\n       **/\n      getEventProof: AugmentedRpc<(eventId: EventProofId | AnyNumber | Uint8Array) => Observable<Option<EthEventProofResponse>>>;\n      /**\n       * Get XRPL event proof for event Id\n       **/\n      getXrplTxProof: AugmentedRpc<(eventId: EventProofId | AnyNumber | Uint8Array) => Observable<Option<XrplEventProofResponse>>>;\n    };\n    grandpa: {\n      /**\n       * Prove finality for the given block number, returning the Justification for the last block in the set.\n       **/\n      proveFinality: AugmentedRpc<(blockNumber: BlockNumber | AnyNumber | Uint8Array) => Observable<Option<EncodedFinalityProofs>>>;\n      /**\n       * Returns the state of the current best round state as well as the ongoing background rounds\n       **/\n      roundState: AugmentedRpc<() => Observable<ReportedRoundStates>>;\n      /**\n       * Subscribes to grandpa justifications\n       **/\n      subscribeJustifications: AugmentedRpc<() => Observable<JustificationNotification>>;\n    };\n    mmr: {\n      /**\n       * Generate MMR proof for the given block numbers.\n       **/\n      generateProof: AugmentedRpc<(blockNumbers: Vec<u64> | (u64 | AnyNumber | Uint8Array)[], bestKnownBlockNumber?: u64 | AnyNumber | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<MmrLeafBatchProof>>;\n      /**\n       * Get the MMR root hash for the current best block.\n       **/\n      root: AugmentedRpc<(at?: BlockHash | string | Uint8Array) => Observable<MmrHash>>;\n      /**\n       * Verify an MMR proof\n       **/\n      verifyProof: AugmentedRpc<(proof: MmrLeafBatchProof | { blockHash?: any; leaves?: any; proof?: any } | string | Uint8Array) => Observable<bool>>;\n      /**\n       * Verify an MMR proof statelessly given an mmr_root\n       **/\n      verifyProofStateless: AugmentedRpc<(root: MmrHash | string | Uint8Array, proof: MmrLeafBatchProof | { blockHash?: any; leaves?: any; proof?: any } | string | Uint8Array) => Observable<bool>>;\n    };\n    net: {\n      /**\n       * Returns true if client is actively listening for network connections. Otherwise false.\n       **/\n      listening: AugmentedRpc<() => Observable<bool>>;\n      /**\n       * Returns number of peers connected to node.\n       **/\n      peerCount: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Returns protocol version.\n       **/\n      version: AugmentedRpc<() => Observable<Text>>;\n    };\n    nft: {\n      /**\n       * Get all NFTs owned by an account\n       **/\n      ownedTokens: AugmentedRpc<(collectionId: CollectionUuid | AnyNumber | Uint8Array, who: AccountId | string | Uint8Array, cursor: SerialNumber | AnyNumber | Uint8Array, limit: u16 | AnyNumber | Uint8Array) => Observable<Json>>;\n      /**\n       * Get the URI of a token\n       **/\n      tokenUri: AugmentedRpc<(tokenId: TokenId) => Observable<Json>>;\n    };\n    offchain: {\n      /**\n       * Get offchain local storage under given key and prefix\n       **/\n      localStorageGet: AugmentedRpc<(kind: StorageKind | 'PERSISTENT' | 'LOCAL' | number | Uint8Array, key: Bytes | string | Uint8Array) => Observable<Option<Bytes>>>;\n      /**\n       * Set offchain local storage under given key and prefix\n       **/\n      localStorageSet: AugmentedRpc<(kind: StorageKind | 'PERSISTENT' | 'LOCAL' | number | Uint8Array, key: Bytes | string | Uint8Array, value: Bytes | string | Uint8Array) => Observable<Null>>;\n    };\n    payment: {\n      /**\n       * @deprecated Use `api.call.transactionPaymentApi.queryFeeDetails` instead\n       * Query the detailed fee of a given encoded extrinsic\n       **/\n      queryFeeDetails: AugmentedRpc<(extrinsic: Bytes | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<FeeDetails>>;\n      /**\n       * @deprecated Use `api.call.transactionPaymentApi.queryInfo` instead\n       * Retrieves the fee information for an encoded extrinsic\n       **/\n      queryInfo: AugmentedRpc<(extrinsic: Bytes | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<RuntimeDispatchInfoV1>>;\n    };\n    rpc: {\n      /**\n       * Retrieves the list of RPC methods that are exposed by the node\n       **/\n      methods: AugmentedRpc<() => Observable<RpcMethods>>;\n    };\n    state: {\n      /**\n       * Perform a call to a builtin on the chain\n       **/\n      call: AugmentedRpc<(method: Text | string, data: Bytes | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<Bytes>>;\n      /**\n       * Retrieves the keys with prefix of a specific child storage\n       **/\n      getChildKeys: AugmentedRpc<(childStorageKey: StorageKey | string | Uint8Array | any, childDefinition: StorageKey | string | Uint8Array | any, childType: u32 | AnyNumber | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns proof of storage for child key entries at a specific block state.\n       **/\n      getChildReadProof: AugmentedRpc<(childStorageKey: PrefixedStorageKey | string | Uint8Array, keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], at?: BlockHash | string | Uint8Array) => Observable<ReadProof>>;\n      /**\n       * Retrieves the child storage for a key\n       **/\n      getChildStorage: AugmentedRpc<(childStorageKey: StorageKey | string | Uint8Array | any, childDefinition: StorageKey | string | Uint8Array | any, childType: u32 | AnyNumber | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<StorageData>>;\n      /**\n       * Retrieves the child storage hash\n       **/\n      getChildStorageHash: AugmentedRpc<(childStorageKey: StorageKey | string | Uint8Array | any, childDefinition: StorageKey | string | Uint8Array | any, childType: u32 | AnyNumber | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Hash>>;\n      /**\n       * Retrieves the child storage size\n       **/\n      getChildStorageSize: AugmentedRpc<(childStorageKey: StorageKey | string | Uint8Array | any, childDefinition: StorageKey | string | Uint8Array | any, childType: u32 | AnyNumber | Uint8Array, key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<u64>>;\n      /**\n       * @deprecated Use `api.rpc.state.getKeysPaged` to retrieve keys\n       * Retrieves the keys with a certain prefix\n       **/\n      getKeys: AugmentedRpc<(key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns the keys with prefix with pagination support.\n       **/\n      getKeysPaged: AugmentedRpc<(key: StorageKey | string | Uint8Array | any, count: u32 | AnyNumber | Uint8Array, startKey?: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Vec<StorageKey>>>;\n      /**\n       * Returns the runtime metadata\n       **/\n      getMetadata: AugmentedRpc<(at?: BlockHash | string | Uint8Array) => Observable<Metadata>>;\n      /**\n       * @deprecated Use `api.rpc.state.getKeysPaged` to retrieve keys\n       * Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)\n       **/\n      getPairs: AugmentedRpc<(prefix: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Vec<KeyValue>>>;\n      /**\n       * Returns proof of storage entries at a specific block state\n       **/\n      getReadProof: AugmentedRpc<(keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], at?: BlockHash | string | Uint8Array) => Observable<ReadProof>>;\n      /**\n       * Get the runtime version\n       **/\n      getRuntimeVersion: AugmentedRpc<(at?: BlockHash | string | Uint8Array) => Observable<RuntimeVersion>>;\n      /**\n       * Retrieves the storage for a key\n       **/\n      getStorage: AugmentedRpc<<T = Codec>(key: StorageKey | string | Uint8Array | any, block?: Hash | Uint8Array | string) => Observable<T>>;\n      /**\n       * Retrieves the storage hash\n       **/\n      getStorageHash: AugmentedRpc<(key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<Hash>>;\n      /**\n       * Retrieves the storage size\n       **/\n      getStorageSize: AugmentedRpc<(key: StorageKey | string | Uint8Array | any, at?: BlockHash | string | Uint8Array) => Observable<u64>>;\n      /**\n       * Query historical storage entries (by key) starting from a start block\n       **/\n      queryStorage: AugmentedRpc<<T = Codec[]>(keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], fromBlock?: Hash | Uint8Array | string, toBlock?: Hash | Uint8Array | string) => Observable<[Hash, T][]>>;\n      /**\n       * Query storage entries (by key) starting at block hash given as the second parameter\n       **/\n      queryStorageAt: AugmentedRpc<<T = Codec[]>(keys: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[], at?: Hash | Uint8Array | string) => Observable<T>>;\n      /**\n       * Retrieves the runtime version via subscription\n       **/\n      subscribeRuntimeVersion: AugmentedRpc<() => Observable<RuntimeVersion>>;\n      /**\n       * Subscribes to storage changes for the provided keys\n       **/\n      subscribeStorage: AugmentedRpc<<T = Codec[]>(keys?: Vec<StorageKey> | (StorageKey | string | Uint8Array | any)[]) => Observable<T>>;\n      /**\n       * Provides a way to trace the re-execution of a single block\n       **/\n      traceBlock: AugmentedRpc<(block: Hash | string | Uint8Array, targets: Option<Text> | null | Uint8Array | Text | string, storageKeys: Option<Text> | null | Uint8Array | Text | string, methods: Option<Text> | null | Uint8Array | Text | string) => Observable<TraceBlockResponse>>;\n      /**\n       * Check current migration state\n       **/\n      trieMigrationStatus: AugmentedRpc<(at?: BlockHash | string | Uint8Array) => Observable<MigrationStatusResult>>;\n    };\n    syncstate: {\n      /**\n       * Returns the json-serialized chainspec running the node, with a sync state.\n       **/\n      genSyncSpec: AugmentedRpc<(raw: bool | boolean | Uint8Array) => Observable<Json>>;\n    };\n    system: {\n      /**\n       * Retrieves the next accountIndex as available on the node\n       **/\n      accountNextIndex: AugmentedRpc<(accountId: AccountId | string | Uint8Array) => Observable<Index>>;\n      /**\n       * Adds the supplied directives to the current log filter\n       **/\n      addLogFilter: AugmentedRpc<(directives: Text | string) => Observable<Null>>;\n      /**\n       * Adds a reserved peer\n       **/\n      addReservedPeer: AugmentedRpc<(peer: Text | string) => Observable<Text>>;\n      /**\n       * Retrieves the chain\n       **/\n      chain: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Retrieves the chain type\n       **/\n      chainType: AugmentedRpc<() => Observable<ChainType>>;\n      /**\n       * Dry run an extrinsic at a given block\n       **/\n      dryRun: AugmentedRpc<(extrinsic: Bytes | string | Uint8Array, at?: BlockHash | string | Uint8Array) => Observable<ApplyExtrinsicResult>>;\n      /**\n       * Return health status of the node\n       **/\n      health: AugmentedRpc<() => Observable<Health>>;\n      /**\n       * The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example\n       **/\n      localListenAddresses: AugmentedRpc<() => Observable<Vec<Text>>>;\n      /**\n       * Returns the base58-encoded PeerId of the node\n       **/\n      localPeerId: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Retrieves the node name\n       **/\n      name: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Returns current state of the network\n       **/\n      networkState: AugmentedRpc<() => Observable<NetworkState>>;\n      /**\n       * Returns the roles the node is running as\n       **/\n      nodeRoles: AugmentedRpc<() => Observable<Vec<NodeRole>>>;\n      /**\n       * Returns the currently connected peers\n       **/\n      peers: AugmentedRpc<() => Observable<Vec<PeerInfo>>>;\n      /**\n       * Get a custom set of properties as a JSON object, defined in the chain spec\n       **/\n      properties: AugmentedRpc<() => Observable<ChainProperties>>;\n      /**\n       * Remove a reserved peer\n       **/\n      removeReservedPeer: AugmentedRpc<(peerId: Text | string) => Observable<Text>>;\n      /**\n       * Returns the list of reserved peers\n       **/\n      reservedPeers: AugmentedRpc<() => Observable<Vec<Text>>>;\n      /**\n       * Resets the log filter to Substrate defaults\n       **/\n      resetLogFilter: AugmentedRpc<() => Observable<Null>>;\n      /**\n       * Returns the state of the syncing of the node\n       **/\n      syncState: AugmentedRpc<() => Observable<SyncState>>;\n      /**\n       * Retrieves the version of the node\n       **/\n      version: AugmentedRpc<() => Observable<Text>>;\n    };\n    web3: {\n      /**\n       * Returns current client version.\n       **/\n      clientVersion: AugmentedRpc<() => Observable<Text>>;\n      /**\n       * Returns sha3 of the given data\n       **/\n      sha3: AugmentedRpc<(data: Bytes | string | Uint8Array) => Observable<H256>>;\n    };\n  } // RpcInterface\n} // declare module\n"],"version":3}