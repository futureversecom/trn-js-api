{"file":"/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/tx.e2e.ts","mappings":"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","names":[],"sources":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/tx.e2e.ts"],"sourcesContent":["// // Copyright 2019-2020 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import {AssetInfoV40 as AssetInfo, AssetOptions, Balance, LiquidityPriceResponse} from \"@cennznet/types\";\n// import {cvmToAddress} from \"@cennznet/types/utils\";\n// import { SubmittableResult } from '@polkadot/api';\n// import { Keyring } from '@polkadot/keyring';\n// import { KeyringPair } from '@polkadot/keyring/types';\n// import { stringToHex } from '@polkadot/util';\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n// import initApiPromise from '../../../../jest/initApiPromise';\n// import { SingleAccountSigner } from \"./util/SingleAccountSigner\";\n// import { mock } from '@depay/web3-mock'\n//\n// const keyring = new Keyring({ type: 'sr25519' });\n//\n// describe('e2e transactions', () => {\n//   let api;\n//   let alice, bob;\n//   let spendingAssetId, stakingAssetId;\n//\n//   beforeAll(async () => {\n//     await cryptoWaitReady();\n//     api = await initApiPromise();\n//     alice = keyring.addFromUri('//Alice');\n//     bob = keyring.addFromUri('//Bob');\n//\n//     spendingAssetId = await api.query.genericAsset.spendingAssetId();\n//     stakingAssetId = await api.query.genericAsset.stakingAssetId();\n//\n//     mock('ethereum');\n//   });\n//\n//   afterAll(async () => {\n//     await api.disconnect();\n//   });\n//\n//   describe('Send', () => {\n//\n//     it('Makes a tx using immortal era', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(bob.address);\n//       await api.tx.genericAsset\n//         .transfer(stakingAssetId, alice.address, 100)\n//         .signAndSend(bob, { nonce },\n//           async ({ events, status }: SubmittableResult) => {\n//             if (status.isInBlock) {\n//               expect(events[0].event.method).toEqual('Transferred');\n//               expect(events[0].event.section).toEqual('genericAsset');\n//               done();\n//             }\n//           });\n//     });\n//\n//     it('Makes a tx via send', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(bob.address);\n//       const tx = api.tx.genericAsset\n//         .transfer(stakingAssetId, alice.address, 1)\n//         .sign(bob, { nonce });\n//       await tx.send(async ({ events, status }: SubmittableResult) => {\n//         if (status.isInBlock) {\n//           expect(events[0].event.method).toEqual('Transferred');\n//           expect(events[0].event.section).toEqual('genericAsset');\n//           done();\n//         }\n//       });\n//     });\n//\n//     it('Makes a tx', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(bob.address);\n//       await api.tx.genericAsset\n//         .transfer(stakingAssetId, alice.address, 1)\n//         .signAndSend(bob, { nonce }, async ({ events, status }: SubmittableResult) => {\n//           if (status.isInBlock) {\n//             expect(events[0].event.method).toEqual('Transferred');\n//             expect(events[0].event.section).toEqual('genericAsset');\n//             done();\n//           }\n//         });\n//     });\n//\n//   });\n//\n//   describe('Eth signining txs', () => {\n//\n//     it('Convert eth address to cennznet address', async done => {\n//       const ethAddress = '0x5D5586341ca72146791C33c26c0c10eD971c9B53';\n//       const cennznetAddress = cvmToAddress(ethAddress);\n//       console.log('cennznetAddress:',cennznetAddress);\n//       expect(cennznetAddress).toEqual('5EK7n4pa3FcCGoxvoqUFJM8CD6fngE31G4rAjqLYW2bXtstn');\n//       done();\n//     });\n//\n//     it('Uses eth wallet to sign', async done => {\n//       const ethAddress = '0x5d5586341ca72146791c33c26c0c10ed971c9b53';\n//       // Find the equivalent CENNZnet address for Ethereum address and send some CPAY to spend on txs\n//       const cennznetAddress = cvmToAddress(ethAddress);\n//       const amount = 100000;\n//       const nonce = await api.rpc.system.accountNextIndex(alice.address);\n//       const fundTransferred = new Promise<void>(async (resolve, reject) => {\n//         await api.tx.genericAsset\n//             .transfer(stakingAssetId, cennznetAddress, amount)\n//             .signAndSend(\n//                 alice,\n//                 { nonce });\n//         await api.tx.genericAsset\n//             .transfer(spendingAssetId, cennznetAddress, amount)\n//             .signAndSend(\n//                 alice,\n//                 { nonce: nonce+1 }, ({ status }) => status.isInBlock ? resolve() : null\n//             );\n//       });\n//       fundTransferred.then(async () => {\n//         // Start with a connected wallet\n//         const accounts = [ethAddress];\n//         mock({\n//           blockchain: 'ethereum',\n//           accounts: {return: accounts},\n//           signature: {\n//             params: [accounts[0], 'sign'],\n//             return: \"0xc8ee1390bc05479bb4e13eb36b46714af19821eb590142e3f8fb7d972f6f31fb070717be960e41e4ec33baf85776c43e5be588916e7c41ee20ad99c6695fa7fa1b\"\n//           }\n//         });\n//\n//\n//         const transferAmt = 20000;\n//         await api.tx.genericAsset\n//             .transfer(stakingAssetId, alice.address, transferAmt)\n//             .signViaEthWallet(\n//                 ethAddress,\n//                 api,\n//                 (global as any).ethereum,  async ({ events, status }: SubmittableResult) => {\n//                   if (status.isInBlock) {\n//                     expect(events[0].event.method).toEqual('Transferred');\n//                     expect(events[0].event.section).toEqual('genericAsset');\n//                     done();\n//                   }\n//                 }\n//             );\n//       });\n//     });\n//   });\n//\n//   describe('Extrinsic payment options', () => {\n//     // A generic asset to be used for fee payment\n//     let feeAssetId;\n//     // This account will own the newly created asset and receive initial issuance\n//     // It will also mint liquidity on CENNZ-X\n//     let assetOwner: KeyringPair;\n//\n//     beforeAll(async done => {\n//       // Setup:\n//       // Create a new generic asset and mint a liquidity pool on CENNZX.\n//       // This fee asset will be used for fee payment in place of the default asset, CPAY.\n//       assetOwner = keyring.addFromUri('//Test//AssetOwner');\n//\n//       // Amount of test asset to create\n//       const initialIssuance = 900_000_000_000_000;\n//       const owner = api.registry.createType('Owner', assetOwner.address, 1); // Owner type is enum with 0 as none/null\n//       const permissions = api.registry.createType('PermissionsV1', { update: owner, mint: owner, burn: owner});\n//       const option = {initialIssuance , permissions};\n//       const assetOption: AssetOptions = api.registry.createType('AssetOptions', option);\n//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'TEST', decimalPlaces: 4, existentialDeposit: 5});\n//       let createAssetTx = api.tx.genericAsset.create(assetOwner.address, assetOption, assetInfo);\n//\n//       // Lookup from keyring (assuming we have added all, on --dev this would be `//Alice`)\n//       const sudoAddress = await api.query.sudo.key();\n//       const sudoKeypair = keyring.getPair(sudoAddress.toString());\n//\n//       // when the new asset is created it will have this ID.\n//       feeAssetId = await api.query.genericAsset.nextAssetId();\n//\n//       // 1) Create the new fee asset\n//       // 2) Mint CPAY to assetOwner to fund subsequent pool liquidity and further transactions.\n//       const assetCreated = new Promise<void>(async (resolve, reject) => {\n//         let nonce = await api.rpc.system.accountNextIndex(sudoAddress);\n//         await api.tx.sudo.sudo(createAssetTx).signAndSend(sudoKeypair, { nonce: nonce++ });\n//         await api.tx.genericAsset.mint(spendingAssetId, assetOwner.address, initialIssuance).signAndSend(\n//           sudoKeypair, { nonce: nonce++ }, ({ status }) => status.isInBlock ? resolve() : null\n//         );\n//       });\n//\n//       // 3) Mint liquidity for fee asset <> CPAY.\n//       assetCreated.then(async () => {\n//         const desiredLiquidity = 30_000_000;\n//         const minimumLiquidity = 1;\n//         const liquidityPrice: LiquidityPriceResponse = await (api.rpc.cennzx.liquidityPrice(feeAssetId, desiredLiquidity));\n//         await api.tx.cennzx\n//           .addLiquidity(feeAssetId, minimumLiquidity, liquidityPrice.asset, liquidityPrice.core)\n//           .signAndSend(assetOwner, ({ events, status }) => status.isInBlock ? done() :null );\n//\n//       });\n//\n//     });\n//\n//     it('Uses keypair to sign', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);\n//       await api.tx.genericAsset\n//         .transfer(spendingAssetId, bob.address, 100)\n//         .setPaymentOpts(api, {feeAssetId: feeAssetId, slippage: 0, tip: 0})\n//         .signAndSend(\n//           assetOwner,\n//           { nonce },\n//           ({ status }) => status.isInBlock ? done() : null\n//         );\n//     });\n//\n//     it('Use tip along with fee exchange', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);\n//       await api.tx.genericAsset\n//         .transfer(spendingAssetId, bob.address, 100)\n//         .setPaymentOpts(api, { feeAssetId: feeAssetId, slippage: 0, tip: 2})\n//         .signAndSend(\n//           assetOwner,\n//           { nonce },\n//           ({ status }) => (status.isInBlock) ? done() : null\n//       );\n//     });\n//\n//     it('Use slippage for max payment in transaction', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);\n//       await api.tx.genericAsset\n//         .transfer(spendingAssetId, bob.address, 100)\n//         .setPaymentOpts(api, { feeAssetId: feeAssetId, slippage: 0.03})\n//         .signAndSend(\n//           assetOwner,\n//           { nonce },\n//           ({ status }) => (status.isInBlock) ? done() : null\n//         );\n//     });\n//\n//     it('Update asset info', async done => {\n//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);\n//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'NEW_ASSET_ID', decimalPlaces: 5, existentialDeposit: 5});\n//       await api.tx.genericAsset.updateAssetInfo( feeAssetId, assetInfo).signAndSend(assetOwner, { nonce }, async ({ events, status }) => {\n//         if (status.isInBlock) {\n//           for (const { event: { method, section, data } } of events) {\n//             if (section === 'genericAsset' && method == 'AssetInfoUpdated') {\n//               const [assetId, assetMeta] = data;\n//               expect(assetId as number).toEqual(feeAssetId);\n//               expect(assetMeta.toJSON()).toEqual({\n//                 existentialDeposit: 5,\n//                 decimalPlaces: 5,\n//                 symbol: stringToHex('NEW_ASSET_ID')\n//               });\n//\n//               done();\n//             }\n//           }\n//         }\n//       });\n//     });\n//   });\n//\n//\n//   describe('Signed via signer', () => {\n//     it('should sign with a signer', async done => {\n//       const dave = keyring.addFromUri('//Dave');\n//       const signer = new SingleAccountSigner(api.registry, dave);\n//       const transfer = api.tx.genericAsset.transfer(spendingAssetId, alice.address, 54121);\n//       await transfer.signAndSend(dave.address, { signer }, async ({events, status}) => {\n//         if (status.isInBlock) {\n//           for (const {event: { method, section } } of events) {\n//             if (section === 'genericAsset' && method == 'Transferred') {\n//               done();\n//             }\n//           }\n//         }\n//       });\n//     });\n//   });\n//\n// });\n"],"version":3}