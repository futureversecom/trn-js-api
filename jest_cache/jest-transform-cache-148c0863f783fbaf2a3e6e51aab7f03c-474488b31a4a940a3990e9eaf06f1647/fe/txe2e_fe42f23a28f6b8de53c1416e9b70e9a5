003c5d930730e2a7c9e51be89f0fecf7
"use strict";
// // Copyright 2019-2020 Centrality Investments Limited
// //
// // Licensed under the Apache License, Version 2.0 (the "License");
// // you may not use this file except in compliance with the License.
// // You may obtain a copy of the License at
// //
// //     http://www.apache.org/licenses/LICENSE-2.0
// //
// // Unless required by applicable law or agreed to in writing, software
// // distributed under the License is distributed on an "AS IS" BASIS,
// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// // See the License for the specific language governing permissions and
// // limitations under the License.
//
// import {AssetInfoV40 as AssetInfo, AssetOptions, Balance, LiquidityPriceResponse} from "@cennznet/types";
// import {cvmToAddress} from "@cennznet/types/utils";
// import { SubmittableResult } from '@polkadot/api';
// import { Keyring } from '@polkadot/keyring';
// import { KeyringPair } from '@polkadot/keyring/types';
// import { stringToHex } from '@polkadot/util';
// import { cryptoWaitReady } from '@polkadot/util-crypto';
// import initApiPromise from '../../../../jest/initApiPromise';
// import { SingleAccountSigner } from "./util/SingleAccountSigner";
// import { mock } from '@depay/web3-mock'
//
// const keyring = new Keyring({ type: 'sr25519' });
//
// describe('e2e transactions', () => {
//   let api;
//   let alice, bob;
//   let spendingAssetId, stakingAssetId;
//
//   beforeAll(async () => {
//     await cryptoWaitReady();
//     api = await initApiPromise();
//     alice = keyring.addFromUri('//Alice');
//     bob = keyring.addFromUri('//Bob');
//
//     spendingAssetId = await api.query.genericAsset.spendingAssetId();
//     stakingAssetId = await api.query.genericAsset.stakingAssetId();
//
//     mock('ethereum');
//   });
//
//   afterAll(async () => {
//     await api.disconnect();
//   });
//
//   describe('Send', () => {
//
//     it('Makes a tx using immortal era', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(bob.address);
//       await api.tx.genericAsset
//         .transfer(stakingAssetId, alice.address, 100)
//         .signAndSend(bob, { nonce },
//           async ({ events, status }: SubmittableResult) => {
//             if (status.isInBlock) {
//               expect(events[0].event.method).toEqual('Transferred');
//               expect(events[0].event.section).toEqual('genericAsset');
//               done();
//             }
//           });
//     });
//
//     it('Makes a tx via send', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(bob.address);
//       const tx = api.tx.genericAsset
//         .transfer(stakingAssetId, alice.address, 1)
//         .sign(bob, { nonce });
//       await tx.send(async ({ events, status }: SubmittableResult) => {
//         if (status.isInBlock) {
//           expect(events[0].event.method).toEqual('Transferred');
//           expect(events[0].event.section).toEqual('genericAsset');
//           done();
//         }
//       });
//     });
//
//     it('Makes a tx', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(bob.address);
//       await api.tx.genericAsset
//         .transfer(stakingAssetId, alice.address, 1)
//         .signAndSend(bob, { nonce }, async ({ events, status }: SubmittableResult) => {
//           if (status.isInBlock) {
//             expect(events[0].event.method).toEqual('Transferred');
//             expect(events[0].event.section).toEqual('genericAsset');
//             done();
//           }
//         });
//     });
//
//   });
//
//   describe('Eth signining txs', () => {
//
//     it('Convert eth address to cennznet address', async done => {
//       const ethAddress = '0x5D5586341ca72146791C33c26c0c10eD971c9B53';
//       const cennznetAddress = cvmToAddress(ethAddress);
//       console.log('cennznetAddress:',cennznetAddress);
//       expect(cennznetAddress).toEqual('5EK7n4pa3FcCGoxvoqUFJM8CD6fngE31G4rAjqLYW2bXtstn');
//       done();
//     });
//
//     it('Uses eth wallet to sign', async done => {
//       const ethAddress = '0x5d5586341ca72146791c33c26c0c10ed971c9b53';
//       // Find the equivalent CENNZnet address for Ethereum address and send some CPAY to spend on txs
//       const cennznetAddress = cvmToAddress(ethAddress);
//       const amount = 100000;
//       const nonce = await api.rpc.system.accountNextIndex(alice.address);
//       const fundTransferred = new Promise<void>(async (resolve, reject) => {
//         await api.tx.genericAsset
//             .transfer(stakingAssetId, cennznetAddress, amount)
//             .signAndSend(
//                 alice,
//                 { nonce });
//         await api.tx.genericAsset
//             .transfer(spendingAssetId, cennznetAddress, amount)
//             .signAndSend(
//                 alice,
//                 { nonce: nonce+1 }, ({ status }) => status.isInBlock ? resolve() : null
//             );
//       });
//       fundTransferred.then(async () => {
//         // Start with a connected wallet
//         const accounts = [ethAddress];
//         mock({
//           blockchain: 'ethereum',
//           accounts: {return: accounts},
//           signature: {
//             params: [accounts[0], 'sign'],
//             return: "0xc8ee1390bc05479bb4e13eb36b46714af19821eb590142e3f8fb7d972f6f31fb070717be960e41e4ec33baf85776c43e5be588916e7c41ee20ad99c6695fa7fa1b"
//           }
//         });
//
//
//         const transferAmt = 20000;
//         await api.tx.genericAsset
//             .transfer(stakingAssetId, alice.address, transferAmt)
//             .signViaEthWallet(
//                 ethAddress,
//                 api,
//                 (global as any).ethereum,  async ({ events, status }: SubmittableResult) => {
//                   if (status.isInBlock) {
//                     expect(events[0].event.method).toEqual('Transferred');
//                     expect(events[0].event.section).toEqual('genericAsset');
//                     done();
//                   }
//                 }
//             );
//       });
//     });
//   });
//
//   describe('Extrinsic payment options', () => {
//     // A generic asset to be used for fee payment
//     let feeAssetId;
//     // This account will own the newly created asset and receive initial issuance
//     // It will also mint liquidity on CENNZ-X
//     let assetOwner: KeyringPair;
//
//     beforeAll(async done => {
//       // Setup:
//       // Create a new generic asset and mint a liquidity pool on CENNZX.
//       // This fee asset will be used for fee payment in place of the default asset, CPAY.
//       assetOwner = keyring.addFromUri('//Test//AssetOwner');
//
//       // Amount of test asset to create
//       const initialIssuance = 900_000_000_000_000;
//       const owner = api.registry.createType('Owner', assetOwner.address, 1); // Owner type is enum with 0 as none/null
//       const permissions = api.registry.createType('PermissionsV1', { update: owner, mint: owner, burn: owner});
//       const option = {initialIssuance , permissions};
//       const assetOption: AssetOptions = api.registry.createType('AssetOptions', option);
//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'TEST', decimalPlaces: 4, existentialDeposit: 5});
//       let createAssetTx = api.tx.genericAsset.create(assetOwner.address, assetOption, assetInfo);
//
//       // Lookup from keyring (assuming we have added all, on --dev this would be `//Alice`)
//       const sudoAddress = await api.query.sudo.key();
//       const sudoKeypair = keyring.getPair(sudoAddress.toString());
//
//       // when the new asset is created it will have this ID.
//       feeAssetId = await api.query.genericAsset.nextAssetId();
//
//       // 1) Create the new fee asset
//       // 2) Mint CPAY to assetOwner to fund subsequent pool liquidity and further transactions.
//       const assetCreated = new Promise<void>(async (resolve, reject) => {
//         let nonce = await api.rpc.system.accountNextIndex(sudoAddress);
//         await api.tx.sudo.sudo(createAssetTx).signAndSend(sudoKeypair, { nonce: nonce++ });
//         await api.tx.genericAsset.mint(spendingAssetId, assetOwner.address, initialIssuance).signAndSend(
//           sudoKeypair, { nonce: nonce++ }, ({ status }) => status.isInBlock ? resolve() : null
//         );
//       });
//
//       // 3) Mint liquidity for fee asset <> CPAY.
//       assetCreated.then(async () => {
//         const desiredLiquidity = 30_000_000;
//         const minimumLiquidity = 1;
//         const liquidityPrice: LiquidityPriceResponse = await (api.rpc.cennzx.liquidityPrice(feeAssetId, desiredLiquidity));
//         await api.tx.cennzx
//           .addLiquidity(feeAssetId, minimumLiquidity, liquidityPrice.asset, liquidityPrice.core)
//           .signAndSend(assetOwner, ({ events, status }) => status.isInBlock ? done() :null );
//
//       });
//
//     });
//
//     it('Uses keypair to sign', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);
//       await api.tx.genericAsset
//         .transfer(spendingAssetId, bob.address, 100)
//         .setPaymentOpts(api, {feeAssetId: feeAssetId, slippage: 0, tip: 0})
//         .signAndSend(
//           assetOwner,
//           { nonce },
//           ({ status }) => status.isInBlock ? done() : null
//         );
//     });
//
//     it('Use tip along with fee exchange', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);
//       await api.tx.genericAsset
//         .transfer(spendingAssetId, bob.address, 100)
//         .setPaymentOpts(api, { feeAssetId: feeAssetId, slippage: 0, tip: 2})
//         .signAndSend(
//           assetOwner,
//           { nonce },
//           ({ status }) => (status.isInBlock) ? done() : null
//       );
//     });
//
//     it('Use slippage for max payment in transaction', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);
//       await api.tx.genericAsset
//         .transfer(spendingAssetId, bob.address, 100)
//         .setPaymentOpts(api, { feeAssetId: feeAssetId, slippage: 0.03})
//         .signAndSend(
//           assetOwner,
//           { nonce },
//           ({ status }) => (status.isInBlock) ? done() : null
//         );
//     });
//
//     it('Update asset info', async done => {
//       const nonce = await api.rpc.system.accountNextIndex(assetOwner.address);
//       const assetInfo: AssetInfo = api.registry.createType('AssetInfo', {symbol: 'NEW_ASSET_ID', decimalPlaces: 5, existentialDeposit: 5});
//       await api.tx.genericAsset.updateAssetInfo( feeAssetId, assetInfo).signAndSend(assetOwner, { nonce }, async ({ events, status }) => {
//         if (status.isInBlock) {
//           for (const { event: { method, section, data } } of events) {
//             if (section === 'genericAsset' && method == 'AssetInfoUpdated') {
//               const [assetId, assetMeta] = data;
//               expect(assetId as number).toEqual(feeAssetId);
//               expect(assetMeta.toJSON()).toEqual({
//                 existentialDeposit: 5,
//                 decimalPlaces: 5,
//                 symbol: stringToHex('NEW_ASSET_ID')
//               });
//
//               done();
//             }
//           }
//         }
//       });
//     });
//   });
//
//
//   describe('Signed via signer', () => {
//     it('should sign with a signer', async done => {
//       const dave = keyring.addFromUri('//Dave');
//       const signer = new SingleAccountSigner(api.registry, dave);
//       const transfer = api.tx.genericAsset.transfer(spendingAssetId, alice.address, 54121);
//       await transfer.signAndSend(dave.address, { signer }, async ({events, status}) => {
//         if (status.isInBlock) {
//           for (const {event: { method, section } } of events) {
//             if (section === 'genericAsset' && method == 'Transferred') {
//               done();
//             }
//           }
//         }
//       });
//     });
//   });
//
// });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2thcmlzaG1hL3dvcmsvZnV0dXJldmVyc2UvdHJuLXJvb3RuZXQtYXBpL3BhY2thZ2VzL2FwaS90ZXN0L2UyZS90eC5lMmUudHMiLCJtYXBwaW5ncyI6IjtBQUFBLHdEQUF3RDtBQUN4RCxLQUFLO0FBQ0wscUVBQXFFO0FBQ3JFLHNFQUFzRTtBQUN0RSw2Q0FBNkM7QUFDN0MsS0FBSztBQUNMLG9EQUFvRDtBQUNwRCxLQUFLO0FBQ0wseUVBQXlFO0FBQ3pFLHVFQUF1RTtBQUN2RSw4RUFBOEU7QUFDOUUseUVBQXlFO0FBQ3pFLG9DQUFvQztBQUNwQyxFQUFFO0FBQ0YsNEdBQTRHO0FBQzVHLHNEQUFzRDtBQUN0RCxxREFBcUQ7QUFDckQsK0NBQStDO0FBQy9DLHlEQUF5RDtBQUN6RCxnREFBZ0Q7QUFDaEQsMkRBQTJEO0FBQzNELGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUNGLHVDQUF1QztBQUN2QyxhQUFhO0FBQ2Isb0JBQW9CO0FBQ3BCLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0YsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEMsNkNBQTZDO0FBQzdDLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHNFQUFzRTtBQUN0RSxFQUFFO0FBQ0Ysd0JBQXdCO0FBQ3hCLFFBQVE7QUFDUixFQUFFO0FBQ0YsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QixRQUFRO0FBQ1IsRUFBRTtBQUNGLDZCQUE2QjtBQUM3QixFQUFFO0FBQ0YsMERBQTBEO0FBQzFELDBFQUEwRTtBQUMxRSxrQ0FBa0M7QUFDbEMsd0RBQXdEO0FBQ3hELHVDQUF1QztBQUN2QywrREFBK0Q7QUFDL0Qsc0NBQXNDO0FBQ3RDLHVFQUF1RTtBQUN2RSx5RUFBeUU7QUFDekUsd0JBQXdCO0FBQ3hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsVUFBVTtBQUNWLEVBQUU7QUFDRixnREFBZ0Q7QUFD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ZnV0dXJldmVyc2UvdHJuLXJvb3RuZXQtYXBpL3BhY2thZ2VzL2FwaS90ZXN0L2UyZS90eC5lMmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gLy8gQ29weXJpZ2h0IDIwMTktMjAyMCBDZW50cmFsaXR5IEludmVzdG1lbnRzIExpbWl0ZWRcbi8vIC8vXG4vLyAvLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8gLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLyAvL1xuLy8gLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8gLy9cbi8vIC8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIC8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIC8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vL1xuLy8gaW1wb3J0IHtBc3NldEluZm9WNDAgYXMgQXNzZXRJbmZvLCBBc3NldE9wdGlvbnMsIEJhbGFuY2UsIExpcXVpZGl0eVByaWNlUmVzcG9uc2V9IGZyb20gXCJAY2VubnpuZXQvdHlwZXNcIjtcbi8vIGltcG9ydCB7Y3ZtVG9BZGRyZXNzfSBmcm9tIFwiQGNlbm56bmV0L3R5cGVzL3V0aWxzXCI7XG4vLyBpbXBvcnQgeyBTdWJtaXR0YWJsZVJlc3VsdCB9IGZyb20gJ0Bwb2xrYWRvdC9hcGknO1xuLy8gaW1wb3J0IHsgS2V5cmluZyB9IGZyb20gJ0Bwb2xrYWRvdC9rZXlyaW5nJztcbi8vIGltcG9ydCB7IEtleXJpbmdQYWlyIH0gZnJvbSAnQHBvbGthZG90L2tleXJpbmcvdHlwZXMnO1xuLy8gaW1wb3J0IHsgc3RyaW5nVG9IZXggfSBmcm9tICdAcG9sa2Fkb3QvdXRpbCc7XG4vLyBpbXBvcnQgeyBjcnlwdG9XYWl0UmVhZHkgfSBmcm9tICdAcG9sa2Fkb3QvdXRpbC1jcnlwdG8nO1xuLy8gaW1wb3J0IGluaXRBcGlQcm9taXNlIGZyb20gJy4uLy4uLy4uLy4uL2plc3QvaW5pdEFwaVByb21pc2UnO1xuLy8gaW1wb3J0IHsgU2luZ2xlQWNjb3VudFNpZ25lciB9IGZyb20gXCIuL3V0aWwvU2luZ2xlQWNjb3VudFNpZ25lclwiO1xuLy8gaW1wb3J0IHsgbW9jayB9IGZyb20gJ0BkZXBheS93ZWIzLW1vY2snXG4vL1xuLy8gY29uc3Qga2V5cmluZyA9IG5ldyBLZXlyaW5nKHsgdHlwZTogJ3NyMjU1MTknIH0pO1xuLy9cbi8vIGRlc2NyaWJlKCdlMmUgdHJhbnNhY3Rpb25zJywgKCkgPT4ge1xuLy8gICBsZXQgYXBpO1xuLy8gICBsZXQgYWxpY2UsIGJvYjtcbi8vICAgbGV0IHNwZW5kaW5nQXNzZXRJZCwgc3Rha2luZ0Fzc2V0SWQ7XG4vL1xuLy8gICBiZWZvcmVBbGwoYXN5bmMgKCkgPT4ge1xuLy8gICAgIGF3YWl0IGNyeXB0b1dhaXRSZWFkeSgpO1xuLy8gICAgIGFwaSA9IGF3YWl0IGluaXRBcGlQcm9taXNlKCk7XG4vLyAgICAgYWxpY2UgPSBrZXlyaW5nLmFkZEZyb21VcmkoJy8vQWxpY2UnKTtcbi8vICAgICBib2IgPSBrZXlyaW5nLmFkZEZyb21VcmkoJy8vQm9iJyk7XG4vL1xuLy8gICAgIHNwZW5kaW5nQXNzZXRJZCA9IGF3YWl0IGFwaS5xdWVyeS5nZW5lcmljQXNzZXQuc3BlbmRpbmdBc3NldElkKCk7XG4vLyAgICAgc3Rha2luZ0Fzc2V0SWQgPSBhd2FpdCBhcGkucXVlcnkuZ2VuZXJpY0Fzc2V0LnN0YWtpbmdBc3NldElkKCk7XG4vL1xuLy8gICAgIG1vY2soJ2V0aGVyZXVtJyk7XG4vLyAgIH0pO1xuLy9cbi8vICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuLy8gICAgIGF3YWl0IGFwaS5kaXNjb25uZWN0KCk7XG4vLyAgIH0pO1xuLy9cbi8vICAgZGVzY3JpYmUoJ1NlbmQnLCAoKSA9PiB7XG4vL1xuLy8gICAgIGl0KCdNYWtlcyBhIHR4IHVzaW5nIGltbW9ydGFsIGVyYScsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGJvYi5hZGRyZXNzKTtcbi8vICAgICAgIGF3YWl0IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgLnRyYW5zZmVyKHN0YWtpbmdBc3NldElkLCBhbGljZS5hZGRyZXNzLCAxMDApXG4vLyAgICAgICAgIC5zaWduQW5kU2VuZChib2IsIHsgbm9uY2UgfSxcbi8vICAgICAgICAgICBhc3luYyAoeyBldmVudHMsIHN0YXR1cyB9OiBTdWJtaXR0YWJsZVJlc3VsdCkgPT4ge1xuLy8gICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5tZXRob2QpLnRvRXF1YWwoJ1RyYW5zZmVycmVkJyk7XG4vLyAgICAgICAgICAgICAgIGV4cGVjdChldmVudHNbMF0uZXZlbnQuc2VjdGlvbikudG9FcXVhbCgnZ2VuZXJpY0Fzc2V0Jyk7XG4vLyAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9KTtcbi8vICAgICB9KTtcbi8vXG4vLyAgICAgaXQoJ01ha2VzIGEgdHggdmlhIHNlbmQnLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgYXBpLnJwYy5zeXN0ZW0uYWNjb3VudE5leHRJbmRleChib2IuYWRkcmVzcyk7XG4vLyAgICAgICBjb25zdCB0eCA9IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgLnRyYW5zZmVyKHN0YWtpbmdBc3NldElkLCBhbGljZS5hZGRyZXNzLCAxKVxuLy8gICAgICAgICAuc2lnbihib2IsIHsgbm9uY2UgfSk7XG4vLyAgICAgICBhd2FpdCB0eC5zZW5kKGFzeW5jICh7IGV2ZW50cywgc3RhdHVzIH06IFN1Ym1pdHRhYmxlUmVzdWx0KSA9PiB7XG4vLyAgICAgICAgIGlmIChzdGF0dXMuaXNJbkJsb2NrKSB7XG4vLyAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5tZXRob2QpLnRvRXF1YWwoJ1RyYW5zZmVycmVkJyk7XG4vLyAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5zZWN0aW9uKS50b0VxdWFsKCdnZW5lcmljQXNzZXQnKTtcbi8vICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICBpdCgnTWFrZXMgYSB0eCcsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGJvYi5hZGRyZXNzKTtcbi8vICAgICAgIGF3YWl0IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgLnRyYW5zZmVyKHN0YWtpbmdBc3NldElkLCBhbGljZS5hZGRyZXNzLCAxKVxuLy8gICAgICAgICAuc2lnbkFuZFNlbmQoYm9iLCB7IG5vbmNlIH0sIGFzeW5jICh7IGV2ZW50cywgc3RhdHVzIH06IFN1Ym1pdHRhYmxlUmVzdWx0KSA9PiB7XG4vLyAgICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICAgIGV4cGVjdChldmVudHNbMF0uZXZlbnQubWV0aG9kKS50b0VxdWFsKCdUcmFuc2ZlcnJlZCcpO1xuLy8gICAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5zZWN0aW9uKS50b0VxdWFsKCdnZW5lcmljQXNzZXQnKTtcbi8vICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgfSk7XG4vL1xuLy8gICBkZXNjcmliZSgnRXRoIHNpZ25pbmluZyB0eHMnLCAoKSA9PiB7XG4vL1xuLy8gICAgIGl0KCdDb252ZXJ0IGV0aCBhZGRyZXNzIHRvIGNlbm56bmV0IGFkZHJlc3MnLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgIGNvbnN0IGV0aEFkZHJlc3MgPSAnMHg1RDU1ODYzNDFjYTcyMTQ2NzkxQzMzYzI2YzBjMTBlRDk3MWM5QjUzJztcbi8vICAgICAgIGNvbnN0IGNlbm56bmV0QWRkcmVzcyA9IGN2bVRvQWRkcmVzcyhldGhBZGRyZXNzKTtcbi8vICAgICAgIGNvbnNvbGUubG9nKCdjZW5uem5ldEFkZHJlc3M6JyxjZW5uem5ldEFkZHJlc3MpO1xuLy8gICAgICAgZXhwZWN0KGNlbm56bmV0QWRkcmVzcykudG9FcXVhbCgnNUVLN240cGEzRmNDR294dm9xVUZKTThDRDZmbmdFMzFHNHJBanFMWVcyYlh0c3RuJyk7XG4vLyAgICAgICBkb25lKCk7XG4vLyAgICAgfSk7XG4vL1xuLy8gICAgIGl0KCdVc2VzIGV0aCB3YWxsZXQgdG8gc2lnbicsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3QgZXRoQWRkcmVzcyA9ICcweDVkNTU4NjM0MWNhNzIxNDY3OTFjMzNjMjZjMGMxMGVkOTcxYzliNTMnO1xuLy8gICAgICAgLy8gRmluZCB0aGUgZXF1aXZhbGVudCBDRU5OWm5ldCBhZGRyZXNzIGZvciBFdGhlcmV1bSBhZGRyZXNzIGFuZCBzZW5kIHNvbWUgQ1BBWSB0byBzcGVuZCBvbiB0eHNcbi8vICAgICAgIGNvbnN0IGNlbm56bmV0QWRkcmVzcyA9IGN2bVRvQWRkcmVzcyhldGhBZGRyZXNzKTtcbi8vICAgICAgIGNvbnN0IGFtb3VudCA9IDEwMDAwMDtcbi8vICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgYXBpLnJwYy5zeXN0ZW0uYWNjb3VudE5leHRJbmRleChhbGljZS5hZGRyZXNzKTtcbi8vICAgICAgIGNvbnN0IGZ1bmRUcmFuc2ZlcnJlZCA9IG5ldyBQcm9taXNlPHZvaWQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbi8vICAgICAgICAgYXdhaXQgYXBpLnR4LmdlbmVyaWNBc3NldFxuLy8gICAgICAgICAgICAgLnRyYW5zZmVyKHN0YWtpbmdBc3NldElkLCBjZW5uem5ldEFkZHJlc3MsIGFtb3VudClcbi8vICAgICAgICAgICAgIC5zaWduQW5kU2VuZChcbi8vICAgICAgICAgICAgICAgICBhbGljZSxcbi8vICAgICAgICAgICAgICAgICB7IG5vbmNlIH0pO1xuLy8gICAgICAgICBhd2FpdCBhcGkudHguZ2VuZXJpY0Fzc2V0XG4vLyAgICAgICAgICAgICAudHJhbnNmZXIoc3BlbmRpbmdBc3NldElkLCBjZW5uem5ldEFkZHJlc3MsIGFtb3VudClcbi8vICAgICAgICAgICAgIC5zaWduQW5kU2VuZChcbi8vICAgICAgICAgICAgICAgICBhbGljZSxcbi8vICAgICAgICAgICAgICAgICB7IG5vbmNlOiBub25jZSsxIH0sICh7IHN0YXR1cyB9KSA9PiBzdGF0dXMuaXNJbkJsb2NrID8gcmVzb2x2ZSgpIDogbnVsbFxuLy8gICAgICAgICAgICAgKTtcbi8vICAgICAgIH0pO1xuLy8gICAgICAgZnVuZFRyYW5zZmVycmVkLnRoZW4oYXN5bmMgKCkgPT4ge1xuLy8gICAgICAgICAvLyBTdGFydCB3aXRoIGEgY29ubmVjdGVkIHdhbGxldFxuLy8gICAgICAgICBjb25zdCBhY2NvdW50cyA9IFtldGhBZGRyZXNzXTtcbi8vICAgICAgICAgbW9jayh7XG4vLyAgICAgICAgICAgYmxvY2tjaGFpbjogJ2V0aGVyZXVtJyxcbi8vICAgICAgICAgICBhY2NvdW50czoge3JldHVybjogYWNjb3VudHN9LFxuLy8gICAgICAgICAgIHNpZ25hdHVyZToge1xuLy8gICAgICAgICAgICAgcGFyYW1zOiBbYWNjb3VudHNbMF0sICdzaWduJ10sXG4vLyAgICAgICAgICAgICByZXR1cm46IFwiMHhjOGVlMTM5MGJjMDU0NzliYjRlMTNlYjM2YjQ2NzE0YWYxOTgyMWViNTkwMTQyZTNmOGZiN2Q5NzJmNmYzMWZiMDcwNzE3YmU5NjBlNDFlNGVjMzNiYWY4NTc3NmM0M2U1YmU1ODg5MTZlN2M0MWVlMjBhZDk5YzY2OTVmYTdmYTFiXCJcbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy9cbi8vXG4vLyAgICAgICAgIGNvbnN0IHRyYW5zZmVyQW10ID0gMjAwMDA7XG4vLyAgICAgICAgIGF3YWl0IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgICAgIC50cmFuc2ZlcihzdGFraW5nQXNzZXRJZCwgYWxpY2UuYWRkcmVzcywgdHJhbnNmZXJBbXQpXG4vLyAgICAgICAgICAgICAuc2lnblZpYUV0aFdhbGxldChcbi8vICAgICAgICAgICAgICAgICBldGhBZGRyZXNzLFxuLy8gICAgICAgICAgICAgICAgIGFwaSxcbi8vICAgICAgICAgICAgICAgICAoZ2xvYmFsIGFzIGFueSkuZXRoZXJldW0sICBhc3luYyAoeyBldmVudHMsIHN0YXR1cyB9OiBTdWJtaXR0YWJsZVJlc3VsdCkgPT4ge1xuLy8gICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGV2ZW50c1swXS5ldmVudC5tZXRob2QpLnRvRXF1YWwoJ1RyYW5zZmVycmVkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChldmVudHNbMF0uZXZlbnQuc2VjdGlvbikudG9FcXVhbCgnZ2VuZXJpY0Fzc2V0Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICApO1xuLy8gICAgICAgfSk7XG4vLyAgICAgfSk7XG4vLyAgIH0pO1xuLy9cbi8vICAgZGVzY3JpYmUoJ0V4dHJpbnNpYyBwYXltZW50IG9wdGlvbnMnLCAoKSA9PiB7XG4vLyAgICAgLy8gQSBnZW5lcmljIGFzc2V0IHRvIGJlIHVzZWQgZm9yIGZlZSBwYXltZW50XG4vLyAgICAgbGV0IGZlZUFzc2V0SWQ7XG4vLyAgICAgLy8gVGhpcyBhY2NvdW50IHdpbGwgb3duIHRoZSBuZXdseSBjcmVhdGVkIGFzc2V0IGFuZCByZWNlaXZlIGluaXRpYWwgaXNzdWFuY2Vcbi8vICAgICAvLyBJdCB3aWxsIGFsc28gbWludCBsaXF1aWRpdHkgb24gQ0VOTlotWFxuLy8gICAgIGxldCBhc3NldE93bmVyOiBLZXlyaW5nUGFpcjtcbi8vXG4vLyAgICAgYmVmb3JlQWxsKGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgLy8gU2V0dXA6XG4vLyAgICAgICAvLyBDcmVhdGUgYSBuZXcgZ2VuZXJpYyBhc3NldCBhbmQgbWludCBhIGxpcXVpZGl0eSBwb29sIG9uIENFTk5aWC5cbi8vICAgICAgIC8vIFRoaXMgZmVlIGFzc2V0IHdpbGwgYmUgdXNlZCBmb3IgZmVlIHBheW1lbnQgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgYXNzZXQsIENQQVkuXG4vLyAgICAgICBhc3NldE93bmVyID0ga2V5cmluZy5hZGRGcm9tVXJpKCcvL1Rlc3QvL0Fzc2V0T3duZXInKTtcbi8vXG4vLyAgICAgICAvLyBBbW91bnQgb2YgdGVzdCBhc3NldCB0byBjcmVhdGVcbi8vICAgICAgIGNvbnN0IGluaXRpYWxJc3N1YW5jZSA9IDkwMF8wMDBfMDAwXzAwMF8wMDA7XG4vLyAgICAgICBjb25zdCBvd25lciA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdPd25lcicsIGFzc2V0T3duZXIuYWRkcmVzcywgMSk7IC8vIE93bmVyIHR5cGUgaXMgZW51bSB3aXRoIDAgYXMgbm9uZS9udWxsXG4vLyAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdQZXJtaXNzaW9uc1YxJywgeyB1cGRhdGU6IG93bmVyLCBtaW50OiBvd25lciwgYnVybjogb3duZXJ9KTtcbi8vICAgICAgIGNvbnN0IG9wdGlvbiA9IHtpbml0aWFsSXNzdWFuY2UgLCBwZXJtaXNzaW9uc307XG4vLyAgICAgICBjb25zdCBhc3NldE9wdGlvbjogQXNzZXRPcHRpb25zID0gYXBpLnJlZ2lzdHJ5LmNyZWF0ZVR5cGUoJ0Fzc2V0T3B0aW9ucycsIG9wdGlvbik7XG4vLyAgICAgICBjb25zdCBhc3NldEluZm86IEFzc2V0SW5mbyA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdBc3NldEluZm8nLCB7c3ltYm9sOiAnVEVTVCcsIGRlY2ltYWxQbGFjZXM6IDQsIGV4aXN0ZW50aWFsRGVwb3NpdDogNX0pO1xuLy8gICAgICAgbGV0IGNyZWF0ZUFzc2V0VHggPSBhcGkudHguZ2VuZXJpY0Fzc2V0LmNyZWF0ZShhc3NldE93bmVyLmFkZHJlc3MsIGFzc2V0T3B0aW9uLCBhc3NldEluZm8pO1xuLy9cbi8vICAgICAgIC8vIExvb2t1cCBmcm9tIGtleXJpbmcgKGFzc3VtaW5nIHdlIGhhdmUgYWRkZWQgYWxsLCBvbiAtLWRldiB0aGlzIHdvdWxkIGJlIGAvL0FsaWNlYClcbi8vICAgICAgIGNvbnN0IHN1ZG9BZGRyZXNzID0gYXdhaXQgYXBpLnF1ZXJ5LnN1ZG8ua2V5KCk7XG4vLyAgICAgICBjb25zdCBzdWRvS2V5cGFpciA9IGtleXJpbmcuZ2V0UGFpcihzdWRvQWRkcmVzcy50b1N0cmluZygpKTtcbi8vXG4vLyAgICAgICAvLyB3aGVuIHRoZSBuZXcgYXNzZXQgaXMgY3JlYXRlZCBpdCB3aWxsIGhhdmUgdGhpcyBJRC5cbi8vICAgICAgIGZlZUFzc2V0SWQgPSBhd2FpdCBhcGkucXVlcnkuZ2VuZXJpY0Fzc2V0Lm5leHRBc3NldElkKCk7XG4vL1xuLy8gICAgICAgLy8gMSkgQ3JlYXRlIHRoZSBuZXcgZmVlIGFzc2V0XG4vLyAgICAgICAvLyAyKSBNaW50IENQQVkgdG8gYXNzZXRPd25lciB0byBmdW5kIHN1YnNlcXVlbnQgcG9vbCBsaXF1aWRpdHkgYW5kIGZ1cnRoZXIgdHJhbnNhY3Rpb25zLlxuLy8gICAgICAgY29uc3QgYXNzZXRDcmVhdGVkID0gbmV3IFByb21pc2U8dm9pZD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuLy8gICAgICAgICBsZXQgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KHN1ZG9BZGRyZXNzKTtcbi8vICAgICAgICAgYXdhaXQgYXBpLnR4LnN1ZG8uc3VkbyhjcmVhdGVBc3NldFR4KS5zaWduQW5kU2VuZChzdWRvS2V5cGFpciwgeyBub25jZTogbm9uY2UrKyB9KTtcbi8vICAgICAgICAgYXdhaXQgYXBpLnR4LmdlbmVyaWNBc3NldC5taW50KHNwZW5kaW5nQXNzZXRJZCwgYXNzZXRPd25lci5hZGRyZXNzLCBpbml0aWFsSXNzdWFuY2UpLnNpZ25BbmRTZW5kKFxuLy8gICAgICAgICAgIHN1ZG9LZXlwYWlyLCB7IG5vbmNlOiBub25jZSsrIH0sICh7IHN0YXR1cyB9KSA9PiBzdGF0dXMuaXNJbkJsb2NrID8gcmVzb2x2ZSgpIDogbnVsbFxuLy8gICAgICAgICApO1xuLy8gICAgICAgfSk7XG4vL1xuLy8gICAgICAgLy8gMykgTWludCBsaXF1aWRpdHkgZm9yIGZlZSBhc3NldCA8PiBDUEFZLlxuLy8gICAgICAgYXNzZXRDcmVhdGVkLnRoZW4oYXN5bmMgKCkgPT4ge1xuLy8gICAgICAgICBjb25zdCBkZXNpcmVkTGlxdWlkaXR5ID0gMzBfMDAwXzAwMDtcbi8vICAgICAgICAgY29uc3QgbWluaW11bUxpcXVpZGl0eSA9IDE7XG4vLyAgICAgICAgIGNvbnN0IGxpcXVpZGl0eVByaWNlOiBMaXF1aWRpdHlQcmljZVJlc3BvbnNlID0gYXdhaXQgKGFwaS5ycGMuY2Vubnp4LmxpcXVpZGl0eVByaWNlKGZlZUFzc2V0SWQsIGRlc2lyZWRMaXF1aWRpdHkpKTtcbi8vICAgICAgICAgYXdhaXQgYXBpLnR4LmNlbm56eFxuLy8gICAgICAgICAgIC5hZGRMaXF1aWRpdHkoZmVlQXNzZXRJZCwgbWluaW11bUxpcXVpZGl0eSwgbGlxdWlkaXR5UHJpY2UuYXNzZXQsIGxpcXVpZGl0eVByaWNlLmNvcmUpXG4vLyAgICAgICAgICAgLnNpZ25BbmRTZW5kKGFzc2V0T3duZXIsICh7IGV2ZW50cywgc3RhdHVzIH0pID0+IHN0YXR1cy5pc0luQmxvY2sgPyBkb25lKCkgOm51bGwgKTtcbi8vXG4vLyAgICAgICB9KTtcbi8vXG4vLyAgICAgfSk7XG4vL1xuLy8gICAgIGl0KCdVc2VzIGtleXBhaXIgdG8gc2lnbicsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGFzc2V0T3duZXIuYWRkcmVzcyk7XG4vLyAgICAgICBhd2FpdCBhcGkudHguZ2VuZXJpY0Fzc2V0XG4vLyAgICAgICAgIC50cmFuc2ZlcihzcGVuZGluZ0Fzc2V0SWQsIGJvYi5hZGRyZXNzLCAxMDApXG4vLyAgICAgICAgIC5zZXRQYXltZW50T3B0cyhhcGksIHtmZWVBc3NldElkOiBmZWVBc3NldElkLCBzbGlwcGFnZTogMCwgdGlwOiAwfSlcbi8vICAgICAgICAgLnNpZ25BbmRTZW5kKFxuLy8gICAgICAgICAgIGFzc2V0T3duZXIsXG4vLyAgICAgICAgICAgeyBub25jZSB9LFxuLy8gICAgICAgICAgICh7IHN0YXR1cyB9KSA9PiBzdGF0dXMuaXNJbkJsb2NrID8gZG9uZSgpIDogbnVsbFxuLy8gICAgICAgICApO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICBpdCgnVXNlIHRpcCBhbG9uZyB3aXRoIGZlZSBleGNoYW5nZScsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGFzc2V0T3duZXIuYWRkcmVzcyk7XG4vLyAgICAgICBhd2FpdCBhcGkudHguZ2VuZXJpY0Fzc2V0XG4vLyAgICAgICAgIC50cmFuc2ZlcihzcGVuZGluZ0Fzc2V0SWQsIGJvYi5hZGRyZXNzLCAxMDApXG4vLyAgICAgICAgIC5zZXRQYXltZW50T3B0cyhhcGksIHsgZmVlQXNzZXRJZDogZmVlQXNzZXRJZCwgc2xpcHBhZ2U6IDAsIHRpcDogMn0pXG4vLyAgICAgICAgIC5zaWduQW5kU2VuZChcbi8vICAgICAgICAgICBhc3NldE93bmVyLFxuLy8gICAgICAgICAgIHsgbm9uY2UgfSxcbi8vICAgICAgICAgICAoeyBzdGF0dXMgfSkgPT4gKHN0YXR1cy5pc0luQmxvY2spID8gZG9uZSgpIDogbnVsbFxuLy8gICAgICAgKTtcbi8vICAgICB9KTtcbi8vXG4vLyAgICAgaXQoJ1VzZSBzbGlwcGFnZSBmb3IgbWF4IHBheW1lbnQgaW4gdHJhbnNhY3Rpb24nLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgYXBpLnJwYy5zeXN0ZW0uYWNjb3VudE5leHRJbmRleChhc3NldE93bmVyLmFkZHJlc3MpO1xuLy8gICAgICAgYXdhaXQgYXBpLnR4LmdlbmVyaWNBc3NldFxuLy8gICAgICAgICAudHJhbnNmZXIoc3BlbmRpbmdBc3NldElkLCBib2IuYWRkcmVzcywgMTAwKVxuLy8gICAgICAgICAuc2V0UGF5bWVudE9wdHMoYXBpLCB7IGZlZUFzc2V0SWQ6IGZlZUFzc2V0SWQsIHNsaXBwYWdlOiAwLjAzfSlcbi8vICAgICAgICAgLnNpZ25BbmRTZW5kKFxuLy8gICAgICAgICAgIGFzc2V0T3duZXIsXG4vLyAgICAgICAgICAgeyBub25jZSB9LFxuLy8gICAgICAgICAgICh7IHN0YXR1cyB9KSA9PiAoc3RhdHVzLmlzSW5CbG9jaykgPyBkb25lKCkgOiBudWxsXG4vLyAgICAgICAgICk7XG4vLyAgICAgfSk7XG4vL1xuLy8gICAgIGl0KCdVcGRhdGUgYXNzZXQgaW5mbycsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBhcGkucnBjLnN5c3RlbS5hY2NvdW50TmV4dEluZGV4KGFzc2V0T3duZXIuYWRkcmVzcyk7XG4vLyAgICAgICBjb25zdCBhc3NldEluZm86IEFzc2V0SW5mbyA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdBc3NldEluZm8nLCB7c3ltYm9sOiAnTkVXX0FTU0VUX0lEJywgZGVjaW1hbFBsYWNlczogNSwgZXhpc3RlbnRpYWxEZXBvc2l0OiA1fSk7XG4vLyAgICAgICBhd2FpdCBhcGkudHguZ2VuZXJpY0Fzc2V0LnVwZGF0ZUFzc2V0SW5mbyggZmVlQXNzZXRJZCwgYXNzZXRJbmZvKS5zaWduQW5kU2VuZChhc3NldE93bmVyLCB7IG5vbmNlIH0sIGFzeW5jICh7IGV2ZW50cywgc3RhdHVzIH0pID0+IHtcbi8vICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICBmb3IgKGNvbnN0IHsgZXZlbnQ6IHsgbWV0aG9kLCBzZWN0aW9uLCBkYXRhIH0gfSBvZiBldmVudHMpIHtcbi8vICAgICAgICAgICAgIGlmIChzZWN0aW9uID09PSAnZ2VuZXJpY0Fzc2V0JyAmJiBtZXRob2QgPT0gJ0Fzc2V0SW5mb1VwZGF0ZWQnKSB7XG4vLyAgICAgICAgICAgICAgIGNvbnN0IFthc3NldElkLCBhc3NldE1ldGFdID0gZGF0YTtcbi8vICAgICAgICAgICAgICAgZXhwZWN0KGFzc2V0SWQgYXMgbnVtYmVyKS50b0VxdWFsKGZlZUFzc2V0SWQpO1xuLy8gICAgICAgICAgICAgICBleHBlY3QoYXNzZXRNZXRhLnRvSlNPTigpKS50b0VxdWFsKHtcbi8vICAgICAgICAgICAgICAgICBleGlzdGVudGlhbERlcG9zaXQ6IDUsXG4vLyAgICAgICAgICAgICAgICAgZGVjaW1hbFBsYWNlczogNSxcbi8vICAgICAgICAgICAgICAgICBzeW1ib2w6IHN0cmluZ1RvSGV4KCdORVdfQVNTRVRfSUQnKVxuLy8gICAgICAgICAgICAgICB9KTtcbi8vXG4vLyAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy8gICB9KTtcbi8vXG4vL1xuLy8gICBkZXNjcmliZSgnU2lnbmVkIHZpYSBzaWduZXInLCAoKSA9PiB7XG4vLyAgICAgaXQoJ3Nob3VsZCBzaWduIHdpdGggYSBzaWduZXInLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgIGNvbnN0IGRhdmUgPSBrZXlyaW5nLmFkZEZyb21VcmkoJy8vRGF2ZScpO1xuLy8gICAgICAgY29uc3Qgc2lnbmVyID0gbmV3IFNpbmdsZUFjY291bnRTaWduZXIoYXBpLnJlZ2lzdHJ5LCBkYXZlKTtcbi8vICAgICAgIGNvbnN0IHRyYW5zZmVyID0gYXBpLnR4LmdlbmVyaWNBc3NldC50cmFuc2ZlcihzcGVuZGluZ0Fzc2V0SWQsIGFsaWNlLmFkZHJlc3MsIDU0MTIxKTtcbi8vICAgICAgIGF3YWl0IHRyYW5zZmVyLnNpZ25BbmRTZW5kKGRhdmUuYWRkcmVzcywgeyBzaWduZXIgfSwgYXN5bmMgKHtldmVudHMsIHN0YXR1c30pID0+IHtcbi8vICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICBmb3IgKGNvbnN0IHtldmVudDogeyBtZXRob2QsIHNlY3Rpb24gfSB9IG9mIGV2ZW50cykge1xuLy8gICAgICAgICAgICAgaWYgKHNlY3Rpb24gPT09ICdnZW5lcmljQXNzZXQnICYmIG1ldGhvZCA9PSAnVHJhbnNmZXJyZWQnKSB7XG4vLyAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy8gICB9KTtcbi8vXG4vLyB9KTtcbiJdLCJ2ZXJzaW9uIjozfQ==