{"file":"/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/nft.e2e.ts","mappings":";AAAA,wDAAwD;AACxD,KAAK;AACL,qEAAqE;AACrE,sEAAsE;AACtE,6CAA6C;AAC7C,KAAK;AACL,oDAAoD;AACpD,KAAK;AACL,yEAAyE;AACzE,uEAAuE;AACvE,8EAA8E;AAC9E,yEAAyE;AACzE,oCAAoC;AACpC,EAAE;AACF,uCAAuC;AACvC,+CAA+C;AAC/C,2DAA2D;AAC3D,0DAA0D;AAC1D,EAAE;AACF,gEAAgE;AAChE,oEAAoE;AACpE,sFAAsF;AACtF,EAAE;AACF,gBAAgB;AAChB,oDAAoD;AACpD,aAAa;AACb,mCAAmC;AACnC,uBAAuB;AACvB,0BAA0B;AAC1B,sBAAsB;AACtB,EAAE;AACF,4BAA4B;AAC5B,6BAA6B;AAC7B,kCAAkC;AAClC,qBAAqB;AACrB,2CAA2C;AAC3C,EAAE;AACF,qEAAqE;AACrE,2DAA2D;AAC3D,qBAAqB;AACrB,mFAAmF;AACnF,0CAA0C;AAC1C,EAAE;AACF,iCAAiC;AACjC,4BAA4B;AAC5B,yEAAyE;AACzE,4BAA4B;AAC5B,oEAAoE;AACpE,6EAA6E;AAC7E,EAAE;AACF,MAAM;AACN,EAAE;AACF,yBAAyB;AACzB,4BAA4B;AAC5B,MAAM;AACN,EAAE;AACF,2BAA2B;AAC3B,qDAAqD;AACrD,EAAE;AACF,+BAA+B;AAC/B,2DAA2D;AAC3D,wDAAwD;AACxD,wBAAwB;AACxB,4CAA4C;AAC5C,kEAAkE;AAClE,yCAAyC;AACzC,wBAAwB;AACxB,cAAc;AACd,qEAAqE;AACrE,gCAAgC;AAChC,yDAAyD;AACzD,gDAAgD;AAChD,uDAAuD;AACvD,cAAc;AACd,cAAc;AACd,EAAE;AACF,4GAA4G;AAC5G,0EAA0E;AAC1E,sCAAsC;AACtC,iEAAiE;AACjE,kDAAkD;AAClD,4DAA4D;AAC5D,uDAAuD;AACvD,qHAAqH;AACrH,4BAA4B;AAC5B,oBAAoB;AACpB,oBAAoB;AACpB,gBAAgB;AAChB,gBAAgB;AAChB,UAAU;AACV,UAAU;AACV,OAAO;AACP,EAAE;AACF,+CAA+C;AAC/C,iDAAiD;AACjD,sCAAsC;AACtC,yCAAyC;AACzC,wBAAwB;AACxB,2BAA2B;AAC3B,qEAAqE;AACrE,gCAAgC;AAChC,wEAAwE;AACxE,4FAA4F;AAC5F,gDAAgD;AAChD,iDAAiD;AACjD,8DAA8D;AAC9D,cAAc;AACd,cAAc;AACd,gHAAgH;AAChH,mHAAmH;AACnH,kBAAkB;AAClB,UAAU;AACV,UAAU;AACV,QAAQ;AACR,EAAE;AACF,qDAAqD;AACrD,0CAA0C;AAC1C,sCAAsC;AACtC,yCAAyC;AACzC,wBAAwB;AACxB,0BAA0B;AAC1B,qEAAqE;AACrE,gCAAgC;AAChC,wEAAwE;AACxE,4FAA4F;AAC5F,gDAAgD;AAChD,kDAAkD;AAClD,sEAAsE;AACtE,cAAc;AACd,cAAc;AACd,iHAAiH;AACjH,oHAAoH;AACpH,kBAAkB;AAClB,UAAU;AACV,UAAU;AACV,QAAQ;AACR,EAAE;AACF,0CAA0C;AAC1C,mEAAmE;AACnE,6DAA6D;AAC7D,iDAAiD;AACjD,UAAU;AACV,iBAAiB;AACjB,4CAA4C;AAC5C,WAAW;AACX,UAAU;AACV,iBAAiB;AACjB,sCAAsC;AACtC,WAAW;AACX,UAAU;AACV,aAAa;AACb,QAAQ;AACR,EAAE;AACF,0CAA0C;AAC1C,mBAAmB;AACnB,0BAA0B;AAC1B,kEAAkE;AAClE,sEAAsE;AACtE,oGAAoG;AACpG,gCAAgC;AAChC,0DAA0D;AAC1D,2CAA2C;AAC3C,iCAAiC;AACjC,oDAAoD;AACpD,cAAc;AACd,cAAc;AACd,EAAE;AACF,qEAAqE;AACrE,8BAA8B;AAC9B,cAAc;AACd,yCAAyC;AACzC,uBAAuB;AACvB,+EAA+E;AAC/E,cAAc;AACd,aAAa;AACb,EAAE;AACF,kBAAkB;AAClB,UAAU;AACV,UAAU;AACV,QAAQ;AACR,EAAE;AACF,+DAA+D;AAC/D,oBAAoB;AACpB,wBAAwB;AACxB,kEAAkE;AAClE,EAAE;AACF,uBAAuB;AACvB,kFAAkF;AAClF,oEAAoE;AACpE,gCAAgC;AAChC,0DAA0D;AAC1D,4CAA4C;AAC5C,kCAAkC;AAClC,sDAAsD;AACtD,cAAc;AACd,cAAc;AACd,EAAE;AACF,6EAA6E;AAC7E,gCAAgC;AAChC,mGAAmG;AACnG,qEAAqE;AACrE,8BAA8B;AAC9B,cAAc;AACd,yCAAyC;AACzC,uBAAuB;AACvB,+EAA+E;AAC/E,cAAc;AACd,aAAa;AACb,EAAE;AACF,kBAAkB;AAClB,UAAU;AACV,UAAU;AACV,QAAQ;AACR,EAAE;AACF,qEAAqE;AACrE,oBAAoB;AACpB,wBAAwB;AACxB,mEAAmE;AACnE,EAAE;AACF,uBAAuB;AACvB,qFAAqF;AACrF,sEAAsE;AACtE,kCAAkC;AAClC,4DAA4D;AAC5D,8CAA8C;AAC9C,oCAAoC;AACpC,wDAAwD;AACxD,gBAAgB;AAChB,gBAAgB;AAChB,EAAE;AACF,+EAA+E;AAC/E,kCAAkC;AAClC,sGAAsG;AACtG,uEAAuE;AACvE,gCAAgC;AAChC,gBAAgB;AAChB,2CAA2C;AAC3C,yBAAyB;AACzB,iFAAiF;AACjF,gBAAgB;AAChB,eAAe;AACf,EAAE;AACF,oBAAoB;AACpB,YAAY;AACZ,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,+DAA+D;AAC/D,wBAAwB;AACxB,wBAAwB;AACxB,sEAAsE;AACtE,EAAE;AACF,uBAAuB;AACvB,oFAAoF;AACpF,sEAAsE;AACtE,kCAAkC;AAClC,4DAA4D;AAC5D,8CAA8C;AAC9C,oCAAoC;AACpC,wDAAwD;AACxD,gBAAgB;AAChB,gBAAgB;AAChB,EAAE;AACF,+EAA+E;AAC/E,kCAAkC;AAClC,sGAAsG;AACtG,uEAAuE;AACvE,gCAAgC;AAChC,gBAAgB;AAChB,2CAA2C;AAC3C,yBAAyB;AACzB,iFAAiF;AACjF,gBAAgB;AAChB,eAAe;AACf,mDAAmD;AACnD,oBAAoB;AACpB,YAAY;AACZ,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,wDAAwD;AACxD,0BAA0B;AAC1B,8BAA8B;AAC9B,8DAA8D;AAC9D,EAAE;AACF,yEAAyE;AACzE,iEAAiE;AACjE,kCAAkC;AAClC,0DAA0D;AAC1D,sCAAsC;AACtC,yDAAyD;AACzD,iEAAiE;AACjE,0DAA0D;AAC1D,mEAAmE;AACnE,wBAAwB;AACxB,gBAAgB;AAChB,gBAAgB;AAChB,YAAY;AACZ,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,kDAAkD;AAClD,gHAAgH;AAChH,kJAAkJ;AAClJ,kJAAkJ;AAClJ,iDAAiD;AACjD,iDAAiD;AACjD,cAAc;AACd,QAAQ;AACR,EAAE;AACF,sEAAsE;AACtE,8EAA8E;AAC9E,uFAAuF;AACvF,4CAA4C;AAC5C,qGAAqG;AACrG,cAAc;AACd,QAAQ;AACR,EAAE;AACF,+FAA+F;AAC/F,+FAA+F;AAC/F,qDAAqD;AACrD,+DAA+D;AAC/D,oDAAoD;AACpD,uDAAuD;AACvD,SAAS;AACT,6DAA6D;AAC7D,EAAE;AACF,wDAAwD;AACxD,+DAA+D;AAC/D,mDAAmD;AACnD,uDAAuD;AACvD,SAAS;AACT,gEAAgE;AAChE,EAAE;AACF,wDAAwD;AACxD,+DAA+D;AAC/D,oDAAoD;AACpD,uDAAuD;AACvD,SAAS;AACT,kDAAkD;AAClD,EAAE;AACF,wDAAwD;AACxD,+DAA+D;AAC/D,oDAAoD;AACpD,uDAAuD;AACvD,SAAS;AACT,gEAAgE;AAChE,EAAE;AACF,QAAQ;AACR,EAAE;AACF,+CAA+C;AAC/C,+FAA+F;AAC/F,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD,QAAQ;AACR,EAAE;AACF,iEAAiE;AACjE,4DAA4D;AAC5D,4CAA4C;AAC5C,2BAA2B;AAC3B,6DAA6D;AAC7D,qEAAqE;AACrE,2DAA2D;AAC3D,kCAAkC;AAClC,uBAAuB;AACvB,yGAAyG;AACzG,yDAAyD;AACzD,oCAAoC;AACpC,kGAAkG;AAClG,iGAAiG;AACjG,EAAE;AACF,gEAAgE;AAChE,iDAAiD;AACjD,qCAAqC;AACrC,uCAAuC;AACvC,wCAAwC;AACxC,iDAAiD;AACjD,8CAA8C;AAC9C,0BAA0B;AAC1B,2DAA2D;AAC3D,oBAAoB;AACpB,EAAE;AACF,sBAAsB;AACtB,cAAc;AACd,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,uDAAuD;AACvD,mDAAmD;AACnD,2BAA2B;AAC3B,yEAAyE;AACzE,2DAA2D;AAC3D,kCAAkC;AAClC,EAAE;AACF,uBAAuB;AACvB,2FAA2F;AAC3F,yDAAyD;AACzD,kCAAkC;AAClC,+FAA+F;AAC/F,gGAAgG;AAChG,wFAAwF;AACxF,wFAAwF;AACxF,qFAAqF;AACrF,qFAAqF;AACrF,iFAAiF;AACjF,gGAAgG;AAChG,EAAE;AACF,oBAAoB;AACpB,YAAY;AACZ,UAAU;AACV,SAAS;AACT,EAAE;AACF,QAAQ;AACR,EAAE;AACF,2DAA2D;AAC3D,uCAAuC;AACvC,6BAA6B;AAC7B,oCAAoC;AACpC,qCAAqC;AACrC,kCAAkC;AAClC,iFAAiF;AACjF,8FAA8F;AAC9F,yDAAyD;AACzD,kCAAkC;AAClC,wGAAwG;AACxG,+DAA+D;AAC/D,wCAAwC;AACxC,qGAAqG;AACrG,kGAAkG;AAClG,oDAAoD;AACpD,6CAA6C;AAC7C,sBAAsB;AACtB,kFAAkF;AAClF,0EAA0E;AAC1E,kFAAkF;AAClF,uBAAuB;AACvB,sBAAsB;AACtB,kFAAkF;AAClF,0EAA0E;AAC1E,kFAAkF;AAClF,uBAAuB;AACvB,oBAAoB;AACpB,gDAAgD;AAChD,8FAA8F;AAC9F,qDAAqD;AACrD,sBAAsB;AACtB,wDAAwD;AACxD,mCAAmC;AACnC,uCAAuC;AACvC,uBAAuB;AACvB,sBAAsB;AACtB,wDAAwD;AACxD,mCAAmC;AACnC,uCAAuC;AACvC,sBAAsB;AACtB,sBAAsB;AACtB,kEAAkE;AAClE,kIAAkI;AAClI,kFAAkF;AAClF,wEAAwE;AACxE,4EAA4E;AAC5E,qDAAqD;AACrD,oEAAoE;AACpE,gEAAgE;AAChE,mEAAmE;AACnE,sBAAsB;AACtB,oBAAoB;AACpB,0BAA0B;AAC1B,kBAAkB;AAClB,iBAAiB;AACjB,YAAY;AACZ,WAAW;AACX,QAAQ;AACR,EAAE;AACF,EAAE;AACF,+DAA+D;AAC/D,6EAA6E;AAC7E,wCAAwC;AACxC,gDAAgD;AAChD,qEAAqE;AACrE,sHAAsH;AACtH,gDAAgD;AAChD,qEAAqE;AACrE,sHAAsH;AACtH,cAAc;AACd,QAAQ;AACR,EAAE;AACF,0EAA0E;AAC1E,6EAA6E;AAC7E,qCAAqC;AACrC,gBAAgB;AAChB,QAAQ;AACR,EAAE;AACF,+DAA+D;AAC/D,2DAA2D;AAC3D,0EAA0E;AAC1E,yDAAyD;AACzD,6DAA6D;AAC7D,uEAAuE;AACvE,8BAA8B;AAC9B,cAAc;AACd,QAAQ;AACR,EAAE;AACF,EAAE;AACF,6EAA6E;AAC7E,gEAAgE;AAChE,yDAAyD;AACzD,EAAE;AACF,iGAAiG;AACjG,EAAE;AACF,2FAA2F;AAC3F,EAAE;AACF,kGAAkG;AAClG,4FAA4F;AAC5F,EAAE;AACF,8BAA8B;AAC9B,cAAc;AACd,EAAE;AACF,QAAQ;AACR,EAAE;AACF,8DAA8D;AAC9D,wDAAwD;AACxD,kEAAkE;AAClE,8FAA8F;AAC9F,8BAA8B;AAC9B,cAAc;AACd,QAAQ;AACR,EAAE;AACF,kDAAkD;AAClD,wDAAwD;AACxD,iEAAiE;AACjE,2FAA2F;AAC3F,+GAA+G;AAC/G,6EAA6E;AAC7E,8EAA8E;AAC9E,6DAA6D;AAC7D,4BAA4B;AAC5B,2UAA2U;AAC3U,oHAAoH;AACpH,2EAA2E;AAC3E,gGAAgG;AAChG,oDAAoD;AACpD,EAAE;AACF,uJAAuJ;AACvJ,qDAAqD;AACrD,EAAE;AACF,iGAAiG;AACjG,2GAA2G;AAC3G,wBAAwB;AACxB,cAAc;AACd,QAAQ;AACR,MAAM","names":[],"sources":["/Users/karishma/work/futureverse/trn-rootnet-api/packages/api/test/e2e/nft.e2e.ts"],"sourcesContent":["// // Copyright 2020-2021 Centrality Investments Limited\n// //\n// // Licensed under the Apache License, Version 2.0 (the \"License\");\n// // you may not use this file except in compliance with the License.\n// // You may obtain a copy of the License at\n// //\n// //     http://www.apache.org/licenses/LICENSE-2.0\n// //\n// // Unless required by applicable law or agreed to in writing, software\n// // distributed under the License is distributed on an \"AS IS\" BASIS,\n// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// // See the License for the specific language governing permissions and\n// // limitations under the License.\n//\n// import { Api } from \"@cennznet/api\";\n// import { Keyring } from '@polkadot/keyring';\n// import { cryptoWaitReady } from '@polkadot/util-crypto';\n// import {stringToHex, u8aToString} from '@polkadot/util'\n//\n// import initApiPromise from '../../../../jest/initApiPromise';\n// import {CollectionInfo, Listing, TokenId} from '@cennznet/types';\n// import { EnhancedTokenId } from '@cennznet/types/interfaces/nft/enhanced-token-id';\n//\n// let api: Api;\n// const keyring = new Keyring({ type: 'sr25519' });\n// let alice;\n// let collectionOwner, tokenOwner;\n// let spendingAssetId;\n// let globalCollectionId;\n// let globalTokenIds;\n//\n// beforeAll(async done => {\n//   await cryptoWaitReady();\n//   api = await initApiPromise();\n//   // alice is sudo\n//   alice = keyring.addFromUri('//Alice');\n//\n//   collectionOwner = keyring.addFromUri('//Test//CollectionOwner');\n//   tokenOwner = keyring.addFromUri('//Test//TokenOwner');\n//   // Fund accounts\n//   spendingAssetId = (await api.query.genericAsset.spendingAssetId()).toNumber();\n//   const initialEndowment = 100_000_000;\n//\n//   await api.tx.utility.batch([\n//       api.tx.genericAsset\n//     .mint(spendingAssetId, collectionOwner.address, initialEndowment),\n//       api.tx.genericAsset\n//     .mint(spendingAssetId, tokenOwner.address, initialEndowment),\n//   ]).signAndSend(alice, ({ status }) => status.isInBlock ? done() : null);\n//\n// });\n//\n// afterAll(async () => {\n//   await api.disconnect();\n// });\n//\n// describe('NFTs', () => {\n//   let collectionId: number, collectionId2: number;\n//\n//   beforeEach(async done => {\n//     // Create collection and series for each test to use\n//     let collectionName = 'global-example-collection';\n//     let quantity = 3;\n//     globalTokenIds = [...Array(quantity)]\n//     const metadataPath = {\"Https\": \"example.com/nft/metadata\" }\n//     await api.tx.nft.createCollection(\n//       collectionName,\n//       null,\n//     ).signAndSend(collectionOwner, async ({ status, events }) => {\n//       if (status.isInBlock) {\n//         events.forEach(({ event: {data, method}}) => {\n//           if (method == 'CreateCollection') {\n//             globalCollectionId = data[0].toNumber();\n//           }\n//         });\n//\n//         await api.tx.nft.mintSeries(globalCollectionId, quantity, tokenOwner.address, metadataPath, null)\n//           .signAndSend(collectionOwner, async ({ status, events }) => {\n//             if (status.isInBlock) {\n//               events.forEach(({ event: { data, method }}) => {\n//                 if (method == 'CreateSeries') {\n//                   const collectionId = data[0].toNumber()\n//                   let seriesId = data[1].toNumber();\n//                   globalTokenIds = globalTokenIds.map((_, serialNumber) => [collectionId, seriesId, serialNumber])\n//                   done();\n//                 }\n//               });\n//             }\n//           });\n//       }\n//     });\n//   })\n//\n//   it('creates a collection', async done => {\n//     let collectionName = 'example-collection';\n//     const royaltiesSchedule = null;\n//     await api.tx.nft.createCollection(\n//       collectionName,\n//       royaltiesSchedule,\n//     ).signAndSend(collectionOwner, async ({ status, events }) => {\n//       if (status.isInBlock) {\n//         events.forEach(({phase, event: {data, method, section}}) => {\n//           console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//           if (method == 'CreateCollection') {\n//             collectionId = data[0].toNumber();\n//             console.log(`got collection: ${collectionId}`);\n//           }\n//         });\n//         expect((await api.query.nft.collectionOwner(collectionId)).toString()).toBe(collectionOwner.address);\n//         expect((await api.query.nft.collectionName(collectionId)).toString()).toBe(stringToHex(collectionName));\n//         done();\n//       }\n//     });\n//   });\n//\n//   it('creates another collection', async done => {\n//     let collectionName = 'Digital Art';\n//     const royaltiesSchedule = null;\n//     await api.tx.nft.createCollection(\n//       collectionName,\n//       royaltiesSchedule\n//     ).signAndSend(collectionOwner, async ({ status, events }) => {\n//       if (status.isInBlock) {\n//         events.forEach(({phase, event: {data, method, section}}) => {\n//           console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toString());\n//           if (method == 'CreateCollection') {\n//             collectionId2 = data[0].toNumber();\n//             console.log(`got second collection: ${collectionId2}`);\n//           }\n//         });\n//         expect((await api.query.nft.collectionOwner(collectionId2)).toString()).toBe(collectionOwner.address);\n//         expect((await api.query.nft.collectionName(collectionId2)).toString()).toBe(stringToHex(collectionName));\n//         done();\n//       }\n//     });\n//   });\n//\n//   it('collection Map ', async done => {\n//     const collectionMap = await api.derive.nft.collectionInfo();\n//     //Ensure collectionMap contains at least the following\n//     expect(collectionMap.slice(0,2)).toEqual([\n//       {\n//         id: 0,\n//         name: 'global-example-collection'\n//       },\n//       {\n//         id: 1,\n//         name: 'example-collection',\n//       },\n//     ]);\n//    done();\n//   });\n//\n//   it('creates a token', async done => {\n//     let tokenId;\n//     const quantity = 1;\n//     const metadataPath = {\"Https\": \"example.com/nft/metadata\" }\n//     await api.tx.nft.mintSeries(collectionId, quantity, tokenOwner.\n//         address, metadataPath, null).signAndSend(collectionOwner, async ({ status, events }) => {\n//       if (status.isInBlock) {\n//         events.forEach(({ event: {data, method }}) => {\n//           if (method == 'CreateToken') {\n//             tokenId = data[1];\n//             console.log(`got token: ${tokenId}`);\n//           }\n//         });\n//\n//         let tokenInfo = (await api.derive.nft.tokenInfo(tokenId));\n//         expect(tokenInfo ==\n//           {\n//             owner: tokenOwner.address,\n//             tokenId,\n//             attributes: api.registry.createType('Vec<NFTAttributeValue>',[])\n//           }\n//         );\n//\n//         done();\n//       }\n//     });\n//   });\n//\n//   it('creates a series in first collection', async done => {\n//     let seriesId;\n//     let quantity = 3;\n//     const metadataPath = {\"Https\": \"example.com/nft/metadata\" }\n//\n//     await api.tx.nft\n//     .mintSeries(collectionId, quantity, tokenOwner.address, metadataPath, null)\n//     .signAndSend(collectionOwner, async ({ status, events }) => {\n//       if (status.isInBlock) {\n//         events.forEach(({ event: {data, method }}) => {\n//           if (method == 'CreateSeries') {\n//             seriesId = data[1];\n//             console.log(`got series: ${seriesId}`);\n//           }\n//         });\n//\n//         // this is a new series, the first token will have serial number 0\n//         let serialNumber = 0;\n//         let tokenId = new EnhancedTokenId(api.registry, [collectionId, seriesId, serialNumber]);\n//         let tokenInfo = (await api.derive.nft.tokenInfo(tokenId));\n//         expect(tokenInfo ==\n//           {\n//             owner: tokenOwner.address,\n//             tokenId,\n//             attributes: api.registry.createType('Vec<NFTAttributeValue>',[])\n//           }\n//         );\n//\n//         done();\n//       }\n//     });\n//   });\n//\n//   it('creates a series of 5 in second collection', async done => {\n//     let seriesId;\n//     let quantity = 5;\n//     const metadataPath = {\"Https\": \"example.com/nft/metadata\" };\n//\n//     await api.tx.nft\n//       .mintSeries(collectionId2, quantity, tokenOwner.address, metadataPath, null)\n//       .signAndSend(collectionOwner, async ({ status, events }) => {\n//         if (status.isInBlock) {\n//           events.forEach(({ event: {data, method }}) => {\n//             if (method == 'CreateSeries') {\n//               seriesId = data[1];\n//               console.log(`got series: ${seriesId}`);\n//             }\n//           });\n//\n//           // this is a new series, the first token will have serial number 0\n//           let serialNumber = 0;\n//           let tokenId = new EnhancedTokenId(api.registry, [collectionId2, seriesId, serialNumber]);\n//           let tokenInfo = (await api.derive.nft.tokenInfo(tokenId));\n//           expect(tokenInfo ==\n//             {\n//               owner: tokenOwner.address,\n//               tokenId,\n//               attributes: api.registry.createType('Vec<NFTAttributeValue>',[])\n//             }\n//           );\n//\n//           done();\n//         }\n//       });\n//   });\n//\n//   it('mint additional in second collection', async done => {\n//     let seriesId = 1;\n//     let quantity = 3;\n//     // const metadataPath = {\"Https\": \"example.com/nft/metadata\" };\n//\n//     await api.tx.nft\n//       .mintAdditional(collectionId2, seriesId, quantity, collectionOwner.address)\n//       .signAndSend(collectionOwner, async ({ status, events }) => {\n//         if (status.isInBlock) {\n//           events.forEach(({ event: {data, method }}) => {\n//             if (method == 'CreateSeries') {\n//               seriesId = data[1];\n//               console.log(`got series: ${seriesId}`);\n//             }\n//           });\n//\n//           // this is a new series, the first token will have serial number 0\n//           let serialNumber = 0;\n//           let tokenId = new EnhancedTokenId(api.registry, [collectionId2, seriesId, serialNumber]);\n//           let tokenInfo = (await api.derive.nft.tokenInfo(tokenId));\n//           expect(tokenInfo ==\n//             {\n//               owner: tokenOwner.address,\n//               tokenId,\n//               attributes: api.registry.createType('Vec<NFTAttributeValue>',[])\n//             }\n//           );\n//           //console.log('tokenInfo:',tokenInfo);\n//           done();\n//         }\n//       });\n//   });\n//\n//   it('burn second token from series', async done => {\n//     const seriesId = 1;\n//     const serialNumber = 1;\n//     const tokenId = [collectionId, seriesId, serialNumber];\n//\n//     await api.tx.nft.burn(api.registry.createType('TokenId', tokenId))\n//       .signAndSend(tokenOwner, async ({ status, events }) => {\n//         if (status.isInBlock) {\n//           events.forEach(({event: {data, method}}) => {\n//             if (method == 'Burn') {\n//               const [collId, sId, [serialNo] ] = data;\n//               expect(collId.toNumber()).toEqual(collectionId);\n//               expect(sId.toNumber()).toEqual(seriesId);\n//               expect(serialNo.toNumber()).toEqual(serialNumber);\n//               done();\n//             }\n//           });\n//         }\n//       });\n//   });\n//\n//   it('Find tokens with owner ', async done => {\n//     const tokens: EnhancedTokenId[] = await api.derive.nft.tokensOf(tokenOwner.address) as EnhancedTokenId[];\n//     const hasToken0 = (token) => token.collectionId.toNumber() === 0 && token.seriesId.toNumber() === 0 && token.serialNumber.toNumber() === 0;\n//     const hasToken1 = (token) => token.collectionId.toNumber() === 1 && token.seriesId.toNumber() === 0 && token.serialNumber.toNumber() === 0;\n//     expect(tokens.some(hasToken0)).toBe(true);\n//     expect(tokens.some(hasToken1)).toBe(true);\n//     done();\n//   });\n//\n//   it('Find tokens in second collection for owner ', async done => {\n//     const collectionIds = api.registry.createType('Vec<CollectionId>',[1]);\n//     const tokens = await api.derive.nft.tokensOf(tokenOwner.address, collectionIds);\n//     const tokensInCollection = tokens[0];\n//     expect(tokensInCollection.toJSON()).toEqual({\"0\": [1, 0, 0], \"1\": [1, 1, 0], \"2\": [1, 1, 2]});\n//     done();\n//   });\n//\n//   it('finds collected tokens, their attributes and owners with derived query', async () => {\n//     const tokenInfos = await api.derive.nft.tokenInfoForCollection(collectionId.toString());\n//     const uniqueToken = tokenInfos.find((token) =>\n//       token.tokenId.collectionId.toNumber() === collectionId\n//       && token.tokenId.seriesId.toNumber() ===  0\n//       && token.tokenId.serialNumber.toNumber() === 0\n//     );\n//     expect(uniqueToken.owner).toEqual(tokenOwner.address);\n//\n//     const token1InSeries = tokenInfos.find((token) =>\n//       token.tokenId.collectionId.toNumber() === collectionId\n//       && token.tokenId.seriesId.toNumber() === 1\n//       && token.tokenId.serialNumber.toNumber() === 0\n//     );\n//     expect(token1InSeries.owner).toEqual(tokenOwner.address);\n//\n//     const token2InSeries = tokenInfos.find((token) =>\n//       token.tokenId.collectionId.toNumber() === collectionId\n//       && token.tokenId.seriesId.toNumber() ===  1\n//       && token.tokenId.serialNumber.toNumber() === 1\n//     );\n//     expect(token2InSeries.owner).toEqual(null);\n//\n//     const token3InSeries = tokenInfos.find((token) =>\n//       token.tokenId.collectionId.toNumber() === collectionId\n//       && token.tokenId.seriesId.toNumber() ===  1\n//       && token.tokenId.serialNumber.toNumber() === 2\n//     );\n//     expect(token3InSeries.owner).toEqual(tokenOwner.address);\n//\n//   });\n//\n//   it('finds collected tokens', async () => {\n//     let ownedTokens = (await api.rpc.nft.collectedTokens(collectionId, tokenOwner.address));\n//     expect(ownedTokens[0]).toEqual([1, 0, 0]);\n//     expect(ownedTokens[1]).toEqual([1, 1, 0]);\n//     expect(ownedTokens[2]).toEqual([1, 1, 2]);\n//   });\n//\n//   it('can list a bundle for fixed price sale', async done => {\n//     let buyer = keyring.addFromUri('//Test//TokenBuyer');\n//     let price = 200 * 10_000; // 200 CPAY\n//     let duration = 1000;\n//     let tokens = [[collectionId,0,0], [collectionId,1,0]];\n//     let tokenIds = api.registry.createType('Vec<TokenId>',tokens);\n//     let listingId = await api.query.nft.nextListingId();\n//     const marketplaceId = null;\n//     await api.tx.nft\n//       .sellBundle(tokenIds, buyer.address, spendingAssetId, price, duration.toString(), marketplaceId)\n//       .signAndSend(tokenOwner, async ({ status }) => {\n//           if (status.isInBlock) {\n//             let listing: Listing = (await api.query.nft.listings(listingId)).unwrapOrDefault();\n//             let blockNumber = (await api.rpc.chain.getBlock()).block.header.number.toNumber();\n//\n//               expect(listing.asFixedPrice.toJSON()).toEqual({\n//                 paymentAsset: spendingAssetId,\n//                 fixedPrice: price,\n//                 marketplaceId: null,\n//                 buyer: buyer.address,\n//                 close: blockNumber + duration,\n//                 seller: tokenOwner.address,\n//                 tokens,\n//                 royaltiesSchedule: { entitlements: [] },\n//               });\n//\n//             done();\n//           }\n//       });\n//   });\n//\n//   it('can list a token for auction', async done => {\n//     let reservePrice = 200 * 10_000; // 200 CPAY\n//     let duration = 1000;\n//     let token = api.registry.createType('TokenId',[collectionId,1,2]);\n//     let listingId = await api.query.nft.nextListingId();\n//     const marketplaceId = null;\n//\n//     await api.tx.nft\n//       .auction(token, spendingAssetId, reservePrice, duration.toString(), marketplaceId)\n//       .signAndSend(tokenOwner, async ({ status }) => {\n//         if (status.isInBlock) {\n//           let blockNumber = (await api.rpc.chain.getBlock()).block.header.number.toNumber();\n//           let listing: Listing = (await api.query.nft.listings(listingId)).unwrapOrDefault();\n//           expect(listing.asAuction.close.toNumber()).toEqual(blockNumber + duration);\n//           expect(listing.asAuction.paymentAsset.toNumber()).toEqual(spendingAssetId);\n//           expect(listing.asAuction.reservePrice.toNumber()).toEqual(reservePrice);\n//           expect(listing.asAuction.seller.toString()).toEqual(tokenOwner.address);\n//           expect(listing.asAuction.tokens.toJSON()).toEqual([token.toJSON()]);\n//           expect(listing.asAuction.royaltiesSchedule.toJSON()).toEqual({ entitlements: [] });\n//\n//           done();\n//         }\n//       }\n//     );\n//\n//   });\n//\n//   it('Get Open listings for Collection', async done => {\n//     let reservePrice = 200 * 10_000;\n//     let duration = '1000';\n//     let token = globalTokenIds[0]\n//     let token2 = globalTokenIds[1]\n//     const marketplaceId = null;\n//     // list two out of the three tokens, one auction & one fixed in collection\n//     await api.tx.nft.auction(token, spendingAssetId, reservePrice, duration, marketplaceId)\n//       .signAndSend(tokenOwner, async ({ status }) => {\n//         if (status.isInBlock) {\n//           await api.tx.nft.sell(token2, null, spendingAssetId, reservePrice, duration, marketplaceId)\n//             .signAndSend(tokenOwner, async ({ status }) => {\n//               if (status.isInBlock) {\n//                 const allTokens = await api.derive.nft.openCollectionListings(globalCollectionId);\n//                 // confirm only received 2 out of 3 listings returned and token IDs are correct\n//                 expect(allTokens.length).toBe(2);\n//                 const receivedTokenIds = [\n//                   {\n//                     collectionId: allTokens[0].tokenId.collectionId.toNumber(),\n//                     seriesId: allTokens[0].tokenId.seriesId.toNumber(),\n//                     serialNumber: allTokens[0].tokenId.serialNumber.toNumber(),\n//                   },\n//                   {\n//                     collectionId: allTokens[1].tokenId.collectionId.toNumber(),\n//                     seriesId: allTokens[1].tokenId.seriesId.toNumber(),\n//                     serialNumber: allTokens[1].tokenId.serialNumber.toNumber(),\n//                   },\n//                 ]\n//                 //sort based on series number\n//                 receivedTokenIds.sort((a, b) => (a.serialNumber > b.serialNumber) ? 1 : -1)\n//                 expect(receivedTokenIds).toEqual([\n//                   {\n//                     collectionId: globalCollectionId,\n//                     seriesId: 0,\n//                     serialNumber: 0,\n//                   },\n//                   {\n//                     collectionId: globalCollectionId,\n//                     seriesId: 0,\n//                     serialNumber: 1,\n//                   }\n//                 ]);\n//                 // Ensure Listing Id correctly matches token Id\n//                 const firstReceivedListing: Listing = (await api.query.nft.listings(allTokens[0].listingId)).unwrapOrDefault();\n//                 const expectedTokenID: TokenId = firstReceivedListing.isAuction\n//                   ? firstReceivedListing.asAuction.toJSON().tokens[0]\n//                   : firstReceivedListing.asFixedPrice.toJSON().tokens[0];\n//                 expect(expectedTokenID).toEqual( [\n//                     allTokens[0].tokenId.collectionId.toNumber(),\n//                     allTokens[0].tokenId.seriesId.toNumber(),\n//                     allTokens[0].tokenId.serialNumber.toNumber()\n//                   ]\n//                 )\n//                 done();\n//               }\n//             })\n//         }\n//       })\n//   });\n//\n//\n//   it('Find tokens listing on local with V2', async done => {\n//     const allTokens = await api.derive.nft.openCollectionListingsV2('16');\n//     expect(allTokens.length).toBe(2);\n//     expect(allTokens[0].listingId).toBe('3');\n//     expect(allTokens[0].tokens[0].owner).toBe(tokenOwner.address);\n//     expect(allTokens[0].tokens[0].tokenId.toString()).toBe(new EnhancedTokenId(api.registry, [16,0,1]).toString());\n//     expect(allTokens[1].listingId).toBe('2');\n//     expect(allTokens[1].tokens[0].owner).toBe(tokenOwner.address);\n//     expect(allTokens[1].tokens[0].tokenId.toString()).toBe(new EnhancedTokenId(api.registry, [16,0,0]).toString());\n//     done();\n//   });\n//\n//   it( 'Return empty listing when it is not available ', async done => {\n//       const listing = await api.derive.nft.openCollectionListings('1442');\n//       expect(listing).toEqual([]);\n//       done();\n//   });\n//\n//   it('Find all tokens with owner on Azalea', async done => {\n//     jest.setTimeout(40000); // sometimes takes more time\n//     const address = '5EYxYJVZFwa4T1nVGFadeMNWRhHPYboMdToEbiER2AzWVsLK';\n//     const api = await Api.create({network: 'azalea'});\n//     const tokens = await api.derive.nft.tokensOf(address);\n//     expect((tokens as EnhancedTokenId[]).length).toBeGreaterThan(0);\n//     await api.disconnect();\n//     done();\n//   });\n//\n//\n//   // Might need to change this test as owner can change while trading nfts\n//   it('Find tokens info with owner on Azalea', async done => {\n//     const api = await Api.create({network: 'azalea'});\n//\n//     const tokenInfo = await api.derive.nft.tokenInfo(api.createType('TokenId',[46, 24, 214]));\n//\n//     expect(tokenInfo.owner).toEqual(\"5G1oXM53W1zMB6YZQvgZ6BUvAk1iXQcZdpNAZAJjyLyJX8NL\");\n//\n//     const tokenInfo1 = await api.derive.nft.tokenInfo(api.createType('TokenId',[46, 24, 441]));\n//     expect(tokenInfo1.owner).toEqual(\"5CoQbre9E6oaSq9RzcqQJCd6qcNEy5d1YyBnpLC2mqoubWQV\");\n//\n//     await api.disconnect();\n//     done();\n//\n//   });\n//\n//   it('Find series metadata uri from nikau', async done => {\n//     const api = await Api.create({network: \"nikau\"});\n//     const uri = await api.derive.nft.seriesMetadataUri(192, 0);\n//     expect(uri.toHuman()).toEqual(\"ipfs://QmdHBkLr9L3UarwPZVGjqKFZs6XQ36Z4jJULt4zh3KwkY1\");\n//     await api.disconnect();\n//     done();\n//   });\n//\n//   it('test derive nft queries', async done => {\n//     const api = await Api.create({network: \"nikau\"});\n//     const tokenInfo = await api.rpc.nft.getTokenInfo(206,0,1);\n//     expect(tokenInfo.owner).toEqual(\"5H14vxnz18N4raNRGZDNnRtF1vXC5uUru4LxTxz2ZUSxuxfF\");\n//     expect(tokenInfo.royalties[0]).toEqual([\"5H14vxnz18N4raNRGZDNnRtF1vXC5uUru4LxTxz2ZUSxuxfF\",\"0.070000\"]);\n//     const listingInfo = await api.rpc.nft.getCollectionListings(206,0,10);\n//     expect((listingInfo as any).listings.length).toBeGreaterThanOrEqual(0);\n//     const firstListing = (listingInfo as any).listings[0];\n//     // Listing can expire\n//     // expect(firstListing).toEqual({\"buyer\":null,\"end_block\":2813952,\"id\":\"2023\",\"listing_type\":\"fixedPrice\",\"payment_asset\":17002,\"price\":\"333000000000000000000\",\"royalties\":[[\"5H14vxnz18N4raNRGZDNnRtF1vXC5uUru4LxTxz2ZUSxuxfF\",\"0.070000\"]],\"seller\":\"5E5gfwi3m5YhWfpwycwYv3RKhKMvQssE1G7gnfp4khEVF7K2\",\"token_ids\":[[206,0,8]]});\n//     const collectionInfo: CollectionInfo = await api.rpc.nft.getCollectionInfo(206) as unknown as CollectionInfo;\n//     expect(collectionInfo.name).toEqual('GLORIOUS GORDON WALTERS MAHO');\n//     expect(collectionInfo.owner).toEqual('5H14vxnz18N4raNRGZDNnRtF1vXC5uUru4LxTxz2ZUSxuxfF');\n//     expect(collectionInfo.royalties).toEqual([]);\n//\n//     const collectedTokens = await api.rpc.nft.collectedTokens(206, \"5E5gfwi3m5YhWfpwycwYv3RKhKMvQssE1G7gnfp4khEVF7K2\") as unknown as CollectionInfo;\n//     expect(collectedTokens[0]).toEqual([206,0,8]);\n//\n//     const tokenUri = await api.rpc.nft.tokenUri(api.registry.createType('TokenId',[206,0,1]));\n//     expect(u8aToString(tokenUri)).toEqual('ipfs://QmaPjtvkpLbwWvGAFjp9GgvXCFFJPVN9VGWD36zoRpd8Sq.json');\n//     api.disconnect();\n//     done();\n//   });\n// });\n"],"version":3}