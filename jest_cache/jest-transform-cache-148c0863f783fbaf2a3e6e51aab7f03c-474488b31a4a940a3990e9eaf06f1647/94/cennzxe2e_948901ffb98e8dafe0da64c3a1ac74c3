1989e4e6925f5137fbc6af16c6283b42
"use strict";
// // Copyright 2019-2020 Centrality Investments Limited
// //
// // Licensed under the Apache License, Version 2.0 (the "License");
// // you may not use this file except in compliance with the License.
// // You may obtain a copy of the License at
// //
// //     http://www.apache.org/licenses/LICENSE-2.0
// //
// // Unless required by applicable law or agreed to in writing, software
// // distributed under the License is distributed on an "AS IS" BASIS,
// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// // See the License for the specific language governing permissions and
// // limitations under the License.
// import { Api } from '@cennznet/api';
// import {SignerOptions} from "@polkadot/api/types";
// import { Keyring } from '@polkadot/keyring';
// import {BN} from "@polkadot/util";
// import { cryptoWaitReady } from '@polkadot/util-crypto';
// import initApiPromise from '../../../../jest/initApiPromise';
// import {Balance, LiquidityPriceResponse, LiquidityValueResponse} from '@cennznet/types';
// const CENNZ = '16000';
// const CENTRAPAY = '16001';
// const PLUG = '16003';
//
describe.skip('DEX RPC calls testing', () => { });
//   let api: Api;
//   let alice, bob;
//   beforeAll(async () => {
//     await cryptoWaitReady();
//     // api = await initApiPromise();
//     // const keyring = new Keyring({ type: 'sr25519' });
//     // alice = keyring.addFromUri('//Alice');
//     // bob = keyring.addFromUri('//Bob');
//   });
//
//   afterAll(async () => {
//     // api.disconnect();
//   });
//
//   describe('Queries()', () => {
//
//     it("Deposit liquidity in CENNZ asset's pool", async done => {
//         const amount = 3_000_000;
//         const coreAmount = amount;
//         const minLiquidity = 1;
//       // Add Liquidity for the first time in the pool.
//         await api.tx.cennzx
//           .addLiquidity(CENNZ, minLiquidity, amount, coreAmount)
//           .signAndSend(alice, async ({events, status}) => {
//             if (status.isInBlock) {
//               for (const {event} of events) {
//                 if (event.method === 'AddLiquidity') {
//                   let amount = 2000;
//                   const liquidityPrice: LiquidityPriceResponse = await api.rpc.cennzx.liquidityPrice(CENNZ, amount);
//                   // Deposit liquidity in existing pool
//                   await api.tx.cennzx
//                       .addLiquidity(CENNZ, minLiquidity, liquidityPrice.asset, liquidityPrice.core)
//                       .signAndSend(alice, async ({events, status}) => {
//                         if (status.isFinalized) {
//                           for (const {event} of events) {
//                             if (event.method === 'AddLiquidity') {
//                               done();
//                             }
//                           }
//                         }
//                       });
//                 }
//               }
//             }
//           });
//     });
//
//     it("Get the liquidity value for CENNZ asset in Alice's account", async done => {
//       const liquidityValue: LiquidityValueResponse = await api.rpc.cennzx.liquidityValue(alice.address, CENNZ);
//       expect(liquidityValue.liquidity.isZero()).toBe(false);
//       expect(liquidityValue.core.isZero()).toBe(false);
//       expect(liquidityValue.asset.isZero()).toBe(false);
//       done();
//     });
//
//     describe('Positive flow with liquidity in pool', () => {
//       it("Calculate the buy price when buying CENTRAPAY for CENNZ", async done => {
//         const amount = 100;
//         const poolAssetBalance = await api.derive.cennzx.poolAssetBalance(CENNZ);
//         const poolCoreAssetBalance = await api.derive.cennzx.poolCoreAssetBalance(CENNZ);
//         console.log('Amount of asset in CENNZ pool:', poolAssetBalance.toString());
//         console.log('Amount of core in CENNZ pool:', poolCoreAssetBalance.toString());
//         // How much CENTRAPAY will it cost to buy 100 (amount) CENNZ
//         const buyPrice = await api.rpc.cennzx.buyPrice(CENTRAPAY, amount, CENNZ);
//         console.log('Buy price:', buyPrice.toString());
//         expect(buyPrice.price.toNumber()).toBeGreaterThan(0);
//         done();
//       });
//
//       it("Calculate the sell price when selling CENNZ for CENTRAPAY ", async done => {
//         const amount = 1000;
//         // when I sell 1000(amount) CENNZ, how much of CENTRAPAY will I get in return
//         const sellPrice = await api.rpc.cennzx
//           .sellPrice(CENNZ, amount, CENTRAPAY);
//         expect(sellPrice.price.toNumber()).toBeGreaterThan(0);
//         done();
//       });
//
//       describe('feeExchange derive queries with positive flow', () => {
//         it('Query estimated fee in CENTRAPAY(default fee currency)', async done => {
//           const assetBalanceBefore = await api.query.genericAsset.freeBalance(CENTRAPAY, alice.address);
//           const extrinsic = api.tx.genericAsset
//             .transfer(CENNZ, bob.address, 10000);
//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId:CENTRAPAY});
//
//           await extrinsic.signAndSend(alice,  async ({events, status}) => {
//             if (status.isFinalized) {
//               events.forEach(({phase, event: {data, method, section}}) => {
//                 console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
//               });
//               const assetBalanceAfter = await api.query.genericAsset.freeBalance(CENTRAPAY, alice.address);
//               expect((assetBalanceBefore as Balance).toBn().sub((assetBalanceAfter as Balance).toBn()).toString()).toEqual(feeFromQuery.toString());
//               done();
//             }
//           });
//         });
//
//         it('Query estimated fee in different currency (CENNZ)', async done => {
//           const maxPayment = '50000000000000000';
//           const assetId = api.registry.createType('AssetId', CENNZ);
//           const feeExchange = api.registry.createType('FeeExchange', {assetId, maxPayment}, 0);
//           const transactionPayment = api.registry.createType('ChargeTransactionPayment', {tip: 0, feeExchange});
//           const royaltiesSchedule = null;
//           const extrinsic = api.tx.nft.createCollection(
//             'collectionName',
//             royaltiesSchedule
//           );
//
//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId: CENNZ, maxPayment});
//           await extrinsic.signAndSend(alice,  {transactionPayment} as Partial<SignerOptions>, async ({events, status}) => {
//             if (status.isFinalized) {
//               events.forEach(({phase, event: {data, method, section}}) => {
//                 if (method === 'AssetBought') {
//                   const price = data[3];
//                   console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
//                   expect(feeFromQuery.toString()).toEqual(price.toString());
//                   done();
//                 }
//               });
//             }
//           });
//         });
//       });
//     });
//
//     describe('Negative flow with no liquidity in pool', () => {
//       it("Calculate the buy price when buying CENTRAPAY for PLUG", async done => {
//         const amount = 100;
//         const poolAssetBalance = await api.derive.cennzx.poolAssetBalance(PLUG);
//         const poolCoreAssetBalance = await api.derive.cennzx.poolCoreAssetBalance(PLUG);
//         console.log('Amount of asset in PLUG pool:', poolAssetBalance.toString());
//         console.log('Amount of core in PLUG pool:', poolCoreAssetBalance.toString());
//         // How much CENTRAPAY will it cost to buy 100 (amount) PLUG
//         await expect(api.rpc.cennzx.buyPrice(CENTRAPAY, amount, PLUG)).rejects.toThrow(
//           '2: Cannot exchange for requested amount.:'
//         );
//         done();
//       });
//
//       it("Calculate the sell price when selling PLUG for CENTRAPAY when no liquidity exist ", async done => {
//         const amount = 1000;
//         // when I sell 1000(amount) PLUG, how much of CENTRAPAY will I get in return
//         await expect(api.rpc.cennzx
//           .sellPrice(PLUG, amount, CENTRAPAY)).rejects.toThrow(
//           '2: Cannot exchange by requested amount.'
//         );
//         done();
//       });
//
//       describe('feeExchange derive queries with negative flow', () => {
//
//         it('Query estimated fee in different currency (PLUG)', async done => {
//           const maxPayment = '50000000000000000';
//           const extrinsic = api.tx.genericAsset
//             .transfer(CENNZ, bob.address, 10000);
//           const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId:PLUG, maxPayment});
//           expect(feeFromQuery).toEqual(new Error('2: Cannot exchange for requested amount.: '));
//           done();
//         });
//       });
//     });
//
//   });
// });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2thcmlzaG1hL3dvcmsvZnV0dXJldmVyc2UvdHJuLXJvb3RuZXQtYXBpL3BhY2thZ2VzL2FwaS90ZXN0L2UyZS9jZW5uenguZTJlLnRzIiwibWFwcGluZ3MiOiI7QUFBQSx3REFBd0Q7QUFDeEQsS0FBSztBQUNMLHFFQUFxRTtBQUNyRSxzRUFBc0U7QUFDdEUsNkNBQTZDO0FBQzdDLEtBQUs7QUFDTCxvREFBb0Q7QUFDcEQsS0FBSztBQUNMLHlFQUF5RTtBQUN6RSx1RUFBdUU7QUFDdkUsOEVBQThFO0FBQzlFLHlFQUF5RTtBQUN6RSxvQ0FBb0M7QUFDcEMsdUNBQXVDO0FBQ3ZDLHFEQUFxRDtBQUNyRCwrQ0FBK0M7QUFDL0MscUNBQXFDO0FBQ3JDLDJEQUEyRDtBQUMzRCxnRUFBZ0U7QUFDaEUsMkZBQTJGO0FBQzNGLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0Isd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRixRQUFRLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2pELGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkMsMkRBQTJEO0FBQzNELGdEQUFnRDtBQUNoRCw0Q0FBNEM7QUFDNUMsUUFBUTtBQUNSLEVBQUU7QUFDRiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLFFBQVE7QUFDUixFQUFFO0FBQ0Ysa0NBQWtDO0FBQ2xDLEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxrQ0FBa0M7QUFDbEMseURBQXlEO0FBQ3pELDhCQUE4QjtBQUM5QixtRUFBbUU7QUFDbkUsOERBQThEO0FBQzlELHNDQUFzQztBQUN0QyxnREFBZ0Q7QUFDaEQseURBQXlEO0FBQ3pELHVDQUF1QztBQUN2Qyx1SEFBdUg7QUFDdkgsMERBQTBEO0FBQzFELHdDQUF3QztBQUN4QyxzR0FBc0c7QUFDdEcsMEVBQTBFO0FBQzFFLG9EQUFvRDtBQUNwRCw0REFBNEQ7QUFDNUQscUVBQXFFO0FBQ3JFLHdDQUF3QztBQUN4QyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLFVBQVU7QUFDVixFQUFFO0FBQ0YsdUZBQXVGO0FBQ3ZGLGtIQUFrSDtBQUNsSCwrREFBK0Q7QUFDL0QsMERBQTBEO0FBQzFELDJEQUEyRDtBQUMzRCxnQkFBZ0I7QUFDaEIsVUFBVTtBQUNWLEVBQUU7QUFDRiwrREFBK0Q7QUFDL0Qsc0ZBQXNGO0FBQ3RGLDhCQUE4QjtBQUM5QixvRkFBb0Y7QUFDcEYsNEZBQTRGO0FBQzVGLHNGQUFzRjtBQUN0Rix5RkFBeUY7QUFDekYsdUVBQXVFO0FBQ3ZFLG9GQUFvRjtBQUNwRiwwREFBMEQ7QUFDMUQsZ0VBQWdFO0FBQ2hFLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osRUFBRTtBQUNGLHlGQUF5RjtBQUN6RiwrQkFBK0I7QUFDL0Isd0ZBQXdGO0FBQ3hGLGlEQUFpRDtBQUNqRCxrREFBa0Q7QUFDbEQsaUVBQWlFO0FBQ2pFLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx1RkFBdUY7QUFDdkYsMkdBQTJHO0FBQzNHLGtEQUFrRDtBQUNsRCxvREFBb0Q7QUFDcEQsMkdBQTJHO0FBQzNHLEVBQUU7QUFDRiw4RUFBOEU7QUFDOUUsd0NBQXdDO0FBQ3hDLDhFQUE4RTtBQUM5RSxrR0FBa0c7QUFDbEcsb0JBQW9CO0FBQ3BCLDhHQUE4RztBQUM5Ryx1SkFBdUo7QUFDdkosd0JBQXdCO0FBQ3hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLEVBQUU7QUFDRixrRkFBa0Y7QUFDbEYsb0RBQW9EO0FBQ3BELHVFQUF1RTtBQUN2RSxrR0FBa0c7QUFDbEcsbUhBQW1IO0FBQ25ILDRDQUE0QztBQUM1QywyREFBMkQ7QUFDM0QsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxlQUFlO0FBQ2YsRUFBRTtBQUNGLG9IQUFvSDtBQUNwSCw4SEFBOEg7QUFDOUgsd0NBQXdDO0FBQ3hDLDhFQUE4RTtBQUM5RSxrREFBa0Q7QUFDbEQsMkNBQTJDO0FBQzNDLG9HQUFvRztBQUNwRywrRUFBK0U7QUFDL0UsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsWUFBWTtBQUNaLFVBQVU7QUFDVixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLHFGQUFxRjtBQUNyRiw4QkFBOEI7QUFDOUIsbUZBQW1GO0FBQ25GLDJGQUEyRjtBQUMzRixxRkFBcUY7QUFDckYsd0ZBQXdGO0FBQ3hGLHNFQUFzRTtBQUN0RSwwRkFBMEY7QUFDMUYsd0RBQXdEO0FBQ3hELGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLEVBQUU7QUFDRixnSEFBZ0g7QUFDaEgsK0JBQStCO0FBQy9CLHVGQUF1RjtBQUN2RixzQ0FBc0M7QUFDdEMsa0VBQWtFO0FBQ2xFLHNEQUFzRDtBQUN0RCxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLEVBQUU7QUFDRixpRkFBaUY7QUFDakYsb0RBQW9EO0FBQ3BELGtEQUFrRDtBQUNsRCxvREFBb0Q7QUFDcEQsa0hBQWtIO0FBQ2xILG1HQUFtRztBQUNuRyxvQkFBb0I7QUFDcEIsY0FBYztBQUNkLFlBQVk7QUFDWixVQUFVO0FBQ1YsRUFBRTtBQUNGLFFBQVE7QUFDUixNQUFNIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXJpc2htYS93b3JrL2Z1dHVyZXZlcnNlL3Rybi1yb290bmV0LWFwaS9wYWNrYWdlcy9hcGkvdGVzdC9lMmUvY2Vubnp4LmUyZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAvLyBDb3B5cmlnaHQgMjAxOS0yMDIwIENlbnRyYWxpdHkgSW52ZXN0bWVudHMgTGltaXRlZFxuLy8gLy9cbi8vIC8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyAvLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyAvLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIC8vXG4vLyAvLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyAvL1xuLy8gLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyAvLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyAvLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vIGltcG9ydCB7IEFwaSB9IGZyb20gJ0BjZW5uem5ldC9hcGknO1xuLy8gaW1wb3J0IHtTaWduZXJPcHRpb25zfSBmcm9tIFwiQHBvbGthZG90L2FwaS90eXBlc1wiO1xuLy8gaW1wb3J0IHsgS2V5cmluZyB9IGZyb20gJ0Bwb2xrYWRvdC9rZXlyaW5nJztcbi8vIGltcG9ydCB7Qk59IGZyb20gXCJAcG9sa2Fkb3QvdXRpbFwiO1xuLy8gaW1wb3J0IHsgY3J5cHRvV2FpdFJlYWR5IH0gZnJvbSAnQHBvbGthZG90L3V0aWwtY3J5cHRvJztcbi8vIGltcG9ydCBpbml0QXBpUHJvbWlzZSBmcm9tICcuLi8uLi8uLi8uLi9qZXN0L2luaXRBcGlQcm9taXNlJztcbi8vIGltcG9ydCB7QmFsYW5jZSwgTGlxdWlkaXR5UHJpY2VSZXNwb25zZSwgTGlxdWlkaXR5VmFsdWVSZXNwb25zZX0gZnJvbSAnQGNlbm56bmV0L3R5cGVzJztcbi8vIGNvbnN0IENFTk5aID0gJzE2MDAwJztcbi8vIGNvbnN0IENFTlRSQVBBWSA9ICcxNjAwMSc7XG4vLyBjb25zdCBQTFVHID0gJzE2MDAzJztcbi8vXG5kZXNjcmliZS5za2lwKCdERVggUlBDIGNhbGxzIHRlc3RpbmcnLCAoKSA9PiB7fSk7XG4vLyAgIGxldCBhcGk6IEFwaTtcbi8vICAgbGV0IGFsaWNlLCBib2I7XG4vLyAgIGJlZm9yZUFsbChhc3luYyAoKSA9PiB7XG4vLyAgICAgYXdhaXQgY3J5cHRvV2FpdFJlYWR5KCk7XG4vLyAgICAgLy8gYXBpID0gYXdhaXQgaW5pdEFwaVByb21pc2UoKTtcbi8vICAgICAvLyBjb25zdCBrZXlyaW5nID0gbmV3IEtleXJpbmcoeyB0eXBlOiAnc3IyNTUxOScgfSk7XG4vLyAgICAgLy8gYWxpY2UgPSBrZXlyaW5nLmFkZEZyb21VcmkoJy8vQWxpY2UnKTtcbi8vICAgICAvLyBib2IgPSBrZXlyaW5nLmFkZEZyb21VcmkoJy8vQm9iJyk7XG4vLyAgIH0pO1xuLy9cbi8vICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuLy8gICAgIC8vIGFwaS5kaXNjb25uZWN0KCk7XG4vLyAgIH0pO1xuLy9cbi8vICAgZGVzY3JpYmUoJ1F1ZXJpZXMoKScsICgpID0+IHtcbi8vXG4vLyAgICAgaXQoXCJEZXBvc2l0IGxpcXVpZGl0eSBpbiBDRU5OWiBhc3NldCdzIHBvb2xcIiwgYXN5bmMgZG9uZSA9PiB7XG4vLyAgICAgICAgIGNvbnN0IGFtb3VudCA9IDNfMDAwXzAwMDtcbi8vICAgICAgICAgY29uc3QgY29yZUFtb3VudCA9IGFtb3VudDtcbi8vICAgICAgICAgY29uc3QgbWluTGlxdWlkaXR5ID0gMTtcbi8vICAgICAgIC8vIEFkZCBMaXF1aWRpdHkgZm9yIHRoZSBmaXJzdCB0aW1lIGluIHRoZSBwb29sLlxuLy8gICAgICAgICBhd2FpdCBhcGkudHguY2Vubnp4XG4vLyAgICAgICAgICAgLmFkZExpcXVpZGl0eShDRU5OWiwgbWluTGlxdWlkaXR5LCBhbW91bnQsIGNvcmVBbW91bnQpXG4vLyAgICAgICAgICAgLnNpZ25BbmRTZW5kKGFsaWNlLCBhc3luYyAoe2V2ZW50cywgc3RhdHVzfSkgPT4ge1xuLy8gICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0luQmxvY2spIHtcbi8vICAgICAgICAgICAgICAgZm9yIChjb25zdCB7ZXZlbnR9IG9mIGV2ZW50cykge1xuLy8gICAgICAgICAgICAgICAgIGlmIChldmVudC5tZXRob2QgPT09ICdBZGRMaXF1aWRpdHknKSB7XG4vLyAgICAgICAgICAgICAgICAgICBsZXQgYW1vdW50ID0gMjAwMDtcbi8vICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpcXVpZGl0eVByaWNlOiBMaXF1aWRpdHlQcmljZVJlc3BvbnNlID0gYXdhaXQgYXBpLnJwYy5jZW5uengubGlxdWlkaXR5UHJpY2UoQ0VOTlosIGFtb3VudCk7XG4vLyAgICAgICAgICAgICAgICAgICAvLyBEZXBvc2l0IGxpcXVpZGl0eSBpbiBleGlzdGluZyBwb29sXG4vLyAgICAgICAgICAgICAgICAgICBhd2FpdCBhcGkudHguY2Vubnp4XG4vLyAgICAgICAgICAgICAgICAgICAgICAgLmFkZExpcXVpZGl0eShDRU5OWiwgbWluTGlxdWlkaXR5LCBsaXF1aWRpdHlQcmljZS5hc3NldCwgbGlxdWlkaXR5UHJpY2UuY29yZSlcbi8vICAgICAgICAgICAgICAgICAgICAgICAuc2lnbkFuZFNlbmQoYWxpY2UsIGFzeW5jICh7ZXZlbnRzLCBzdGF0dXN9KSA9PiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmlzRmluYWxpemVkKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qge2V2ZW50fSBvZiBldmVudHMpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQubWV0aG9kID09PSAnQWRkTGlxdWlkaXR5Jykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICBpdChcIkdldCB0aGUgbGlxdWlkaXR5IHZhbHVlIGZvciBDRU5OWiBhc3NldCBpbiBBbGljZSdzIGFjY291bnRcIiwgYXN5bmMgZG9uZSA9PiB7XG4vLyAgICAgICBjb25zdCBsaXF1aWRpdHlWYWx1ZTogTGlxdWlkaXR5VmFsdWVSZXNwb25zZSA9IGF3YWl0IGFwaS5ycGMuY2Vubnp4LmxpcXVpZGl0eVZhbHVlKGFsaWNlLmFkZHJlc3MsIENFTk5aKTtcbi8vICAgICAgIGV4cGVjdChsaXF1aWRpdHlWYWx1ZS5saXF1aWRpdHkuaXNaZXJvKCkpLnRvQmUoZmFsc2UpO1xuLy8gICAgICAgZXhwZWN0KGxpcXVpZGl0eVZhbHVlLmNvcmUuaXNaZXJvKCkpLnRvQmUoZmFsc2UpO1xuLy8gICAgICAgZXhwZWN0KGxpcXVpZGl0eVZhbHVlLmFzc2V0LmlzWmVybygpKS50b0JlKGZhbHNlKTtcbi8vICAgICAgIGRvbmUoKTtcbi8vICAgICB9KTtcbi8vXG4vLyAgICAgZGVzY3JpYmUoJ1Bvc2l0aXZlIGZsb3cgd2l0aCBsaXF1aWRpdHkgaW4gcG9vbCcsICgpID0+IHtcbi8vICAgICAgIGl0KFwiQ2FsY3VsYXRlIHRoZSBidXkgcHJpY2Ugd2hlbiBidXlpbmcgQ0VOVFJBUEFZIGZvciBDRU5OWlwiLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgICAgY29uc3QgYW1vdW50ID0gMTAwO1xuLy8gICAgICAgICBjb25zdCBwb29sQXNzZXRCYWxhbmNlID0gYXdhaXQgYXBpLmRlcml2ZS5jZW5uengucG9vbEFzc2V0QmFsYW5jZShDRU5OWik7XG4vLyAgICAgICAgIGNvbnN0IHBvb2xDb3JlQXNzZXRCYWxhbmNlID0gYXdhaXQgYXBpLmRlcml2ZS5jZW5uengucG9vbENvcmVBc3NldEJhbGFuY2UoQ0VOTlopO1xuLy8gICAgICAgICBjb25zb2xlLmxvZygnQW1vdW50IG9mIGFzc2V0IGluIENFTk5aIHBvb2w6JywgcG9vbEFzc2V0QmFsYW5jZS50b1N0cmluZygpKTtcbi8vICAgICAgICAgY29uc29sZS5sb2coJ0Ftb3VudCBvZiBjb3JlIGluIENFTk5aIHBvb2w6JywgcG9vbENvcmVBc3NldEJhbGFuY2UudG9TdHJpbmcoKSk7XG4vLyAgICAgICAgIC8vIEhvdyBtdWNoIENFTlRSQVBBWSB3aWxsIGl0IGNvc3QgdG8gYnV5IDEwMCAoYW1vdW50KSBDRU5OWlxuLy8gICAgICAgICBjb25zdCBidXlQcmljZSA9IGF3YWl0IGFwaS5ycGMuY2Vubnp4LmJ1eVByaWNlKENFTlRSQVBBWSwgYW1vdW50LCBDRU5OWik7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKCdCdXkgcHJpY2U6JywgYnV5UHJpY2UudG9TdHJpbmcoKSk7XG4vLyAgICAgICAgIGV4cGVjdChidXlQcmljZS5wcmljZS50b051bWJlcigpKS50b0JlR3JlYXRlclRoYW4oMCk7XG4vLyAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgIH0pO1xuLy9cbi8vICAgICAgIGl0KFwiQ2FsY3VsYXRlIHRoZSBzZWxsIHByaWNlIHdoZW4gc2VsbGluZyBDRU5OWiBmb3IgQ0VOVFJBUEFZIFwiLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgICAgY29uc3QgYW1vdW50ID0gMTAwMDtcbi8vICAgICAgICAgLy8gd2hlbiBJIHNlbGwgMTAwMChhbW91bnQpIENFTk5aLCBob3cgbXVjaCBvZiBDRU5UUkFQQVkgd2lsbCBJIGdldCBpbiByZXR1cm5cbi8vICAgICAgICAgY29uc3Qgc2VsbFByaWNlID0gYXdhaXQgYXBpLnJwYy5jZW5uenhcbi8vICAgICAgICAgICAuc2VsbFByaWNlKENFTk5aLCBhbW91bnQsIENFTlRSQVBBWSk7XG4vLyAgICAgICAgIGV4cGVjdChzZWxsUHJpY2UucHJpY2UudG9OdW1iZXIoKSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuLy8gICAgICAgICBkb25lKCk7XG4vLyAgICAgICB9KTtcbi8vXG4vLyAgICAgICBkZXNjcmliZSgnZmVlRXhjaGFuZ2UgZGVyaXZlIHF1ZXJpZXMgd2l0aCBwb3NpdGl2ZSBmbG93JywgKCkgPT4ge1xuLy8gICAgICAgICBpdCgnUXVlcnkgZXN0aW1hdGVkIGZlZSBpbiBDRU5UUkFQQVkoZGVmYXVsdCBmZWUgY3VycmVuY3kpJywgYXN5bmMgZG9uZSA9PiB7XG4vLyAgICAgICAgICAgY29uc3QgYXNzZXRCYWxhbmNlQmVmb3JlID0gYXdhaXQgYXBpLnF1ZXJ5LmdlbmVyaWNBc3NldC5mcmVlQmFsYW5jZShDRU5UUkFQQVksIGFsaWNlLmFkZHJlc3MpO1xuLy8gICAgICAgICAgIGNvbnN0IGV4dHJpbnNpYyA9IGFwaS50eC5nZW5lcmljQXNzZXRcbi8vICAgICAgICAgICAgIC50cmFuc2ZlcihDRU5OWiwgYm9iLmFkZHJlc3MsIDEwMDAwKTtcbi8vICAgICAgICAgICBjb25zdCBmZWVGcm9tUXVlcnkgPSBhd2FpdCBhcGkuZGVyaXZlLmZlZXMuZXN0aW1hdGVGZWUoe2V4dHJpbnNpYywgdXNlckZlZUFzc2V0SWQ6Q0VOVFJBUEFZfSk7XG4vL1xuLy8gICAgICAgICAgIGF3YWl0IGV4dHJpbnNpYy5zaWduQW5kU2VuZChhbGljZSwgIGFzeW5jICh7ZXZlbnRzLCBzdGF0dXN9KSA9PiB7XG4vLyAgICAgICAgICAgICBpZiAoc3RhdHVzLmlzRmluYWxpemVkKSB7XG4vLyAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKCh7cGhhc2UsIGV2ZW50OiB7ZGF0YSwgbWV0aG9kLCBzZWN0aW9ufX0pID0+IHtcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnXFx0JywgcGhhc2UudG9TdHJpbmcoKSwgYDogJHtzZWN0aW9ufS4ke21ldGhvZH1gLCBkYXRhLnRvU3RyaW5nKCkpO1xuLy8gICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgY29uc3QgYXNzZXRCYWxhbmNlQWZ0ZXIgPSBhd2FpdCBhcGkucXVlcnkuZ2VuZXJpY0Fzc2V0LmZyZWVCYWxhbmNlKENFTlRSQVBBWSwgYWxpY2UuYWRkcmVzcyk7XG4vLyAgICAgICAgICAgICAgIGV4cGVjdCgoYXNzZXRCYWxhbmNlQmVmb3JlIGFzIEJhbGFuY2UpLnRvQm4oKS5zdWIoKGFzc2V0QmFsYW5jZUFmdGVyIGFzIEJhbGFuY2UpLnRvQm4oKSkudG9TdHJpbmcoKSkudG9FcXVhbChmZWVGcm9tUXVlcnkudG9TdHJpbmcoKSk7XG4vLyAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSk7XG4vL1xuLy8gICAgICAgICBpdCgnUXVlcnkgZXN0aW1hdGVkIGZlZSBpbiBkaWZmZXJlbnQgY3VycmVuY3kgKENFTk5aKScsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgICAgIGNvbnN0IG1heFBheW1lbnQgPSAnNTAwMDAwMDAwMDAwMDAwMDAnO1xuLy8gICAgICAgICAgIGNvbnN0IGFzc2V0SWQgPSBhcGkucmVnaXN0cnkuY3JlYXRlVHlwZSgnQXNzZXRJZCcsIENFTk5aKTtcbi8vICAgICAgICAgICBjb25zdCBmZWVFeGNoYW5nZSA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdGZWVFeGNoYW5nZScsIHthc3NldElkLCBtYXhQYXltZW50fSwgMCk7XG4vLyAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25QYXltZW50ID0gYXBpLnJlZ2lzdHJ5LmNyZWF0ZVR5cGUoJ0NoYXJnZVRyYW5zYWN0aW9uUGF5bWVudCcsIHt0aXA6IDAsIGZlZUV4Y2hhbmdlfSk7XG4vLyAgICAgICAgICAgY29uc3Qgcm95YWx0aWVzU2NoZWR1bGUgPSBudWxsO1xuLy8gICAgICAgICAgIGNvbnN0IGV4dHJpbnNpYyA9IGFwaS50eC5uZnQuY3JlYXRlQ29sbGVjdGlvbihcbi8vICAgICAgICAgICAgICdjb2xsZWN0aW9uTmFtZScsXG4vLyAgICAgICAgICAgICByb3lhbHRpZXNTY2hlZHVsZVxuLy8gICAgICAgICAgICk7XG4vL1xuLy8gICAgICAgICAgIGNvbnN0IGZlZUZyb21RdWVyeSA9IGF3YWl0IGFwaS5kZXJpdmUuZmVlcy5lc3RpbWF0ZUZlZSh7ZXh0cmluc2ljLCB1c2VyRmVlQXNzZXRJZDogQ0VOTlosIG1heFBheW1lbnR9KTtcbi8vICAgICAgICAgICBhd2FpdCBleHRyaW5zaWMuc2lnbkFuZFNlbmQoYWxpY2UsICB7dHJhbnNhY3Rpb25QYXltZW50fSBhcyBQYXJ0aWFsPFNpZ25lck9wdGlvbnM+LCBhc3luYyAoe2V2ZW50cywgc3RhdHVzfSkgPT4ge1xuLy8gICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0ZpbmFsaXplZCkge1xuLy8gICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaCgoe3BoYXNlLCBldmVudDoge2RhdGEsIG1ldGhvZCwgc2VjdGlvbn19KSA9PiB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ0Fzc2V0Qm91Z2h0Jykge1xuLy8gICAgICAgICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBkYXRhWzNdO1xuLy8gICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1xcdCcsIHBoYXNlLnRvU3RyaW5nKCksIGA6ICR7c2VjdGlvbn0uJHttZXRob2R9YCwgZGF0YS50b1N0cmluZygpKTtcbi8vICAgICAgICAgICAgICAgICAgIGV4cGVjdChmZWVGcm9tUXVlcnkudG9TdHJpbmcoKSkudG9FcXVhbChwcmljZS50b1N0cmluZygpKTtcbi8vICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcbi8vICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICBkZXNjcmliZSgnTmVnYXRpdmUgZmxvdyB3aXRoIG5vIGxpcXVpZGl0eSBpbiBwb29sJywgKCkgPT4ge1xuLy8gICAgICAgaXQoXCJDYWxjdWxhdGUgdGhlIGJ1eSBwcmljZSB3aGVuIGJ1eWluZyBDRU5UUkFQQVkgZm9yIFBMVUdcIiwgYXN5bmMgZG9uZSA9PiB7XG4vLyAgICAgICAgIGNvbnN0IGFtb3VudCA9IDEwMDtcbi8vICAgICAgICAgY29uc3QgcG9vbEFzc2V0QmFsYW5jZSA9IGF3YWl0IGFwaS5kZXJpdmUuY2Vubnp4LnBvb2xBc3NldEJhbGFuY2UoUExVRyk7XG4vLyAgICAgICAgIGNvbnN0IHBvb2xDb3JlQXNzZXRCYWxhbmNlID0gYXdhaXQgYXBpLmRlcml2ZS5jZW5uengucG9vbENvcmVBc3NldEJhbGFuY2UoUExVRyk7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKCdBbW91bnQgb2YgYXNzZXQgaW4gUExVRyBwb29sOicsIHBvb2xBc3NldEJhbGFuY2UudG9TdHJpbmcoKSk7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nKCdBbW91bnQgb2YgY29yZSBpbiBQTFVHIHBvb2w6JywgcG9vbENvcmVBc3NldEJhbGFuY2UudG9TdHJpbmcoKSk7XG4vLyAgICAgICAgIC8vIEhvdyBtdWNoIENFTlRSQVBBWSB3aWxsIGl0IGNvc3QgdG8gYnV5IDEwMCAoYW1vdW50KSBQTFVHXG4vLyAgICAgICAgIGF3YWl0IGV4cGVjdChhcGkucnBjLmNlbm56eC5idXlQcmljZShDRU5UUkFQQVksIGFtb3VudCwgUExVRykpLnJlamVjdHMudG9UaHJvdyhcbi8vICAgICAgICAgICAnMjogQ2Fubm90IGV4Y2hhbmdlIGZvciByZXF1ZXN0ZWQgYW1vdW50LjonXG4vLyAgICAgICAgICk7XG4vLyAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgIH0pO1xuLy9cbi8vICAgICAgIGl0KFwiQ2FsY3VsYXRlIHRoZSBzZWxsIHByaWNlIHdoZW4gc2VsbGluZyBQTFVHIGZvciBDRU5UUkFQQVkgd2hlbiBubyBsaXF1aWRpdHkgZXhpc3QgXCIsIGFzeW5jIGRvbmUgPT4ge1xuLy8gICAgICAgICBjb25zdCBhbW91bnQgPSAxMDAwO1xuLy8gICAgICAgICAvLyB3aGVuIEkgc2VsbCAxMDAwKGFtb3VudCkgUExVRywgaG93IG11Y2ggb2YgQ0VOVFJBUEFZIHdpbGwgSSBnZXQgaW4gcmV0dXJuXG4vLyAgICAgICAgIGF3YWl0IGV4cGVjdChhcGkucnBjLmNlbm56eFxuLy8gICAgICAgICAgIC5zZWxsUHJpY2UoUExVRywgYW1vdW50LCBDRU5UUkFQQVkpKS5yZWplY3RzLnRvVGhyb3coXG4vLyAgICAgICAgICAgJzI6IENhbm5vdCBleGNoYW5nZSBieSByZXF1ZXN0ZWQgYW1vdW50Lidcbi8vICAgICAgICAgKTtcbi8vICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgfSk7XG4vL1xuLy8gICAgICAgZGVzY3JpYmUoJ2ZlZUV4Y2hhbmdlIGRlcml2ZSBxdWVyaWVzIHdpdGggbmVnYXRpdmUgZmxvdycsICgpID0+IHtcbi8vXG4vLyAgICAgICAgIGl0KCdRdWVyeSBlc3RpbWF0ZWQgZmVlIGluIGRpZmZlcmVudCBjdXJyZW5jeSAoUExVRyknLCBhc3luYyBkb25lID0+IHtcbi8vICAgICAgICAgICBjb25zdCBtYXhQYXltZW50ID0gJzUwMDAwMDAwMDAwMDAwMDAwJztcbi8vICAgICAgICAgICBjb25zdCBleHRyaW5zaWMgPSBhcGkudHguZ2VuZXJpY0Fzc2V0XG4vLyAgICAgICAgICAgICAudHJhbnNmZXIoQ0VOTlosIGJvYi5hZGRyZXNzLCAxMDAwMCk7XG4vLyAgICAgICAgICAgY29uc3QgZmVlRnJvbVF1ZXJ5ID0gYXdhaXQgYXBpLmRlcml2ZS5mZWVzLmVzdGltYXRlRmVlKHtleHRyaW5zaWMsIHVzZXJGZWVBc3NldElkOlBMVUcsIG1heFBheW1lbnR9KTtcbi8vICAgICAgICAgICBleHBlY3QoZmVlRnJvbVF1ZXJ5KS50b0VxdWFsKG5ldyBFcnJvcignMjogQ2Fubm90IGV4Y2hhbmdlIGZvciByZXF1ZXN0ZWQgYW1vdW50LjogJykpO1xuLy8gICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgICB9KTtcbi8vICAgICB9KTtcbi8vXG4vLyAgIH0pO1xuLy8gfSk7XG4iXSwidmVyc2lvbiI6M30=