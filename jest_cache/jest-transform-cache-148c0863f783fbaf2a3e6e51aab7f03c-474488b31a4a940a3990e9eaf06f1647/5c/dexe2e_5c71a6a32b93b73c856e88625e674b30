8e4a8a2968f9ce5c4bfaca2c62bf9011
"use strict";
// // Copyright 2019-2020 Centrality Investments Limited
// //
// // Licensed under the Apache License, Version 2.0 (the "License");
// // you may not use this file except in compliance with the License.
// // You may obtain a copy of the License at
// //
// //     http://www.apache.org/licenses/LICENSE-2.0
// //
// // Unless required by applicable law or agreed to in writing, software
// // distributed under the License is distributed on an "AS IS" BASIS,
// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// // See the License for the specific language governing permissions and
// // limitations under the License.
// import { Api } from '@cennznet/api';
// import {SignerOptions} from "@polkadot/api/types";
// import { Keyring } from '@polkadot/keyring';
// import {BN} from "@polkadot/util";
// import { cryptoWaitReady } from '@polkadot/util-crypto';
// import initApiPromise from '../../../../jest/initApiPromise';
// import {Balance, LiquidityPriceResponse, LiquidityValueResponse} from '@cennznet/types';
// const CENNZ = '16000';
// const CENTRAPAY = '16001';
// const PLUG = '16003';
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.GAS_TOKEN_ID = exports.BOB_PRIVATE_KEY = exports.ALITH_PRIVATE_KEY = void 0;
exports.ALITH_PRIVATE_KEY = "0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133";
exports.BOB_PRIVATE_KEY = "0x79c3b7fc0b7697b9414cb87adcb37317d1cab32818ae18c0e97ad76395d1fdcf";
const TOKEN_ID = 1124;
exports.GAS_TOKEN_ID = 2;
const api_1 = require("@polkadot/api");
const api_2 = require("@therootnetwork/api");
const util_1 = require("@polkadot/util");
describe('DEX RPC calls testing', () => {
    let api;
    let alith, bob;
    beforeAll(async () => {
        const providerUrl = 'ws://127.0.0.1:9944/';
        const provider = new api_1.WsProvider(providerUrl);
        console.log('providerUrl', providerUrl);
        api = new api_1.ApiPromise((0, api_2.options)({ provider }));
        await api.isReady;
        const keyring = new api_1.Keyring({ type: "ethereum" });
        alith = keyring.addFromSeed((0, util_1.hexToU8a)(exports.ALITH_PRIVATE_KEY));
        bob = keyring.addFromSeed((0, util_1.hexToU8a)(exports.BOB_PRIVATE_KEY));
    });
    afterAll(async () => {
        api.disconnect();
    });
    describe('Queries()', () => {
        it("Deposit liquidity in CENNZ asset's pool", async () => {
            const txs = [
                api.tx.assetsExt.createAsset("test", "TEST", 18, 1, alith.address),
                api.tx.assets.mint(TOKEN_ID, alith.address, "10000000000000000"),
                api.tx.dex.addLiquidity(
                // provide liquidity
                TOKEN_ID, exports.GAS_TOKEN_ID, "1000000000000000", 250_000_000, "10000000000000000", 250_000_000, 0),
            ];
            await new Promise((resolve, reject) => {
                api.tx.utility
                    .batch(txs)
                    .signAndSend(alith, ({ events, status }) => {
                    if (status.isInBlock) {
                        console.log(`setup block hash: ${status.asInBlock}`);
                        if (status.isFinalized) {
                            for (const { event } of events) {
                                if (event.method === 'AddLiquidity') {
                                    resolve();
                                }
                            }
                        }
                    }
                })
                    .catch((err) => reject(err));
            });
            console.log("done setting up dex liquidity.");
        });
        it("getAmountsOut rpc works [library]", async () => {
            const result = await api.rpc.dex.getAmountsOut(100, [exports.GAS_TOKEN_ID, TOKEN_ID]);
            expect(result.OK).toEqual({ "OK": [100, 398799840958623] });
        });
        it("quote rpc works [http - axios]", async () => {
            const result = await api.rpc.dex.quote(1, 5, 10);
            expect(result.OK).toEqual({ "OK": 2 });
        });
        // it("Get the liquidity value for CENNZ asset in Alice's account", async done => {
        //   const liquidityValue: LiquidityValueResponse = await api.rpc.cennzx.liquidityValue(alice.address, CENNZ);
        //   expect(liquidityValue.liquidity.isZero()).toBe(false);
        //   expect(liquidityValue.core.isZero()).toBe(false);
        //   expect(liquidityValue.asset.isZero()).toBe(false);
        //   done();
        // });
        //
        // describe('Positive flow with liquidity in pool', () => {
        //   it("Calculate the buy price when buying CENTRAPAY for CENNZ", async done => {
        //     const amount = 100;
        //     const poolAssetBalance = await api.derive.cennzx.poolAssetBalance(CENNZ);
        //     const poolCoreAssetBalance = await api.derive.cennzx.poolCoreAssetBalance(CENNZ);
        //     console.log('Amount of asset in CENNZ pool:', poolAssetBalance.toString());
        //     console.log('Amount of core in CENNZ pool:', poolCoreAssetBalance.toString());
        //     // How much CENTRAPAY will it cost to buy 100 (amount) CENNZ
        //     const buyPrice = await api.rpc.cennzx.buyPrice(CENTRAPAY, amount, CENNZ);
        //     console.log('Buy price:', buyPrice.toString());
        //     expect(buyPrice.price.toNumber()).toBeGreaterThan(0);
        //     done();
        //   });
        //
        //   it("Calculate the sell price when selling CENNZ for CENTRAPAY ", async done => {
        //     const amount = 1000;
        //     // when I sell 1000(amount) CENNZ, how much of CENTRAPAY will I get in return
        //     const sellPrice = await api.rpc.cennzx
        //       .sellPrice(CENNZ, amount, CENTRAPAY);
        //     expect(sellPrice.price.toNumber()).toBeGreaterThan(0);
        //     done();
        //   });
        //
        //   describe('feeExchange derive queries with positive flow', () => {
        //     it('Query estimated fee in CENTRAPAY(default fee currency)', async done => {
        //       const assetBalanceBefore = await api.query.genericAsset.freeBalance(CENTRAPAY, alice.address);
        //       const extrinsic = api.tx.genericAsset
        //         .transfer(CENNZ, bob.address, 10000);
        //       const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId:CENTRAPAY});
        //
        //       await extrinsic.signAndSend(alice,  async ({events, status}) => {
        //         if (status.isFinalized) {
        //           events.forEach(({phase, event: {data, method, section}}) => {
        //             console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
        //           });
        //           const assetBalanceAfter = await api.query.genericAsset.freeBalance(CENTRAPAY, alice.address);
        //           expect((assetBalanceBefore as Balance).toBn().sub((assetBalanceAfter as Balance).toBn()).toString()).toEqual(feeFromQuery.toString());
        //           done();
        //         }
        //       });
        //     });
        //
        //     it('Query estimated fee in different currency (CENNZ)', async done => {
        //       const maxPayment = '50000000000000000';
        //       const assetId = api.registry.createType('AssetId', CENNZ);
        //       const feeExchange = api.registry.createType('FeeExchange', {assetId, maxPayment}, 0);
        //       const transactionPayment = api.registry.createType('ChargeTransactionPayment', {tip: 0, feeExchange});
        //       const royaltiesSchedule = null;
        //       const extrinsic = api.tx.nft.createCollection(
        //         'collectionName',
        //         royaltiesSchedule
        //       );
        //
        //       const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId: CENNZ, maxPayment});
        //       await extrinsic.signAndSend(alice,  {transactionPayment} as Partial<SignerOptions>, async ({events, status}) => {
        //         if (status.isFinalized) {
        //           events.forEach(({phase, event: {data, method, section}}) => {
        //             if (method === 'AssetBought') {
        //               const price = data[3];
        //               console.log('\t', phase.toString(), `: ${section}.${method}`, data.toString());
        //               expect(feeFromQuery.toString()).toEqual(price.toString());
        //               done();
        //             }
        //           });
        //         }
        //       });
        //     });
        //   });
        // });
        //
        // describe('Negative flow with no liquidity in pool', () => {
        //   it("Calculate the buy price when buying CENTRAPAY for PLUG", async done => {
        //     const amount = 100;
        //     const poolAssetBalance = await api.derive.cennzx.poolAssetBalance(PLUG);
        //     const poolCoreAssetBalance = await api.derive.cennzx.poolCoreAssetBalance(PLUG);
        //     console.log('Amount of asset in PLUG pool:', poolAssetBalance.toString());
        //     console.log('Amount of core in PLUG pool:', poolCoreAssetBalance.toString());
        //     // How much CENTRAPAY will it cost to buy 100 (amount) PLUG
        //     await expect(api.rpc.cennzx.buyPrice(CENTRAPAY, amount, PLUG)).rejects.toThrow(
        //       '2: Cannot exchange for requested amount.:'
        //     );
        //     done();
        //   });
        //
        //   it("Calculate the sell price when selling PLUG for CENTRAPAY when no liquidity exist ", async done => {
        //     const amount = 1000;
        //     // when I sell 1000(amount) PLUG, how much of CENTRAPAY will I get in return
        //     await expect(api.rpc.cennzx
        //       .sellPrice(PLUG, amount, CENTRAPAY)).rejects.toThrow(
        //       '2: Cannot exchange by requested amount.'
        //     );
        //     done();
        //   });
        //
        //   describe('feeExchange derive queries with negative flow', () => {
        //
        //     it('Query estimated fee in different currency (PLUG)', async done => {
        //       const maxPayment = '50000000000000000';
        //       const extrinsic = api.tx.genericAsset
        //         .transfer(CENNZ, bob.address, 10000);
        //       const feeFromQuery = await api.derive.fees.estimateFee({extrinsic, userFeeAssetId:PLUG, maxPayment});
        //       expect(feeFromQuery).toEqual(new Error('2: Cannot exchange for requested amount.: '));
        //       done();
        //     });
        //   });
        // });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2thcmlzaG1hL3dvcmsvZnV0dXJldmVyc2UvdHJuLXJvb3RuZXQtYXBpL3BhY2thZ2VzL2FwaS90ZXN0L2UyZS9kZXguZTJlLnRzIiwibWFwcGluZ3MiOiI7QUFBQSx3REFBd0Q7QUFDeEQsS0FBSztBQUNMLHFFQUFxRTtBQUNyRSxzRUFBc0U7QUFDdEUsNkNBQTZDO0FBQzdDLEtBQUs7QUFDTCxvREFBb0Q7QUFDcEQsS0FBSztBQUNMLHlFQUF5RTtBQUN6RSx1RUFBdUU7QUFDdkUsOEVBQThFO0FBQzlFLHlFQUF5RTtBQUN6RSxvQ0FBb0M7QUFDcEMsdUNBQXVDO0FBQ3ZDLHFEQUFxRDtBQUNyRCwrQ0FBK0M7QUFDL0MscUNBQXFDO0FBQ3JDLDJEQUEyRDtBQUMzRCxnRUFBZ0U7QUFDaEUsMkZBQTJGO0FBQzNGLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0Isd0JBQXdCO0FBQ3hCLEVBQUU7OztBQUVXLFFBQUEsaUJBQWlCLEdBQUcsb0VBQW9FLENBQUM7QUFDekYsUUFBQSxlQUFlLEdBQUcsb0VBQW9FLENBQUM7QUFDcEcsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ1QsUUFBQSxZQUFZLEdBQUcsQ0FBQyxDQUFDO0FBRTlCLHVDQUE4RDtBQUM5RCw2Q0FBNEM7QUFDNUMseUNBQXdDO0FBRXhDLFFBQVEsQ0FBQyx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7SUFDckMsSUFBSSxHQUFHLENBQUM7SUFDUixJQUFJLEtBQUssRUFBRSxHQUFHLENBQUM7SUFDZixTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDbkIsTUFBTSxXQUFXLEdBQUcsc0JBQXNCLENBQUM7UUFDM0MsTUFBTSxRQUFRLEdBQUcsSUFBSSxnQkFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3hDLEdBQUcsR0FBRyxJQUFJLGdCQUFVLENBQUMsSUFBQSxhQUFPLEVBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFD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O1FBQ2hILDBIQUEwSDtRQUMxSCxvQ0FBb0M7UUFDcEMsMEVBQTBFO1FBQzFFLDhDQUE4QztRQUM5Qyx1Q0FBdUM7UUFDdkMsZ0dBQWdHO1FBQ2hHLDJFQUEyRTtRQUMzRSx3QkFBd0I7UUFDeEIsZ0JBQWdCO1FBQ2hCLGdCQUFnQjtRQUNoQixZQUFZO1FBQ1osWUFBWTtRQUNaLFVBQVU7UUFDVixRQUFRO1FBQ1IsTUFBTTtRQUNOLEVBQUU7UUFDRiw4REFBOEQ7UUFDOUQsaUZBQWlGO1FBQ2pGLDBCQUEwQjtRQUMxQiwrRUFBK0U7UUFDL0UsdUZBQXVGO1FBQ3ZGLGlGQUFpRjtRQUNqRixvRkFBb0Y7UUFDcEYsa0VBQWtFO1FBQ2xFLHNGQUFzRjtRQUN0RixvREFBb0Q7UUFDcEQsU0FBUztRQUNULGNBQWM7UUFDZCxRQUFRO1FBQ1IsRUFBRTtRQUNGLDRHQUE0RztRQUM1RywyQkFBMkI7UUFDM0IsbUZBQW1GO1FBQ25GLGtDQUFrQztRQUNsQyw4REFBOEQ7UUFDOUQsa0RBQWtEO1FBQ2xELFNBQVM7UUFDVCxjQUFjO1FBQ2QsUUFBUTtRQUNSLEVBQUU7UUFDRixzRUFBc0U7UUFDdEUsRUFBRTtRQUNGLDZFQUE2RTtRQUM3RSxnREFBZ0Q7UUFDaEQsOENBQThDO1FBQzlDLGdEQUFnRDtRQUNoRCw4R0FBOEc7UUFDOUcsK0ZBQStGO1FBQy9GLGdCQUFnQjtRQUNoQixVQUFVO1FBQ1YsUUFBUTtRQUNSLE1BQU07SUFFUixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXJpc2htYS93b3JrL2Z1dHVyZXZlcnNlL3Rybi1yb290bmV0LWFwaS9wYWNrYWdlcy9hcGkvdGVzdC9lMmUvZGV4LmUyZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAvLyBDb3B5cmlnaHQgMjAxOS0yMDIwIENlbnRyYWxpdHkgSW52ZXN0bWVudHMgTGltaXRlZFxuLy8gLy9cbi8vIC8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyAvLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyAvLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vIC8vXG4vLyAvLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vLyAvL1xuLy8gLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyAvLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyAvLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vIGltcG9ydCB7IEFwaSB9IGZyb20gJ0BjZW5uem5ldC9hcGknO1xuLy8gaW1wb3J0IHtTaWduZXJPcHRpb25zfSBmcm9tIFwiQHBvbGthZG90L2FwaS90eXBlc1wiO1xuLy8gaW1wb3J0IHsgS2V5cmluZyB9IGZyb20gJ0Bwb2xrYWRvdC9rZXlyaW5nJztcbi8vIGltcG9ydCB7Qk59IGZyb20gXCJAcG9sa2Fkb3QvdXRpbFwiO1xuLy8gaW1wb3J0IHsgY3J5cHRvV2FpdFJlYWR5IH0gZnJvbSAnQHBvbGthZG90L3V0aWwtY3J5cHRvJztcbi8vIGltcG9ydCBpbml0QXBpUHJvbWlzZSBmcm9tICcuLi8uLi8uLi8uLi9qZXN0L2luaXRBcGlQcm9taXNlJztcbi8vIGltcG9ydCB7QmFsYW5jZSwgTGlxdWlkaXR5UHJpY2VSZXNwb25zZSwgTGlxdWlkaXR5VmFsdWVSZXNwb25zZX0gZnJvbSAnQGNlbm56bmV0L3R5cGVzJztcbi8vIGNvbnN0IENFTk5aID0gJzE2MDAwJztcbi8vIGNvbnN0IENFTlRSQVBBWSA9ICcxNjAwMSc7XG4vLyBjb25zdCBQTFVHID0gJzE2MDAzJztcbi8vXG5cbmV4cG9ydCBjb25zdCBBTElUSF9QUklWQVRFX0tFWSA9IFwiMHg1ZmI5MmQ2ZTk4ODg0Zjc2ZGU0NjhmYTNmNjI3OGY4ODA3YzQ4YmViYzEzNTk1ZDQ1YWY1YmRjNGRhNzAyMTMzXCI7XG5leHBvcnQgY29uc3QgQk9CX1BSSVZBVEVfS0VZID0gXCIweDc5YzNiN2ZjMGI3Njk3Yjk0MTRjYjg3YWRjYjM3MzE3ZDFjYWIzMjgxOGFlMThjMGU5N2FkNzYzOTVkMWZkY2ZcIjtcbmNvbnN0IFRPS0VOX0lEID0gMTEyNDtcbmV4cG9ydCBjb25zdCBHQVNfVE9LRU5fSUQgPSAyO1xuXG5pbXBvcnQge0FwaVByb21pc2UsIEtleXJpbmcsIFdzUHJvdmlkZXJ9IGZyb20gXCJAcG9sa2Fkb3QvYXBpXCI7XG5pbXBvcnQge29wdGlvbnN9IGZyb20gXCJAdGhlcm9vdG5ldHdvcmsvYXBpXCI7XG5pbXBvcnQge2hleFRvVThhfSBmcm9tIFwiQHBvbGthZG90L3V0aWxcIjtcblxuZGVzY3JpYmUoJ0RFWCBSUEMgY2FsbHMgdGVzdGluZycsICgpID0+IHtcbiAgbGV0IGFwaTtcbiAgbGV0IGFsaXRoLCBib2I7XG4gIGJlZm9yZUFsbChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXJVcmwgPSAnd3M6Ly8xMjcuMC4wLjE6OTk0NC8nO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFdzUHJvdmlkZXIocHJvdmlkZXJVcmwpO1xuICAgIGNvbnNvbGUubG9nKCdwcm92aWRlclVybCcsIHByb3ZpZGVyVXJsKTtcbiAgICBhcGkgPSBuZXcgQXBpUHJvbWlzZShvcHRpb25zKHsgcHJvdmlkZXIgfSkpO1xuICAgIGF3YWl0IGFwaS5pc1JlYWR5O1xuICAgIGNvbnN0IGtleXJpbmcgPSBuZXcgS2V5cmluZyh7IHR5cGU6IFwiZXRoZXJldW1cIiB9KTtcbiAgICBhbGl0aCA9IGtleXJpbmcuYWRkRnJvbVNlZWQoaGV4VG9VOGEoQUxJVEhfUFJJVkFURV9LRVkpKTtcbiAgICBib2IgPSBrZXlyaW5nLmFkZEZyb21TZWVkKGhleFRvVThhKEJPQl9QUklWQVRFX0tFWSkpO1xuICB9KTtcblxuICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgYXBpLmRpc2Nvbm5lY3QoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1F1ZXJpZXMoKScsICgpID0+IHtcblxuICAgIGl0KFwiRGVwb3NpdCBsaXF1aWRpdHkgaW4gQ0VOTlogYXNzZXQncyBwb29sXCIsICBhc3luYyAoKSA9PiB7XG5cbiAgICAgIGNvbnN0IHR4cyA9IFtcbiAgICAgICAgYXBpLnR4LmFzc2V0c0V4dC5jcmVhdGVBc3NldChcInRlc3RcIiwgXCJURVNUXCIsIDE4LCAxLCBhbGl0aC5hZGRyZXNzKSwgLy8gY3JlYXRlIGFzc2V0XG4gICAgICAgIGFwaS50eC5hc3NldHMubWludChUT0tFTl9JRCwgYWxpdGguYWRkcmVzcywgXCIxMDAwMDAwMDAwMDAwMDAwMFwiKSxcbiAgICAgICAgYXBpLnR4LmRleC5hZGRMaXF1aWRpdHkoXG4gICAgICAgICAgICAvLyBwcm92aWRlIGxpcXVpZGl0eVxuICAgICAgICAgICAgVE9LRU5fSUQsXG4gICAgICAgICAgICBHQVNfVE9LRU5fSUQsXG4gICAgICAgICAgICBcIjEwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgICAgIDI1MF8wMDBfMDAwLFxuICAgICAgICAgICAgXCIxMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICAgICAgMjUwXzAwMF8wMDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICApLFxuICAgICAgXTtcblxuICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhcGkudHgudXRpbGl0eVxuICAgICAgICAgICAgLmJhdGNoKHR4cylcbiAgICAgICAgICAgIC5zaWduQW5kU2VuZChhbGl0aCwgKHsgZXZlbnRzLCBzdGF0dXMgfSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc3RhdHVzLmlzSW5CbG9jaykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBzZXR1cCBibG9jayBoYXNoOiAke3N0YXR1cy5hc0luQmxvY2t9YCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5pc0ZpbmFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7ZXZlbnR9IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQubWV0aG9kID09PSAnQWRkTGlxdWlkaXR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiByZWplY3QoZXJyKSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coXCJkb25lIHNldHRpbmcgdXAgZGV4IGxpcXVpZGl0eS5cIik7XG4gICAgICAgICAgfSk7XG5cbiAgICBpdChcImdldEFtb3VudHNPdXQgcnBjIHdvcmtzIFtsaWJyYXJ5XVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoYXBpLnJwYyBhcyBhbnkpLmRleC5nZXRBbW91bnRzT3V0KDEwMCwgW0dBU19UT0tFTl9JRCwgVE9LRU5fSURdKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuT0spLnRvRXF1YWwoe1wiT0tcIjpbMTAwLCAzOTg3OTk4NDA5NTg2MjNdfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInF1b3RlIHJwYyB3b3JrcyBbaHR0cCAtIGF4aW9zXVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcGkucnBjLmRleC5xdW90ZSgxLCA1LCAxMCk7XG4gICAgICBleHBlY3QocmVzdWx0Lk9LKS50b0VxdWFsKHtcIk9LXCI6Mn0pO1xuICAgIH0pO1xuXG4gICAgLy8gaXQoXCJHZXQgdGhlIGxpcXVpZGl0eSB2YWx1ZSBmb3IgQ0VOTlogYXNzZXQgaW4gQWxpY2UncyBhY2NvdW50XCIsIGFzeW5jIGRvbmUgPT4ge1xuICAgIC8vICAgY29uc3QgbGlxdWlkaXR5VmFsdWU6IExpcXVpZGl0eVZhbHVlUmVzcG9uc2UgPSBhd2FpdCBhcGkucnBjLmNlbm56eC5saXF1aWRpdHlWYWx1ZShhbGljZS5hZGRyZXNzLCBDRU5OWik7XG4gICAgLy8gICBleHBlY3QobGlxdWlkaXR5VmFsdWUubGlxdWlkaXR5LmlzWmVybygpKS50b0JlKGZhbHNlKTtcbiAgICAvLyAgIGV4cGVjdChsaXF1aWRpdHlWYWx1ZS5jb3JlLmlzWmVybygpKS50b0JlKGZhbHNlKTtcbiAgICAvLyAgIGV4cGVjdChsaXF1aWRpdHlWYWx1ZS5hc3NldC5pc1plcm8oKSkudG9CZShmYWxzZSk7XG4gICAgLy8gICBkb25lKCk7XG4gICAgLy8gfSk7XG4gICAgLy9cbiAgICAvLyBkZXNjcmliZSgnUG9zaXRpdmUgZmxvdyB3aXRoIGxpcXVpZGl0eSBpbiBwb29sJywgKCkgPT4ge1xuICAgIC8vICAgaXQoXCJDYWxjdWxhdGUgdGhlIGJ1eSBwcmljZSB3aGVuIGJ1eWluZyBDRU5UUkFQQVkgZm9yIENFTk5aXCIsIGFzeW5jIGRvbmUgPT4ge1xuICAgIC8vICAgICBjb25zdCBhbW91bnQgPSAxMDA7XG4gICAgLy8gICAgIGNvbnN0IHBvb2xBc3NldEJhbGFuY2UgPSBhd2FpdCBhcGkuZGVyaXZlLmNlbm56eC5wb29sQXNzZXRCYWxhbmNlKENFTk5aKTtcbiAgICAvLyAgICAgY29uc3QgcG9vbENvcmVBc3NldEJhbGFuY2UgPSBhd2FpdCBhcGkuZGVyaXZlLmNlbm56eC5wb29sQ29yZUFzc2V0QmFsYW5jZShDRU5OWik7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKCdBbW91bnQgb2YgYXNzZXQgaW4gQ0VOTlogcG9vbDonLCBwb29sQXNzZXRCYWxhbmNlLnRvU3RyaW5nKCkpO1xuICAgIC8vICAgICBjb25zb2xlLmxvZygnQW1vdW50IG9mIGNvcmUgaW4gQ0VOTlogcG9vbDonLCBwb29sQ29yZUFzc2V0QmFsYW5jZS50b1N0cmluZygpKTtcbiAgICAvLyAgICAgLy8gSG93IG11Y2ggQ0VOVFJBUEFZIHdpbGwgaXQgY29zdCB0byBidXkgMTAwIChhbW91bnQpIENFTk5aXG4gICAgLy8gICAgIGNvbnN0IGJ1eVByaWNlID0gYXdhaXQgYXBpLnJwYy5jZW5uenguYnV5UHJpY2UoQ0VOVFJBUEFZLCBhbW91bnQsIENFTk5aKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2coJ0J1eSBwcmljZTonLCBidXlQcmljZS50b1N0cmluZygpKTtcbiAgICAvLyAgICAgZXhwZWN0KGJ1eVByaWNlLnByaWNlLnRvTnVtYmVyKCkpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAvLyAgICAgZG9uZSgpO1xuICAgIC8vICAgfSk7XG4gICAgLy9cbiAgICAvLyAgIGl0KFwiQ2FsY3VsYXRlIHRoZSBzZWxsIHByaWNlIHdoZW4gc2VsbGluZyBDRU5OWiBmb3IgQ0VOVFJBUEFZIFwiLCBhc3luYyBkb25lID0+IHtcbiAgICAvLyAgICAgY29uc3QgYW1vdW50ID0gMTAwMDtcbiAgICAvLyAgICAgLy8gd2hlbiBJIHNlbGwgMTAwMChhbW91bnQpIENFTk5aLCBob3cgbXVjaCBvZiBDRU5UUkFQQVkgd2lsbCBJIGdldCBpbiByZXR1cm5cbiAgICAvLyAgICAgY29uc3Qgc2VsbFByaWNlID0gYXdhaXQgYXBpLnJwYy5jZW5uenhcbiAgICAvLyAgICAgICAuc2VsbFByaWNlKENFTk5aLCBhbW91bnQsIENFTlRSQVBBWSk7XG4gICAgLy8gICAgIGV4cGVjdChzZWxsUHJpY2UucHJpY2UudG9OdW1iZXIoKSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIC8vICAgICBkb25lKCk7XG4gICAgLy8gICB9KTtcbiAgICAvL1xuICAgIC8vICAgZGVzY3JpYmUoJ2ZlZUV4Y2hhbmdlIGRlcml2ZSBxdWVyaWVzIHdpdGggcG9zaXRpdmUgZmxvdycsICgpID0+IHtcbiAgICAvLyAgICAgaXQoJ1F1ZXJ5IGVzdGltYXRlZCBmZWUgaW4gQ0VOVFJBUEFZKGRlZmF1bHQgZmVlIGN1cnJlbmN5KScsIGFzeW5jIGRvbmUgPT4ge1xuICAgIC8vICAgICAgIGNvbnN0IGFzc2V0QmFsYW5jZUJlZm9yZSA9IGF3YWl0IGFwaS5xdWVyeS5nZW5lcmljQXNzZXQuZnJlZUJhbGFuY2UoQ0VOVFJBUEFZLCBhbGljZS5hZGRyZXNzKTtcbiAgICAvLyAgICAgICBjb25zdCBleHRyaW5zaWMgPSBhcGkudHguZ2VuZXJpY0Fzc2V0XG4gICAgLy8gICAgICAgICAudHJhbnNmZXIoQ0VOTlosIGJvYi5hZGRyZXNzLCAxMDAwMCk7XG4gICAgLy8gICAgICAgY29uc3QgZmVlRnJvbVF1ZXJ5ID0gYXdhaXQgYXBpLmRlcml2ZS5mZWVzLmVzdGltYXRlRmVlKHtleHRyaW5zaWMsIHVzZXJGZWVBc3NldElkOkNFTlRSQVBBWX0pO1xuICAgIC8vXG4gICAgLy8gICAgICAgYXdhaXQgZXh0cmluc2ljLnNpZ25BbmRTZW5kKGFsaWNlLCAgYXN5bmMgKHtldmVudHMsIHN0YXR1c30pID0+IHtcbiAgICAvLyAgICAgICAgIGlmIChzdGF0dXMuaXNGaW5hbGl6ZWQpIHtcbiAgICAvLyAgICAgICAgICAgZXZlbnRzLmZvckVhY2goKHtwaGFzZSwgZXZlbnQ6IHtkYXRhLCBtZXRob2QsIHNlY3Rpb259fSkgPT4ge1xuICAgIC8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcXHQnLCBwaGFzZS50b1N0cmluZygpLCBgOiAke3NlY3Rpb259LiR7bWV0aG9kfWAsIGRhdGEudG9TdHJpbmcoKSk7XG4gICAgLy8gICAgICAgICAgIH0pO1xuICAgIC8vICAgICAgICAgICBjb25zdCBhc3NldEJhbGFuY2VBZnRlciA9IGF3YWl0IGFwaS5xdWVyeS5nZW5lcmljQXNzZXQuZnJlZUJhbGFuY2UoQ0VOVFJBUEFZLCBhbGljZS5hZGRyZXNzKTtcbiAgICAvLyAgICAgICAgICAgZXhwZWN0KChhc3NldEJhbGFuY2VCZWZvcmUgYXMgQmFsYW5jZSkudG9CbigpLnN1YigoYXNzZXRCYWxhbmNlQWZ0ZXIgYXMgQmFsYW5jZSkudG9CbigpKS50b1N0cmluZygpKS50b0VxdWFsKGZlZUZyb21RdWVyeS50b1N0cmluZygpKTtcbiAgICAvLyAgICAgICAgICAgZG9uZSgpO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICAgIH0pO1xuICAgIC8vICAgICB9KTtcbiAgICAvL1xuICAgIC8vICAgICBpdCgnUXVlcnkgZXN0aW1hdGVkIGZlZSBpbiBkaWZmZXJlbnQgY3VycmVuY3kgKENFTk5aKScsIGFzeW5jIGRvbmUgPT4ge1xuICAgIC8vICAgICAgIGNvbnN0IG1heFBheW1lbnQgPSAnNTAwMDAwMDAwMDAwMDAwMDAnO1xuICAgIC8vICAgICAgIGNvbnN0IGFzc2V0SWQgPSBhcGkucmVnaXN0cnkuY3JlYXRlVHlwZSgnQXNzZXRJZCcsIENFTk5aKTtcbiAgICAvLyAgICAgICBjb25zdCBmZWVFeGNoYW5nZSA9IGFwaS5yZWdpc3RyeS5jcmVhdGVUeXBlKCdGZWVFeGNoYW5nZScsIHthc3NldElkLCBtYXhQYXltZW50fSwgMCk7XG4gICAgLy8gICAgICAgY29uc3QgdHJhbnNhY3Rpb25QYXltZW50ID0gYXBpLnJlZ2lzdHJ5LmNyZWF0ZVR5cGUoJ0NoYXJnZVRyYW5zYWN0aW9uUGF5bWVudCcsIHt0aXA6IDAsIGZlZUV4Y2hhbmdlfSk7XG4gICAgLy8gICAgICAgY29uc3Qgcm95YWx0aWVzU2NoZWR1bGUgPSBudWxsO1xuICAgIC8vICAgICAgIGNvbnN0IGV4dHJpbnNpYyA9IGFwaS50eC5uZnQuY3JlYXRlQ29sbGVjdGlvbihcbiAgICAvLyAgICAgICAgICdjb2xsZWN0aW9uTmFtZScsXG4gICAgLy8gICAgICAgICByb3lhbHRpZXNTY2hlZHVsZVxuICAgIC8vICAgICAgICk7XG4gICAgLy9cbiAgICAvLyAgICAgICBjb25zdCBmZWVGcm9tUXVlcnkgPSBhd2FpdCBhcGkuZGVyaXZlLmZlZXMuZXN0aW1hdGVGZWUoe2V4dHJpbnNpYywgdXNlckZlZUFzc2V0SWQ6IENFTk5aLCBtYXhQYXltZW50fSk7XG4gICAgLy8gICAgICAgYXdhaXQgZXh0cmluc2ljLnNpZ25BbmRTZW5kKGFsaWNlLCAge3RyYW5zYWN0aW9uUGF5bWVudH0gYXMgUGFydGlhbDxTaWduZXJPcHRpb25zPiwgYXN5bmMgKHtldmVudHMsIHN0YXR1c30pID0+IHtcbiAgICAvLyAgICAgICAgIGlmIChzdGF0dXMuaXNGaW5hbGl6ZWQpIHtcbiAgICAvLyAgICAgICAgICAgZXZlbnRzLmZvckVhY2goKHtwaGFzZSwgZXZlbnQ6IHtkYXRhLCBtZXRob2QsIHNlY3Rpb259fSkgPT4ge1xuICAgIC8vICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdBc3NldEJvdWdodCcpIHtcbiAgICAvLyAgICAgICAgICAgICAgIGNvbnN0IHByaWNlID0gZGF0YVszXTtcbiAgICAvLyAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcXHQnLCBwaGFzZS50b1N0cmluZygpLCBgOiAke3NlY3Rpb259LiR7bWV0aG9kfWAsIGRhdGEudG9TdHJpbmcoKSk7XG4gICAgLy8gICAgICAgICAgICAgICBleHBlY3QoZmVlRnJvbVF1ZXJ5LnRvU3RyaW5nKCkpLnRvRXF1YWwocHJpY2UudG9TdHJpbmcoKSk7XG4gICAgLy8gICAgICAgICAgICAgICBkb25lKCk7XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICB9KTtcbiAgICAvLyAgICAgfSk7XG4gICAgLy8gICB9KTtcbiAgICAvLyB9KTtcbiAgICAvL1xuICAgIC8vIGRlc2NyaWJlKCdOZWdhdGl2ZSBmbG93IHdpdGggbm8gbGlxdWlkaXR5IGluIHBvb2wnLCAoKSA9PiB7XG4gICAgLy8gICBpdChcIkNhbGN1bGF0ZSB0aGUgYnV5IHByaWNlIHdoZW4gYnV5aW5nIENFTlRSQVBBWSBmb3IgUExVR1wiLCBhc3luYyBkb25lID0+IHtcbiAgICAvLyAgICAgY29uc3QgYW1vdW50ID0gMTAwO1xuICAgIC8vICAgICBjb25zdCBwb29sQXNzZXRCYWxhbmNlID0gYXdhaXQgYXBpLmRlcml2ZS5jZW5uengucG9vbEFzc2V0QmFsYW5jZShQTFVHKTtcbiAgICAvLyAgICAgY29uc3QgcG9vbENvcmVBc3NldEJhbGFuY2UgPSBhd2FpdCBhcGkuZGVyaXZlLmNlbm56eC5wb29sQ29yZUFzc2V0QmFsYW5jZShQTFVHKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2coJ0Ftb3VudCBvZiBhc3NldCBpbiBQTFVHIHBvb2w6JywgcG9vbEFzc2V0QmFsYW5jZS50b1N0cmluZygpKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2coJ0Ftb3VudCBvZiBjb3JlIGluIFBMVUcgcG9vbDonLCBwb29sQ29yZUFzc2V0QmFsYW5jZS50b1N0cmluZygpKTtcbiAgICAvLyAgICAgLy8gSG93IG11Y2ggQ0VOVFJBUEFZIHdpbGwgaXQgY29zdCB0byBidXkgMTAwIChhbW91bnQpIFBMVUdcbiAgICAvLyAgICAgYXdhaXQgZXhwZWN0KGFwaS5ycGMuY2Vubnp4LmJ1eVByaWNlKENFTlRSQVBBWSwgYW1vdW50LCBQTFVHKSkucmVqZWN0cy50b1Rocm93KFxuICAgIC8vICAgICAgICcyOiBDYW5ub3QgZXhjaGFuZ2UgZm9yIHJlcXVlc3RlZCBhbW91bnQuOidcbiAgICAvLyAgICAgKTtcbiAgICAvLyAgICAgZG9uZSgpO1xuICAgIC8vICAgfSk7XG4gICAgLy9cbiAgICAvLyAgIGl0KFwiQ2FsY3VsYXRlIHRoZSBzZWxsIHByaWNlIHdoZW4gc2VsbGluZyBQTFVHIGZvciBDRU5UUkFQQVkgd2hlbiBubyBsaXF1aWRpdHkgZXhpc3QgXCIsIGFzeW5jIGRvbmUgPT4ge1xuICAgIC8vICAgICBjb25zdCBhbW91bnQgPSAxMDAwO1xuICAgIC8vICAgICAvLyB3aGVuIEkgc2VsbCAxMDAwKGFtb3VudCkgUExVRywgaG93IG11Y2ggb2YgQ0VOVFJBUEFZIHdpbGwgSSBnZXQgaW4gcmV0dXJuXG4gICAgLy8gICAgIGF3YWl0IGV4cGVjdChhcGkucnBjLmNlbm56eFxuICAgIC8vICAgICAgIC5zZWxsUHJpY2UoUExVRywgYW1vdW50LCBDRU5UUkFQQVkpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgLy8gICAgICAgJzI6IENhbm5vdCBleGNoYW5nZSBieSByZXF1ZXN0ZWQgYW1vdW50LidcbiAgICAvLyAgICAgKTtcbiAgICAvLyAgICAgZG9uZSgpO1xuICAgIC8vICAgfSk7XG4gICAgLy9cbiAgICAvLyAgIGRlc2NyaWJlKCdmZWVFeGNoYW5nZSBkZXJpdmUgcXVlcmllcyB3aXRoIG5lZ2F0aXZlIGZsb3cnLCAoKSA9PiB7XG4gICAgLy9cbiAgICAvLyAgICAgaXQoJ1F1ZXJ5IGVzdGltYXRlZCBmZWUgaW4gZGlmZmVyZW50IGN1cnJlbmN5IChQTFVHKScsIGFzeW5jIGRvbmUgPT4ge1xuICAgIC8vICAgICAgIGNvbnN0IG1heFBheW1lbnQgPSAnNTAwMDAwMDAwMDAwMDAwMDAnO1xuICAgIC8vICAgICAgIGNvbnN0IGV4dHJpbnNpYyA9IGFwaS50eC5nZW5lcmljQXNzZXRcbiAgICAvLyAgICAgICAgIC50cmFuc2ZlcihDRU5OWiwgYm9iLmFkZHJlc3MsIDEwMDAwKTtcbiAgICAvLyAgICAgICBjb25zdCBmZWVGcm9tUXVlcnkgPSBhd2FpdCBhcGkuZGVyaXZlLmZlZXMuZXN0aW1hdGVGZWUoe2V4dHJpbnNpYywgdXNlckZlZUFzc2V0SWQ6UExVRywgbWF4UGF5bWVudH0pO1xuICAgIC8vICAgICAgIGV4cGVjdChmZWVGcm9tUXVlcnkpLnRvRXF1YWwobmV3IEVycm9yKCcyOiBDYW5ub3QgZXhjaGFuZ2UgZm9yIHJlcXVlc3RlZCBhbW91bnQuOiAnKSk7XG4gICAgLy8gICAgICAgZG9uZSgpO1xuICAgIC8vICAgICB9KTtcbiAgICAvLyAgIH0pO1xuICAgIC8vIH0pO1xuXG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=